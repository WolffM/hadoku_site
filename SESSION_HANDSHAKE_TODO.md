# Session Handshake - Server Implementation TODO

## Overview

The client-side implementation is complete. The server now needs to implement the session handshake protocol to enable stable sessionIds across page reloads.

**Key Architecture Changes:**
1. **Storage by sessionId, not authKey**: Preferences are now stored per sessionId (not per authKey)
2. **One preference object per device/tab**: Each sessionId gets its own preferences
3. **Multiple sessionIds per authKey**: Same authKey can have multiple active sessionIds (multi-device)
4. **Session mapping for continuity**: authKey → sessionId mapping tracks "most recent" sessionId
5. **Never delete old sessionIds**: Keep old preference objects - user might return to that device

**What This Means:**
- User with key=123 on Phone → sessionId=ABC → preferences stored at `prefs:ABC`
- Same user on Desktop → sessionId=DEF → preferences stored at `prefs:DEF`
- Both coexist! Phone keeps `ABC` settings, Desktop keeps `DEF` settings
- If Desktop reloads, it gets back `DEF` and its settings persist ✓

## Client Changes (COMPLETED ✓)

1. ✓ `session.ts` - Added handshake functions, storage management
   - Public users: Generate and maintain stable sessionId in localStorage indefinitely
   - Authenticated users: Perform server handshake to migrate preferences
2. ✓ `App.tsx` - Session initialization on mount with handshake
   - Public users: Use localStorage-based stable sessionId, never expires
   - Authenticated users: Use sessionId from parent props, sync with server
3. ✓ `usePreferences.ts` - Added support for external preference initialization
4. ✓ `client.ts` - Updated to sync ALL preferences to server (not just non-device-specific)

## Server Requirements

### Important: Public Users Don't Need Server Handshake

**Public users** (`userType: 'public'`):
- Generate and maintain a **stable sessionId in localStorage** (e.g., `public-1729123456-abc123`)
- This sessionId **never changes** (persists across page reloads indefinitely)
- No server handshake needed - all data stays in localStorage
- Preferences stay in localStorage forever (or until cleared by user)

**Authenticated users** (`userType: 'friend'`, `'admin'`, etc.):
- Receive sessionId from parent via props (generated by parent app based on auth key)
- Need server handshake to migrate preferences when sessionId changes
- Server stores preferences and maintains authKey → sessionId mapping

### 1. Session Handshake Endpoint

**Note**: This endpoint is **only called by authenticated users**, not public users.

**Endpoint:** `POST /task/api/session/handshake`

**Headers:**
- `X-User-Type`: The user type (friend, admin, etc.)
- `X-Session-Id`: The new sessionId
- `Content-Type`: application/json

**Request Body:**
```json
{
  "oldSessionId": "session-1729123456-abc123",  // null on first load
  "newSessionId": "session-1729234567-def456"   // from parent props
}
```

**Response:**
```json
{
  "sessionId": "session-1729234567-def456",
  "preferences": {
    "version": 1,
    "updatedAt": "2025-10-24T12:00:00Z",
    "theme": "dark",
    "showCompleteButton": true,
    "showDeleteButton": true,
    "showTagButton": false,
    "experimentalThemes": false,
    "alwaysVerticalLayout": false
  }
}
```

**Logic:**
```typescript
async function handleSessionHandshake(req) {
  const { oldSessionId, newSessionId } = req.body
  const authKey = extractAuthKeyFromRequest(req) // From URL param, cookie, etc.
  
  let preferences = null
  
  // Try to find existing preferences by oldSessionId
  if (oldSessionId) {
    preferences = await storage.getPreferencesBySessionId(oldSessionId)
    console.log('[Handshake] Found preferences for oldSessionId:', oldSessionId)
  }
  
  // If not found, try to find by authKey mapping (for backward compatibility or first load after restart)
  if (!preferences && authKey) {
    const existingSessionId = await storage.getSessionMapping(authKey)
    if (existingSessionId && existingSessionId !== newSessionId) {
      preferences = await storage.getPreferencesBySessionId(existingSessionId)
      console.log('[Handshake] Found preferences via authKey mapping:', existingSessionId)
    }
  }
  
  // If still not found, use defaults
  if (!preferences) {
    preferences = DEFAULT_PREFERENCES
    console.log('[Handshake] No existing preferences, using defaults')
  }
  
  // Save preferences under new sessionId (creates new preference object for this device)
  await storage.savePreferencesBySessionId(newSessionId, preferences)
  console.log('[Handshake] Saved preferences for newSessionId:', newSessionId)
  
  // Update authKey → sessionId mapping to point to the newest sessionId
  // This is used for continuity - next time this authKey loads, we'll check this mapping
  if (authKey) {
    await storage.updateSessionMapping(authKey, newSessionId)
    console.log('[Handshake] Updated session mapping for authKey:', authKey, '→', newSessionId)
  }
  
  // IMPORTANT: Do NOT delete old sessionId preferences
  // Keep them around - the user might return to that device/tab later
  // They're just localStorage-like data namespaced by sessionId
  
  return {
    sessionId: newSessionId,
    preferences
  }
}
```

**Critical Implementation Details:**

1. **Always create new preference object for newSessionId**: Even if copying from oldSessionId, save a NEW copy under newSessionId. This ensures each device/tab has independent preferences.

2. **Keep old sessionId preferences**: Don't delete old preference objects. Same authKey might have multiple devices/tabs, each with their own sessionId and preferences.

3. **Session mapping is a pointer**: The authKey → sessionId mapping just tracks the "most recent" sessionId for that key. It's used for backward compatibility and initial preference lookup.

4. **Return ALL preferences**: Don't filter anything out. Client expects complete UserPreferences object with theme, buttons, experimental flags, layout settings, etc.

### 2. Storage Interface Updates

Add to your Storage implementation:

```typescript
interface Storage {
  // ... existing methods ...
  
  // Preferences by sessionId (NEW - replaces any authKey-based preference storage)
  getPreferencesBySessionId(sessionId: string): Promise<UserPreferences | null>
  savePreferencesBySessionId(sessionId: string, prefs: UserPreferences): Promise<void>
  deletePreferencesBySessionId(sessionId: string): Promise<void>
  
  // Session mapping (authKey → currentSessionId)
  // Used for session continuity - when same authKey reloads, return same sessionId
  getSessionMapping(authKey: string): Promise<string | null>
  updateSessionMapping(authKey: string, sessionId: string): Promise<void>
}
```

**Important Notes:**
- **Multiple sessionIds per authKey**: Same authKey can have multiple active sessionIds (one per device/tab)
- **One preference object per sessionId**: Each sessionId has its own independent preferences
- **Session mapping tracks "current"**: The authKey → sessionId mapping tracks the most recent sessionId for that key
- **Don't delete old sessionIds**: Keep old sessionId preferences around - user might come back to that device

### 3. File Structure (Filesystem Storage)

```
data/
  sessions/
    {authKey}.json              → { "currentSessionId": "session-123", "updatedAt": "..." }
  preferences/
    session-123.json            → { "theme": "dark", "showCompleteButton": true, ... }
    session-456.json            → { "theme": "light", "showDeleteButton": false, ... }
    session-789.json            → { "theme": "ocean-dark", "experimentalThemes": true, ... }
    # Multiple preference files - one per sessionId
    # Same authKey can have multiple sessionIds (different devices/tabs)
  boards/
    {userType}-{sessionId}-boards.json
  tasks/
    {userType}-{sessionId}-{boardId}-tasks.json
```

**Or for KV Storage (Cloudflare Workers):**
```
KV Keys:
  session:{authKey}                     → "session-123"
  prefs:{sessionId}                     → { "theme": "dark", ... }
  prefs:session-123                     → { preferences for device 1 }
  prefs:session-456                     → { preferences for device 2 }
  prefs:session-789                     → { preferences for device 3 }
  boards:{userType}:{sessionId}         → { ... }
  tasks:{userType}:{sessionId}:{boardId} → { ... }
```

**Key Points:**
- One authKey can have **multiple active sessionIds** (multi-device support)
- Each sessionId has its **own preferences object** (device-specific settings)
- Session mapping (`session:{authKey}`) tracks the **most recent** sessionId for continuity
- Old sessionId preferences are **kept** (not deleted) - user might return to that device

### 4. Update Existing Preferences Endpoints

**CRITICAL**: These endpoints must be updated to use sessionId-based storage instead of authKey-based storage.

**GET /task/api/preferences**
- **Current behavior**: May fetch preferences by authKey or other identifier
- **New behavior**: MUST fetch by sessionId
- Use `X-Session-Id` header to identify which preferences to fetch
- Query: `storage.getPreferencesBySessionId(sessionId)`
- Return ALL preferences (theme, buttons, experimental flags, layout, etc.)
- Do NOT filter out "device-specific" settings - client needs everything

**PUT /task/api/preferences**
- **Current behavior**: May save preferences by authKey or other identifier
- **New behavior**: MUST save by sessionId
- Use `X-Session-Id` header to identify where to save
- Accept ALL preference fields (theme, buttons, experimental flags, layout, etc.)
- Merge with existing preferences: `const updated = { ...existing, ...newPrefs, updatedAt: now }`
- Save: `storage.savePreferencesBySessionId(sessionId, updated)`
- Do NOT reject "device-specific" settings - store everything the client sends

**Why This Change Is Critical:**
- Each device/tab needs its own preference storage (via unique sessionId)
- Same authKey can have multiple sessionIds (one per device/tab)
- Server must maintain MULTIPLE preference objects per authKey (one per sessionId)
- Old approach of one preference object per authKey doesn't support multi-device

## Testing Checklist

### Basic Functionality
- [ ] First load with no stored sessionId → gets defaults
- [ ] Reload page with same authKey → gets same preferences
- [ ] Change theme → persists across reload
- [ ] New authKey (different key param) → starts fresh with defaults
- [ ] Mobile/Capacitor app reload → preserves preferences

### Multi-Device Support
- [ ] Device 1 sets theme=dark → Device 2 has theme=light → Both persist independently
- [ ] Device 1 changes theme → Device 2 theme unchanged
- [ ] authKey → sessionId mapping tracks most recent device's sessionId
- [ ] Old device sessionIds still work when returning to that device

### Storage Verification
- [ ] Multiple preference files exist for same authKey (one per sessionId)
- [ ] Old sessionId preferences are NOT deleted when new sessionId is created
- [ ] GET /preferences with sessionId=ABC returns ABC's preferences
- [ ] GET /preferences with sessionId=DEF returns DEF's preferences (different object)

## Server Implementation Checklist

### Phase 1: Storage Layer
- [ ] Add `getPreferencesBySessionId(sessionId)` method
- [ ] Add `savePreferencesBySessionId(sessionId, prefs)` method
- [ ] Add `getSessionMapping(authKey)` method
- [ ] Add `updateSessionMapping(authKey, sessionId)` method
- [ ] Create `preferences/` directory (or KV namespace)
- [ ] Create `sessions/` directory (or KV namespace)

### Phase 2: Handshake Endpoint
- [ ] Create `POST /task/api/session/handshake` endpoint
- [ ] Parse `oldSessionId` and `newSessionId` from request body
- [ ] Extract authKey from request (URL param, header, etc.)
- [ ] Lookup preferences by oldSessionId first
- [ ] Fallback to authKey mapping if oldSessionId not found
- [ ] Use defaults if no preferences found
- [ ] Save preferences under newSessionId
- [ ] Update authKey → sessionId mapping
- [ ] Return preferences + sessionId in response
- [ ] Add logging for debugging

### Phase 3: Update Existing Endpoints
- [ ] Update `GET /task/api/preferences` to use `X-Session-Id` header
- [ ] Update `PUT /task/api/preferences` to use `X-Session-Id` header
- [ ] Ensure PUT merges with existing preferences (don't overwrite completely)
- [ ] Ensure ALL preference fields are stored (theme, buttons, flags, layout)
- [ ] Remove any authKey-based preference storage (replaced by sessionId-based)

### Phase 4: Testing
- [ ] Test handshake with oldSessionId=null (first load)
- [ ] Test handshake with existing oldSessionId
- [ ] Test preference persistence across reloads
- [ ] Test multi-device scenario (two different sessionIds, same authKey)
- [ ] Verify old sessionId preferences are kept
- [ ] Verify session mapping updates correctly

## Migration Notes

**Existing Users:**
- Old localStorage preferences will be migrated via handshake
- On first handshake with oldSessionId=null, server checks authKey mapping
- If authKey has existing session, use those preferences
- Otherwise, start fresh

## Security Considerations

- sessionId is NOT a secret - it's a namespace for storage
- authKey is the security token - validate on all API requests
- Session mapping prevents storage collisions
- Each device can have independent sessionId for device-specific storage

## Benefits

✓ Theme and preferences persist across page reloads
✓ Stable storage keys (no orphaned localStorage entries)
✓ Multi-device support (each device has its own sessionId)
✓ Capacitor app friendly (handles navigation patterns)
✓ Backward compatible (migrates existing preferences)
