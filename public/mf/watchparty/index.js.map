{"version":3,"file":"index.js","sources":["../../../node_modules/.pnpm/react@19.1.1/node_modules/react/cjs/react-jsx-runtime.production.js","../../../node_modules/.pnpm/react@19.1.1/node_modules/react/jsx-runtime.js","../../../node_modules/.pnpm/react-dom@19.1.1_react@19.1.1/node_modules/react-dom/cjs/react-dom.production.js","../../../node_modules/.pnpm/react-dom@19.1.1_react@19.1.1/node_modules/react-dom/index.js","../../../node_modules/.pnpm/@remix-run+router@1.23.0/node_modules/@remix-run/router/dist/router.js","../../../node_modules/.pnpm/react-router@6.30.1_react@19.1.1/node_modules/react-router/dist/index.js","../../../node_modules/.pnpm/react-router-dom@6.30.1_react-dom@19.1.1_react@19.1.1/node_modules/react-router-dom/dist/index.js","../../../node_modules/.pnpm/zustand@4.5.7_@types+react@18.3.25_react@19.1.1/node_modules/zustand/esm/vanilla.mjs","../../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.1/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js","../../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.1/node_modules/use-sync-external-store/shim/index.js","../../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.1/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js","../../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.1/node_modules/use-sync-external-store/shim/with-selector.js","../../../node_modules/.pnpm/zustand@4.5.7_@types+react@18.3.25_react@19.1.1/node_modules/zustand/esm/index.mjs","../src/lib/characters.ts","../src/lib/store.ts","../src/components/Toasts.tsx","../src/components/StarfieldCanvas.tsx","../src/routes/Home.tsx","../src/components/Roster.tsx","../../../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/esm/commons.js","../../../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/esm/encodePacket.browser.js","../../../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js","../../../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/esm/decodePacket.browser.js","../../../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/esm/index.js","../../../node_modules/.pnpm/@socket.io+component-emitter@3.1.2/node_modules/@socket.io/component-emitter/lib/esm/index.js","../../../node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/globals.js","../../../node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/util.js","../../../node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/contrib/parseqs.js","../../../node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/transport.js","../../../node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/transports/polling.js","../../../node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/contrib/has-cors.js","../../../node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/transports/polling-xhr.js","../../../node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/transports/websocket.js","../../../node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/transports/webtransport.js","../../../node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/transports/index.js","../../../node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/contrib/parseuri.js","../../../node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/socket.js","../../../node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/url.js","../../../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/esm/is-binary.js","../../../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/esm/binary.js","../../../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/esm/index.js","../../../node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/on.js","../../../node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/socket.js","../../../node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/contrib/backo2.js","../../../node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/manager.js","../../../node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/index.js","../src/lib/config.ts","../src/lib/socket.ts","../src/components/MediaPlayer.tsx","../src/lib/catalog.ts","../src/lib/controls.ts","../src/lib/catalogProbe.ts","../src/components/MediaDrawer.tsx","../src/components/CharacterDrawer.tsx","../src/routes/Room.tsx","../src/components/APIDownFallback.tsx","../src/App.tsx","../src/router.tsx","../src/entry.tsx"],"sourcesContent":["/**\n * @license React\n * react-jsx-runtime.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n  REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\nfunction jsxProd(type, config, maybeKey) {\n  var key = null;\n  void 0 !== maybeKey && (key = \"\" + maybeKey);\n  void 0 !== config.key && (key = \"\" + config.key);\n  if (\"key\" in config) {\n    maybeKey = {};\n    for (var propName in config)\n      \"key\" !== propName && (maybeKey[propName] = config[propName]);\n  } else maybeKey = config;\n  config = maybeKey.ref;\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key,\n    ref: void 0 !== config ? config : null,\n    props: maybeKey\n  };\n}\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsxProd;\nexports.jsxs = jsxProd;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n","/**\n * @license React\n * react-dom.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar React = require(\"react\");\nfunction formatProdErrorMessage(code) {\n  var url = \"https://react.dev/errors/\" + code;\n  if (1 < arguments.length) {\n    url += \"?args[]=\" + encodeURIComponent(arguments[1]);\n    for (var i = 2; i < arguments.length; i++)\n      url += \"&args[]=\" + encodeURIComponent(arguments[i]);\n  }\n  return (\n    \"Minified React error #\" +\n    code +\n    \"; visit \" +\n    url +\n    \" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\"\n  );\n}\nfunction noop() {}\nvar Internals = {\n    d: {\n      f: noop,\n      r: function () {\n        throw Error(formatProdErrorMessage(522));\n      },\n      D: noop,\n      C: noop,\n      L: noop,\n      m: noop,\n      X: noop,\n      S: noop,\n      M: noop\n    },\n    p: 0,\n    findDOMNode: null\n  },\n  REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\nfunction createPortal$1(children, containerInfo, implementation) {\n  var key =\n    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;\n  return {\n    $$typeof: REACT_PORTAL_TYPE,\n    key: null == key ? null : \"\" + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\nvar ReactSharedInternals =\n  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\nfunction getCrossOriginStringAs(as, input) {\n  if (\"font\" === as) return \"\";\n  if (\"string\" === typeof input)\n    return \"use-credentials\" === input ? input : \"\";\n}\nexports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\n  Internals;\nexports.createPortal = function (children, container) {\n  var key =\n    2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;\n  if (\n    !container ||\n    (1 !== container.nodeType &&\n      9 !== container.nodeType &&\n      11 !== container.nodeType)\n  )\n    throw Error(formatProdErrorMessage(299));\n  return createPortal$1(children, container, null, key);\n};\nexports.flushSync = function (fn) {\n  var previousTransition = ReactSharedInternals.T,\n    previousUpdatePriority = Internals.p;\n  try {\n    if (((ReactSharedInternals.T = null), (Internals.p = 2), fn)) return fn();\n  } finally {\n    (ReactSharedInternals.T = previousTransition),\n      (Internals.p = previousUpdatePriority),\n      Internals.d.f();\n  }\n};\nexports.preconnect = function (href, options) {\n  \"string\" === typeof href &&\n    (options\n      ? ((options = options.crossOrigin),\n        (options =\n          \"string\" === typeof options\n            ? \"use-credentials\" === options\n              ? options\n              : \"\"\n            : void 0))\n      : (options = null),\n    Internals.d.C(href, options));\n};\nexports.prefetchDNS = function (href) {\n  \"string\" === typeof href && Internals.d.D(href);\n};\nexports.preinit = function (href, options) {\n  if (\"string\" === typeof href && options && \"string\" === typeof options.as) {\n    var as = options.as,\n      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),\n      integrity =\n        \"string\" === typeof options.integrity ? options.integrity : void 0,\n      fetchPriority =\n        \"string\" === typeof options.fetchPriority\n          ? options.fetchPriority\n          : void 0;\n    \"style\" === as\n      ? Internals.d.S(\n          href,\n          \"string\" === typeof options.precedence ? options.precedence : void 0,\n          {\n            crossOrigin: crossOrigin,\n            integrity: integrity,\n            fetchPriority: fetchPriority\n          }\n        )\n      : \"script\" === as &&\n        Internals.d.X(href, {\n          crossOrigin: crossOrigin,\n          integrity: integrity,\n          fetchPriority: fetchPriority,\n          nonce: \"string\" === typeof options.nonce ? options.nonce : void 0\n        });\n  }\n};\nexports.preinitModule = function (href, options) {\n  if (\"string\" === typeof href)\n    if (\"object\" === typeof options && null !== options) {\n      if (null == options.as || \"script\" === options.as) {\n        var crossOrigin = getCrossOriginStringAs(\n          options.as,\n          options.crossOrigin\n        );\n        Internals.d.M(href, {\n          crossOrigin: crossOrigin,\n          integrity:\n            \"string\" === typeof options.integrity ? options.integrity : void 0,\n          nonce: \"string\" === typeof options.nonce ? options.nonce : void 0\n        });\n      }\n    } else null == options && Internals.d.M(href);\n};\nexports.preload = function (href, options) {\n  if (\n    \"string\" === typeof href &&\n    \"object\" === typeof options &&\n    null !== options &&\n    \"string\" === typeof options.as\n  ) {\n    var as = options.as,\n      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);\n    Internals.d.L(href, as, {\n      crossOrigin: crossOrigin,\n      integrity:\n        \"string\" === typeof options.integrity ? options.integrity : void 0,\n      nonce: \"string\" === typeof options.nonce ? options.nonce : void 0,\n      type: \"string\" === typeof options.type ? options.type : void 0,\n      fetchPriority:\n        \"string\" === typeof options.fetchPriority\n          ? options.fetchPriority\n          : void 0,\n      referrerPolicy:\n        \"string\" === typeof options.referrerPolicy\n          ? options.referrerPolicy\n          : void 0,\n      imageSrcSet:\n        \"string\" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,\n      imageSizes:\n        \"string\" === typeof options.imageSizes ? options.imageSizes : void 0,\n      media: \"string\" === typeof options.media ? options.media : void 0\n    });\n  }\n};\nexports.preloadModule = function (href, options) {\n  if (\"string\" === typeof href)\n    if (options) {\n      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);\n      Internals.d.m(href, {\n        as:\n          \"string\" === typeof options.as && \"script\" !== options.as\n            ? options.as\n            : void 0,\n        crossOrigin: crossOrigin,\n        integrity:\n          \"string\" === typeof options.integrity ? options.integrity : void 0\n      });\n    } else Internals.d.m(href);\n};\nexports.requestFormReset = function (form) {\n  Internals.d.r(form);\n};\nexports.unstable_batchedUpdates = function (fn, a) {\n  return fn(a);\n};\nexports.useFormState = function (action, initialState, permalink) {\n  return ReactSharedInternals.H.useFormState(action, initialState, permalink);\n};\nexports.useFormStatus = function () {\n  return ReactSharedInternals.H.useHostTransitionStatus();\n};\nexports.version = \"19.1.1\";\n","'use strict';\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (process.env.NODE_ENV === 'production') {\n  // DCE check should happen before ReactDOM bundle executes so that\n  // DevTools can report bad minification during injection.\n  checkDCE();\n  module.exports = require('./cjs/react-dom.production.js');\n} else {\n  module.exports = require('./cjs/react-dom.development.js');\n}\n","/**\n * @remix-run/router v1.23.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Actions represent the type of change to a location value.\n */\nvar Action;\n(function (Action) {\n  /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */\n  Action[\"Pop\"] = \"POP\";\n  /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */\n  Action[\"Push\"] = \"PUSH\";\n  /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */\n  Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\nconst PopStateEventType = \"popstate\";\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    initialEntries = [\"/\"],\n    initialIndex,\n    v5Compat = false\n  } = options;\n  let entries; // Declare so we can access from createMemoryLocation\n  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index === 0 ? \"default\" : undefined));\n  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n  let action = Action.Pop;\n  let listener = null;\n  function clampIndex(n) {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation() {\n    return entries[index];\n  }\n  function createMemoryLocation(to, state, key) {\n    if (state === void 0) {\n      state = null;\n    }\n    let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\n    return location;\n  }\n  function createHref(to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  let history = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref,\n    createURL(to) {\n      return new URL(createHref(to), \"http://localhost\");\n    },\n    encodeLocation(to) {\n      let path = typeof to === \"string\" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || \"\",\n        search: path.search || \"\",\n        hash: path.hash || \"\"\n      };\n    },\n    push(to, state) {\n      action = Action.Push;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 1\n        });\n      }\n    },\n    replace(to, state) {\n      action = Action.Replace;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 0\n        });\n      }\n    },\n    go(delta) {\n      action = Action.Pop;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta\n        });\n      }\n    },\n    listen(fn) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    }\n  };\n  return history;\n}\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createBrowserLocation(window, globalHistory) {\n    let {\n      pathname,\n      search,\n      hash\n    } = window.location;\n    return createLocation(\"\", {\n      pathname,\n      search,\n      hash\n    },\n    // state defaults to `null` because `window.history.state` does\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n  }\n  function createBrowserHref(window, to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createHashLocation(window, globalHistory) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\"\n    } = parsePath(window.location.hash.substr(1));\n    // Hash URL should always have a leading / just like window.location.pathname\n    // does, so if an app ends up at a route like /#something then we add a\n    // leading slash so all of our path-matching behaves the same as if it would\n    // in a browser router.  This is particularly important when there exists a\n    // root splat route (<Route path=\"*\">) since that matches internally against\n    // \"/*\" and we'd expect /#something to 404 in a hash router app.\n    if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n      pathname = \"/\" + pathname;\n    }\n    return createLocation(\"\", {\n      pathname,\n      search,\n      hash\n    },\n    // state defaults to `null` because `window.history.state` does\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n  }\n  function createHashHref(window, to) {\n    let base = window.document.querySelector(\"base\");\n    let href = \"\";\n    if (base && base.getAttribute(\"href\")) {\n      let url = window.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n  function validateHashLocation(location, to) {\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\n  }\n  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience, so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\n * For browser-based histories, we combine the state and key into an object\n */\nfunction getHistoryState(location, index) {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index\n  };\n}\n/**\n * Creates a Location object with a unique key from the given Path\n */\nfunction createLocation(current, to, state, key) {\n  if (state === void 0) {\n    state = null;\n  }\n  let location = _extends({\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\"\n  }, typeof to === \"string\" ? parsePath(to) : to, {\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: to && to.key || key || createKey()\n  });\n  return location;\n}\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */\nfunction createPath(_ref) {\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\"\n  } = _ref;\n  if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */\nfunction parsePath(path) {\n  let parsedPath = {};\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n  return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    window = document.defaultView,\n    v5Compat = false\n  } = options;\n  let globalHistory = window.history;\n  let action = Action.Pop;\n  let listener = null;\n  let index = getIndex();\n  // Index should only be null when we initialize. If not, it's because the\n  // user called history.pushState or history.replaceState directly, in which\n  // case we should log a warning as it will result in bugs.\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), \"\");\n  }\n  function getIndex() {\n    let state = globalHistory.state || {\n      idx: null\n    };\n    return state.idx;\n  }\n  function handlePop() {\n    action = Action.Pop;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({\n        action,\n        location: history.location,\n        delta\n      });\n    }\n  }\n  function push(to, state) {\n    action = Action.Push;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    // try...catch because iOS limits us to 100 pushState calls :/\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      // If the exception is because `state` can't be serialized, let that throw\n      // outwards just like a replace call would so the dev knows the cause\n      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n      if (error instanceof DOMException && error.name === \"DataCloneError\") {\n        throw error;\n      }\n      // They are going to lose state here, but there is no real\n      // way to warn them about it since the page will refresh...\n      window.location.assign(url);\n    }\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 1\n      });\n    }\n  }\n  function replace(to, state) {\n    action = Action.Replace;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 0\n      });\n    }\n  }\n  function createURL(to) {\n    // window.location.origin is \"null\" (the literal string value) in Firefox\n    // under certain conditions, notably when serving from a local HTML file\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n    let base = window.location.origin !== \"null\" ? window.location.origin : window.location.href;\n    let href = typeof to === \"string\" ? to : createPath(to);\n    // Treating this as a full URL will strip any trailing spaces so we need to\n    // pre-encode them since they might be part of a matching splat param from\n    // an ancestor route\n    href = href.replace(/ $/, \"%20\");\n    invariant(base, \"No window.location.(origin|href) available to create URL for href: \" + href);\n    return new URL(href, base);\n  }\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window, globalHistory);\n    },\n    listen(fn) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n      return () => {\n        window.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      // Encode a Location the same way window.location would\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    }\n  };\n  return history;\n}\n//#endregion\n\nvar ResultType;\n(function (ResultType) {\n  ResultType[\"data\"] = \"data\";\n  ResultType[\"deferred\"] = \"deferred\";\n  ResultType[\"redirect\"] = \"redirect\";\n  ResultType[\"error\"] = \"error\";\n})(ResultType || (ResultType = {}));\nconst immutableRouteKeys = new Set([\"lazy\", \"caseSensitive\", \"path\", \"id\", \"index\", \"children\"]);\nfunction isIndexRoute(route) {\n  return route.index === true;\n}\n// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject's within the Router\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  if (manifest === void 0) {\n    manifest = {};\n  }\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, String(index)];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(route.index !== true || !route.children, \"Cannot specify children on an index route\");\n    invariant(!manifest[id], \"Found a route id collision on id \\\"\" + id + \"\\\".  Route \" + \"id's must be globally unique within Data Router usages\");\n    if (isIndexRoute(route)) {\n      let indexRoute = _extends({}, route, mapRouteProperties(route), {\n        id\n      });\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {\n        id,\n        children: undefined\n      });\n      manifest[id] = pathOrLayoutRoute;\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);\n      }\n      return pathOrLayoutRoute;\n    }\n  });\n}\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/v6/utils/match-routes\n */\nfunction matchRoutes(routes, locationArg, basename) {\n  if (basename === void 0) {\n    basename = \"/\";\n  }\n  return matchRoutesImpl(routes, locationArg, basename, false);\n}\nfunction matchRoutesImpl(routes, locationArg, basename, allowPartial) {\n  let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n  if (pathname == null) {\n    return null;\n  }\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    // Incoming pathnames are generally encoded from either window.location\n    // or from router.navigate, but we want to match against the unencoded\n    // paths in the route definitions.  Memory router locations won't be\n    // encoded here but there also shouldn't be anything to decode so this\n    // should be a safe operation.  This avoids needing matchRoutes to be\n    // history-aware.\n    let decoded = decodePath(pathname);\n    matches = matchRouteBranch(branches[i], decoded, allowPartial);\n  }\n  return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n  let {\n    route,\n    pathname,\n    params\n  } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id],\n    handle: route.handle\n  };\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n  if (branches === void 0) {\n    branches = [];\n  }\n  if (parentsMeta === void 0) {\n    parentsMeta = [];\n  }\n  if (parentPath === void 0) {\n    parentPath = \"\";\n  }\n  let flattenRoute = (route, index, relativePath) => {\n    let meta = {\n      relativePath: relativePath === undefined ? route.path || \"\" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route\n    };\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(meta.relativePath.startsWith(parentPath), \"Absolute route path \\\"\" + meta.relativePath + \"\\\" nested under path \" + (\"\\\"\" + parentPath + \"\\\" is not valid. An absolute child route path \") + \"must start with the combined path of all its parent routes.\");\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n    // Add the children before adding this route to the array, so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n      // Our types know better, but runtime JS may not!\n      // @ts-expect-error\n      route.index !== true, \"Index routes must not have child routes. Please remove \" + (\"all child routes from route path \\\"\" + path + \"\\\".\"));\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta\n    });\n  };\n  routes.forEach((route, index) => {\n    var _route$path;\n    // coarse-grain check for optional params\n    if (route.path === \"\" || !((_route$path = route.path) != null && _route$path.includes(\"?\"))) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n  return branches;\n}\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */\nfunction explodeOptionalSegments(path) {\n  let segments = path.split(\"/\");\n  if (segments.length === 0) return [];\n  let [first, ...rest] = segments;\n  // Optional path segments are denoted by a trailing `?`\n  let isOptional = first.endsWith(\"?\");\n  // Compute the corresponding required segment: `foo?` -> `foo`\n  let required = first.replace(/\\?$/, \"\");\n  if (rest.length === 0) {\n    // Intepret empty string as omitting an optional segment\n    // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n    return isOptional ? [required, \"\"] : [required];\n  }\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n  let result = [];\n  // All child paths with the prefix.  Do this for all children before the\n  // optional version for all children, so we get consistent ordering where the\n  // parent optional aspect is preferred as required.  Otherwise, we can get\n  // child sections interspersed where deeper optional segments are higher than\n  // parent optional segments, where for example, /:two would explode _earlier_\n  // then /:one.  By always including the parent as required _for all children_\n  // first, we avoid this issue\n  result.push(...restExploded.map(subpath => subpath === \"\" ? required : [required, subpath].join(\"/\")));\n  // Then, if this is an optional value, add all child versions without\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n  // for absolute paths, ensure `/` instead of empty segment\n  return result.map(exploded => path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\n}\nfunction rankRouteBranches(branches) {\n  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first\n  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));\n}\nconst paramRe = /^:[\\w-]+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = s => s === \"*\";\nfunction computeScore(path, index) {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n  return siblings ?\n  // If two routes are siblings, we should try to match the earlier sibling\n  // first. This allows people to have fine-grained control over the matching\n  // behavior by simply putting routes with identical paths in the order they\n  // want them tried.\n  a[a.length - 1] - b[b.length - 1] :\n  // Otherwise, it doesn't really make sense to rank non-siblings by index,\n  // so they sort equally.\n  0;\n}\nfunction matchRouteBranch(branch, pathname, allowPartial) {\n  if (allowPartial === void 0) {\n    allowPartial = false;\n  }\n  let {\n    routesMeta\n  } = branch;\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath({\n      path: meta.relativePath,\n      caseSensitive: meta.caseSensitive,\n      end\n    }, remainingPathname);\n    let route = meta.route;\n    if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {\n      match = matchPath({\n        path: meta.relativePath,\n        caseSensitive: meta.caseSensitive,\n        end: false\n      }, remainingPathname);\n    }\n    if (!match) {\n      return null;\n    }\n    Object.assign(matchedParams, match.params);\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),\n      route\n    });\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n  return matches;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/v6/utils/generate-path\n */\nfunction generatePath(originalPath, params) {\n  if (params === void 0) {\n    params = {};\n  }\n  let path = originalPath;\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n    warning(false, \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\n    path = path.replace(/\\*$/, \"/*\");\n  }\n  // ensure `/` is added at the beginning if the path is absolute\n  const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n  const stringify = p => p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n  const segments = path.split(/\\/+/).map((segment, index, array) => {\n    const isLastSegment = index === array.length - 1;\n    // only apply the splat if it's the last segment\n    if (isLastSegment && segment === \"*\") {\n      const star = \"*\";\n      // Apply the splat\n      return stringify(params[star]);\n    }\n    const keyMatch = segment.match(/^:([\\w-]+)(\\??)$/);\n    if (keyMatch) {\n      const [, key, optional] = keyMatch;\n      let param = params[key];\n      invariant(optional === \"?\" || param != null, \"Missing \\\":\" + key + \"\\\" param\");\n      return stringify(param);\n    }\n    // Remove any optional markers from optional static segments\n    return segment.replace(/\\?$/g, \"\");\n  })\n  // Remove empty segments\n  .filter(segment => !!segment);\n  return prefix + segments.join(\"/\");\n}\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/v6/utils/match-path\n */\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === \"string\") {\n    pattern = {\n      path: pattern,\n      caseSensitive: false,\n      end: true\n    };\n  }\n  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n  let match = pathname.match(matcher);\n  if (!match) return null;\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params = compiledParams.reduce((memo, _ref, index) => {\n    let {\n      paramName,\n      isOptional\n    } = _ref;\n    // We need to compute the pathnameBase here using the raw splat value\n    // instead of using params[\"*\"] later because it will be decoded then\n    if (paramName === \"*\") {\n      let splatValue = captureGroups[index] || \"\";\n      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n    }\n    const value = captureGroups[index];\n    if (isOptional && !value) {\n      memo[paramName] = undefined;\n    } else {\n      memo[paramName] = (value || \"\").replace(/%2F/g, \"/\");\n    }\n    return memo;\n  }, {});\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\nfunction compilePath(path, caseSensitive, end) {\n  if (caseSensitive === void 0) {\n    caseSensitive = false;\n  }\n  if (end === void 0) {\n    end = true;\n  }\n  warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\n  let params = [];\n  let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n  .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n  .replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n  .replace(/\\/:([\\w-]+)(\\?)?/g, (_, paramName, isOptional) => {\n    params.push({\n      paramName,\n      isOptional: isOptional != null\n    });\n    return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n  });\n  if (path.endsWith(\"*\")) {\n    params.push({\n      paramName: \"*\"\n    });\n    regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" // Already matched the initial /, just match the rest\n    : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else if (end) {\n    // When matching to the end, ignore trailing slashes\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    // If our path is non-empty and contains anything beyond an initial slash,\n    // then we have _some_ form of path in our regex, so we should expect to\n    // match only if we find the end of this path segment.  Look for an optional\n    // non-captured trailing slash (to match a portion of the URL) or the end\n    // of the path (if we've matched to the end).  We used to do this with a\n    // word boundary but that gives false positives on routes like\n    // /user-preferences since `-` counts as a word boundary.\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else ;\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n  return [matcher, params];\n}\nfunction decodePath(value) {\n  try {\n    return value.split(\"/\").map(v => decodeURIComponent(v).replace(/\\//g, \"%2F\")).join(\"/\");\n  } catch (error) {\n    warning(false, \"The URL path \\\"\" + value + \"\\\" could not be decoded because it is is a \" + \"malformed URL segment. This is probably due to a bad percent \" + (\"encoding (\" + error + \").\"));\n    return value;\n  }\n}\n/**\n * @private\n */\nfunction stripBasename(pathname, basename) {\n  if (basename === \"/\") return pathname;\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n  // We want to leave trailing slash behavior in the user's control, so if they\n  // specify a basename with a trailing slash, we should support it\n  let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n  return pathname.slice(startIndex) || \"/\";\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/v6/utils/resolve-path\n */\nfunction resolvePath(to, fromPathname) {\n  if (fromPathname === void 0) {\n    fromPathname = \"/\";\n  }\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\"\n  } = typeof to === \"string\" ? parsePath(to) : to;\n  let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n  relativeSegments.forEach(segment => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n  return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + \"a string in <Link to=\\\"...\\\"> and the router will parse it for you.\";\n}\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */\nfunction getPathContributingMatches(matches) {\n  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);\n}\n// Return the array of pathnames for the current route matches - used to\n// generate the routePathnames input for resolveTo()\nfunction getResolveToMatches(matches, v7_relativeSplatPath) {\n  let pathMatches = getPathContributingMatches(matches);\n  // When v7_relativeSplatPath is enabled, use the full pathname for the leaf\n  // match so we include splat values for \".\" links.  See:\n  // https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329\n  if (v7_relativeSplatPath) {\n    return pathMatches.map((match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase);\n  }\n  return pathMatches.map(match => match.pathnameBase);\n}\n/**\n * @private\n */\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n  if (isPathRelative === void 0) {\n    isPathRelative = false;\n  }\n  let to;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = _extends({}, toArg);\n    invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n    invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n    invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n  }\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n  let from;\n  // Routing is relative to the current pathname if explicitly requested.\n  //\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  if (toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n    // With relative=\"route\" (the default), each leading .. segment means\n    // \"go up one route\" instead of \"go up one URL segment\".  This is a key\n    // difference from how <a href> works and a major reason we call this a\n    // \"to\" value instead of a \"href\".\n    if (!isPathRelative && toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n      to.pathname = toSegments.join(\"/\");\n    }\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n  let path = resolvePath(to, from);\n  // Ensure the pathname has a trailing slash if the original \"to\" had one\n  let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  // Or if this was a link to the current path which has a trailing slash\n  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n    path.pathname += \"/\";\n  }\n  return path;\n}\n/**\n * @private\n */\nfunction getToPathname(to) {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? parsePath(to).pathname : to.pathname;\n}\n/**\n * @private\n */\nconst joinPaths = paths => paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n/**\n * @private\n */\nconst normalizePathname = pathname => pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n/**\n * @private\n */\nconst normalizeSearch = search => !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\n/**\n * @private\n */\nconst normalizeHash = hash => !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n *\n * @deprecated The `json` method is deprecated in favor of returning raw objects.\n * This method will be removed in v7.\n */\nconst json = function json(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === \"number\" ? {\n    status: init\n  } : init;\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n  }\n  return new Response(JSON.stringify(data), _extends({}, responseInit, {\n    headers\n  }));\n};\nclass DataWithResponseInit {\n  constructor(data, init) {\n    this.type = \"DataWithResponseInit\";\n    this.data = data;\n    this.init = init || null;\n  }\n}\n/**\n * Create \"responses\" that contain `status`/`headers` without forcing\n * serialization into an actual `Response` - used by Remix single fetch\n */\nfunction data(data, init) {\n  return new DataWithResponseInit(data, typeof init === \"number\" ? {\n    status: init\n  } : init);\n}\nclass AbortedDeferredError extends Error {}\nclass DeferredData {\n  constructor(data, responseInit) {\n    this.pendingKeysSet = new Set();\n    this.subscribers = new Set();\n    this.deferredKeys = [];\n    invariant(data && typeof data === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\");\n    // Set up an AbortController + Promise we can race against to exit early\n    // cancellation\n    let reject;\n    this.abortPromise = new Promise((_, r) => reject = r);\n    this.controller = new AbortController();\n    let onAbort = () => reject(new AbortedDeferredError(\"Deferred data aborted\"));\n    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener(\"abort\", onAbort);\n    this.controller.signal.addEventListener(\"abort\", onAbort);\n    this.data = Object.entries(data).reduce((acc, _ref2) => {\n      let [key, value] = _ref2;\n      return Object.assign(acc, {\n        [key]: this.trackPromise(key, value)\n      });\n    }, {});\n    if (this.done) {\n      // All incoming values were resolved\n      this.unlistenAbortSignal();\n    }\n    this.init = responseInit;\n  }\n  trackPromise(key, value) {\n    if (!(value instanceof Promise)) {\n      return value;\n    }\n    this.deferredKeys.push(key);\n    this.pendingKeysSet.add(key);\n    // We store a little wrapper promise that will be extended with\n    // _data/_error props upon resolve/reject\n    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, undefined, data), error => this.onSettle(promise, key, error));\n    // Register rejection listeners to avoid uncaught promise rejections on\n    // errors or aborted deferred values\n    promise.catch(() => {});\n    Object.defineProperty(promise, \"_tracked\", {\n      get: () => true\n    });\n    return promise;\n  }\n  onSettle(promise, key, error, data) {\n    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\n      this.unlistenAbortSignal();\n      Object.defineProperty(promise, \"_error\", {\n        get: () => error\n      });\n      return Promise.reject(error);\n    }\n    this.pendingKeysSet.delete(key);\n    if (this.done) {\n      // Nothing left to abort!\n      this.unlistenAbortSignal();\n    }\n    // If the promise was resolved/rejected with undefined, we'll throw an error as you\n    // should always resolve with a value or null\n    if (error === undefined && data === undefined) {\n      let undefinedError = new Error(\"Deferred data for key \\\"\" + key + \"\\\" resolved/rejected with `undefined`, \" + \"you must resolve/reject with a value or `null`.\");\n      Object.defineProperty(promise, \"_error\", {\n        get: () => undefinedError\n      });\n      this.emit(false, key);\n      return Promise.reject(undefinedError);\n    }\n    if (data === undefined) {\n      Object.defineProperty(promise, \"_error\", {\n        get: () => error\n      });\n      this.emit(false, key);\n      return Promise.reject(error);\n    }\n    Object.defineProperty(promise, \"_data\", {\n      get: () => data\n    });\n    this.emit(false, key);\n    return data;\n  }\n  emit(aborted, settledKey) {\n    this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));\n  }\n  subscribe(fn) {\n    this.subscribers.add(fn);\n    return () => this.subscribers.delete(fn);\n  }\n  cancel() {\n    this.controller.abort();\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\n    this.emit(true);\n  }\n  async resolveData(signal) {\n    let aborted = false;\n    if (!this.done) {\n      let onAbort = () => this.cancel();\n      signal.addEventListener(\"abort\", onAbort);\n      aborted = await new Promise(resolve => {\n        this.subscribe(aborted => {\n          signal.removeEventListener(\"abort\", onAbort);\n          if (aborted || this.done) {\n            resolve(aborted);\n          }\n        });\n      });\n    }\n    return aborted;\n  }\n  get done() {\n    return this.pendingKeysSet.size === 0;\n  }\n  get unwrappedData() {\n    invariant(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\n    return Object.entries(this.data).reduce((acc, _ref3) => {\n      let [key, value] = _ref3;\n      return Object.assign(acc, {\n        [key]: unwrapTrackedPromise(value)\n      });\n    }, {});\n  }\n  get pendingKeys() {\n    return Array.from(this.pendingKeysSet);\n  }\n}\nfunction isTrackedPromise(value) {\n  return value instanceof Promise && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\n/**\n * @deprecated The `defer` method is deprecated in favor of returning raw\n * objects. This method will be removed in v7.\n */\nconst defer = function defer(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === \"number\" ? {\n    status: init\n  } : init;\n  return new DeferredData(data, responseInit);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nconst redirect = function redirect(url, init) {\n  if (init === void 0) {\n    init = 302;\n  }\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = {\n      status: responseInit\n    };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n  return new Response(null, _extends({}, responseInit, {\n    headers\n  }));\n};\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nconst redirectDocument = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n  return response;\n};\n/**\n * A redirect response that will perform a `history.replaceState` instead of a\n * `history.pushState` for client-side navigation redirects.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nconst replace = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Replace\", \"true\");\n  return response;\n};\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n *\n * We don't export the class for public use since it's an implementation\n * detail, but we export the interface above so folks can build their own\n * abstractions around instances via isRouteErrorResponse()\n */\nclass ErrorResponseImpl {\n  constructor(status, statusText, data, internal) {\n    if (internal === void 0) {\n      internal = false;\n    }\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.internal = internal;\n    if (data instanceof Error) {\n      this.data = data.toString();\n      this.error = data;\n    } else {\n      this.data = data;\n    }\n  }\n}\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */\nfunction isRouteErrorResponse(error) {\n  return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\n\nconst validMutationMethodsArr = [\"post\", \"put\", \"patch\", \"delete\"];\nconst validMutationMethods = new Set(validMutationMethodsArr);\nconst validRequestMethodsArr = [\"get\", ...validMutationMethodsArr];\nconst validRequestMethods = new Set(validRequestMethodsArr);\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst redirectPreserveMethodStatusCodes = new Set([307, 308]);\nconst IDLE_NAVIGATION = {\n  state: \"idle\",\n  location: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined\n};\nconst IDLE_FETCHER = {\n  state: \"idle\",\n  data: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined\n};\nconst IDLE_BLOCKER = {\n  state: \"unblocked\",\n  proceed: undefined,\n  reset: undefined,\n  location: undefined\n};\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nconst defaultMapRouteProperties = route => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary)\n});\nconst TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a router and listen to history POP navigations\n */\nfunction createRouter(init) {\n  const routerWindow = init.window ? init.window : typeof window !== \"undefined\" ? window : undefined;\n  const isBrowser = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n  const isServer = !isBrowser;\n  invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n  let mapRouteProperties;\n  if (init.mapRouteProperties) {\n    mapRouteProperties = init.mapRouteProperties;\n  } else if (init.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = init.detectErrorBoundary;\n    mapRouteProperties = route => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  // Routes keyed by ID\n  let manifest = {};\n  // Routes in tree format for matching\n  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);\n  let inFlightDataRoutes;\n  let basename = init.basename || \"/\";\n  let dataStrategyImpl = init.dataStrategy || defaultDataStrategy;\n  let patchRoutesOnNavigationImpl = init.patchRoutesOnNavigation;\n  // Config driven behavior flags\n  let future = _extends({\n    v7_fetcherPersist: false,\n    v7_normalizeFormMethod: false,\n    v7_partialHydration: false,\n    v7_prependBasename: false,\n    v7_relativeSplatPath: false,\n    v7_skipActionErrorRevalidation: false\n  }, init.future);\n  // Cleanup function for history\n  let unlistenHistory = null;\n  // Externally-provided functions to call on all state changes\n  let subscribers = new Set();\n  // Externally-provided object to hold scroll restoration locations during routing\n  let savedScrollPositions = null;\n  // Externally-provided function to get scroll restoration keys\n  let getScrollRestorationKey = null;\n  // Externally-provided function to get current scroll position\n  let getScrollPosition = null;\n  // One-time flag to control the initial hydration scroll restoration.  Because\n  // we don't get the saved positions from <ScrollRestoration /> until _after_\n  // the initial render, we need to manually trigger a separate updateState to\n  // send along the restoreScrollPosition\n  // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n  // SSR did the initial scroll restoration.\n  let initialScrollRestored = init.hydrationData != null;\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialMatchesIsFOW = false;\n  let initialErrors = null;\n  if (initialMatches == null && !patchRoutesOnNavigationImpl) {\n    // If we do not match a user-provided-route, fall back to the root\n    // to allow the error boundary to take over\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname\n    });\n    let {\n      matches,\n      route\n    } = getShortCircuitMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = {\n      [route.id]: error\n    };\n  }\n  // In SPA apps, if the user provided a patchRoutesOnNavigation implementation and\n  // our initial match is a splat route, clear them out so we run through lazy\n  // discovery on hydration in case there's a more accurate lazy route match.\n  // In SSR apps (with `hydrationData`), we expect that the server will send\n  // up the proper matched routes so we don't want to run lazy discovery on\n  // initial hydration and want to hydrate into the splat route.\n  if (initialMatches && !init.hydrationData) {\n    let fogOfWar = checkFogOfWar(initialMatches, dataRoutes, init.history.location.pathname);\n    if (fogOfWar.active) {\n      initialMatches = null;\n    }\n  }\n  let initialized;\n  if (!initialMatches) {\n    initialized = false;\n    initialMatches = [];\n    // If partial hydration and fog of war is enabled, we will be running\n    // `patchRoutesOnNavigation` during hydration so include any partial matches as\n    // the initial matches so we can properly render `HydrateFallback`'s\n    if (future.v7_partialHydration) {\n      let fogOfWar = checkFogOfWar(null, dataRoutes, init.history.location.pathname);\n      if (fogOfWar.active && fogOfWar.matches) {\n        initialMatchesIsFOW = true;\n        initialMatches = fogOfWar.matches;\n      }\n    }\n  } else if (initialMatches.some(m => m.route.lazy)) {\n    // All initialMatches need to be loaded before we're ready.  If we have lazy\n    // functions around still then we'll need to run them in initialize()\n    initialized = false;\n  } else if (!initialMatches.some(m => m.route.loader)) {\n    // If we've got no loaders to run, then we're good to go\n    initialized = true;\n  } else if (future.v7_partialHydration) {\n    // If partial hydration is enabled, we're initialized so long as we were\n    // provided with hydrationData for every route with a loader, and no loaders\n    // were marked for explicit hydration\n    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\n    let errors = init.hydrationData ? init.hydrationData.errors : null;\n    // If errors exist, don't consider routes below the boundary\n    if (errors) {\n      let idx = initialMatches.findIndex(m => errors[m.route.id] !== undefined);\n      initialized = initialMatches.slice(0, idx + 1).every(m => !shouldLoadRouteOnHydration(m.route, loaderData, errors));\n    } else {\n      initialized = initialMatches.every(m => !shouldLoadRouteOnHydration(m.route, loaderData, errors));\n    }\n  } else {\n    // Without partial hydration - we're initialized if we were provided any\n    // hydrationData - which is expected to be complete\n    initialized = init.hydrationData != null;\n  }\n  let router;\n  let state = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don't restore on initial updateState() if we were SSR'd\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n    actionData: init.hydrationData && init.hydrationData.actionData || null,\n    errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n    fetchers: new Map(),\n    blockers: new Map()\n  };\n  // -- Stateful internal variables to manage navigations --\n  // Current navigation in progress (to be committed in completeNavigation)\n  let pendingAction = Action.Pop;\n  // Should the current navigation prevent the scroll reset if scroll cannot\n  // be restored?\n  let pendingPreventScrollReset = false;\n  // AbortController for the active navigation\n  let pendingNavigationController;\n  // Should the current navigation enable document.startViewTransition?\n  let pendingViewTransitionEnabled = false;\n  // Store applied view transitions so we can apply them on POP\n  let appliedViewTransitions = new Map();\n  // Cleanup function for persisting applied transitions to sessionStorage\n  let removePageHideEventListener = null;\n  // We use this to avoid touching history in completeNavigation if a\n  // revalidation is entirely uninterrupted\n  let isUninterruptedRevalidation = false;\n  // Use this internal flag to force revalidation of all loaders:\n  //  - submissions (completed or interrupted)\n  //  - useRevalidator()\n  //  - X-Remix-Revalidate (from redirect)\n  let isRevalidationRequired = false;\n  // Use this internal array to capture routes that require revalidation due\n  // to a cancelled deferred on action submission\n  let cancelledDeferredRoutes = [];\n  // Use this internal array to capture fetcher loads that were cancelled by an\n  // action navigation and require revalidation\n  let cancelledFetcherLoads = new Set();\n  // AbortControllers for any in-flight fetchers\n  let fetchControllers = new Map();\n  // Track loads based on the order in which they started\n  let incrementingLoadId = 0;\n  // Track the outstanding pending navigation data load to be compared against\n  // the globally incrementing load when a fetcher load lands after a completed\n  // navigation\n  let pendingNavigationLoadId = -1;\n  // Fetchers that triggered data reloads as a result of their actions\n  let fetchReloadIds = new Map();\n  // Fetchers that triggered redirect navigations\n  let fetchRedirectIds = new Set();\n  // Most recent href/match for fetcher.load calls for fetchers\n  let fetchLoadMatches = new Map();\n  // Ref-count mounted fetchers so we know when it's ok to clean them up\n  let activeFetchers = new Map();\n  // Fetchers that have requested a delete when using v7_fetcherPersist,\n  // they'll be officially removed after they return to idle\n  let deletedFetchers = new Set();\n  // Store DeferredData instances for active route matches.  When a\n  // route loader returns defer() we stick one in here.  Then, when a nested\n  // promise resolves we update loaderData.  If a new navigation starts we\n  // cancel active deferreds for eliminated routes.\n  let activeDeferreds = new Map();\n  // Store blocker functions in a separate Map outside of router state since\n  // we don't need to update UI state if they change\n  let blockerFunctions = new Map();\n  // Flag to ignore the next history update, so we can revert the URL change on\n  // a POP navigation that was blocked by the user without touching router state\n  let unblockBlockerHistoryUpdate = undefined;\n  // Initialize the router, all side effects should be kicked off from here.\n  // Implemented as a Fluent API for ease of:\n  //   let router = createRouter(init).initialize();\n  function initialize() {\n    // If history informs us of a POP navigation, start the navigation but do not update\n    // state.  We'll update our own state once the navigation completes\n    unlistenHistory = init.history.listen(_ref => {\n      let {\n        action: historyAction,\n        location,\n        delta\n      } = _ref;\n      // Ignore this event if it was just us resetting the URL from a\n      // blocked POP navigation\n      if (unblockBlockerHistoryUpdate) {\n        unblockBlockerHistoryUpdate();\n        unblockBlockerHistoryUpdate = undefined;\n        return;\n      }\n      warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location \" + \"that was not created by @remix-run/router. This will fail silently in \" + \"production. This can happen if you are navigating outside the router \" + \"via `window.history.pushState`/`window.location.hash` instead of using \" + \"router navigation APIs.  This can also happen if you are using \" + \"createHashRouter and the user manually changes the URL.\");\n      let blockerKey = shouldBlockNavigation({\n        currentLocation: state.location,\n        nextLocation: location,\n        historyAction\n      });\n      if (blockerKey && delta != null) {\n        // Restore the URL to match the current UI, but don't update router state\n        let nextHistoryUpdatePromise = new Promise(resolve => {\n          unblockBlockerHistoryUpdate = resolve;\n        });\n        init.history.go(delta * -1);\n        // Put the blocker into a blocked state\n        updateBlocker(blockerKey, {\n          state: \"blocked\",\n          location,\n          proceed() {\n            updateBlocker(blockerKey, {\n              state: \"proceeding\",\n              proceed: undefined,\n              reset: undefined,\n              location\n            });\n            // Re-do the same POP navigation we just blocked, after the url\n            // restoration is also complete.  See:\n            // https://github.com/remix-run/react-router/issues/11613\n            nextHistoryUpdatePromise.then(() => init.history.go(delta));\n          },\n          reset() {\n            let blockers = new Map(state.blockers);\n            blockers.set(blockerKey, IDLE_BLOCKER);\n            updateState({\n              blockers\n            });\n          }\n        });\n        return;\n      }\n      return startNavigation(historyAction, location);\n    });\n    if (isBrowser) {\n      // FIXME: This feels gross.  How can we cleanup the lines between\n      // scrollRestoration/appliedTransitions persistance?\n      restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);\n      routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n      removePageHideEventListener = () => routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n    }\n    // Kick off initial data load if needed.  Use Pop to avoid modifying history\n    // Note we don't do any handling of lazy here.  For SPA's it'll get handled\n    // in the normal navigation flow.  For SSR it's expected that lazy modules are\n    // resolved prior to router creation since we can't go into a fallbackElement\n    // UI for SSR'd apps\n    if (!state.initialized) {\n      startNavigation(Action.Pop, state.location, {\n        initialHydration: true\n      });\n    }\n    return router;\n  }\n  // Clean up a router and it's side effects\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    if (removePageHideEventListener) {\n      removePageHideEventListener();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n  // Subscribe to state updates for the router\n  function subscribe(fn) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n  // Update our state and notify the calling context of the change\n  function updateState(newState, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    state = _extends({}, state, newState);\n    // Prep fetcher cleanup so we can tell the UI which fetcher data entries\n    // can be removed\n    let completedFetchers = [];\n    let deletedFetchersKeys = [];\n    if (future.v7_fetcherPersist) {\n      state.fetchers.forEach((fetcher, key) => {\n        if (fetcher.state === \"idle\") {\n          if (deletedFetchers.has(key)) {\n            // Unmounted from the UI and can be totally removed\n            deletedFetchersKeys.push(key);\n          } else {\n            // Returned to idle but still mounted in the UI, so semi-remains for\n            // revalidations and such\n            completedFetchers.push(key);\n          }\n        }\n      });\n    }\n    // Remove any lingering deleted fetchers that have already been removed\n    // from state.fetchers\n    deletedFetchers.forEach(key => {\n      if (!state.fetchers.has(key) && !fetchControllers.has(key)) {\n        deletedFetchersKeys.push(key);\n      }\n    });\n    // Iterate over a local copy so that if flushSync is used and we end up\n    // removing and adding a new subscriber due to the useCallback dependencies,\n    // we don't get ourselves into a loop calling the new subscriber immediately\n    [...subscribers].forEach(subscriber => subscriber(state, {\n      deletedFetchers: deletedFetchersKeys,\n      viewTransitionOpts: opts.viewTransitionOpts,\n      flushSync: opts.flushSync === true\n    }));\n    // Remove idle fetchers from state since we only care about in-flight fetchers.\n    if (future.v7_fetcherPersist) {\n      completedFetchers.forEach(key => state.fetchers.delete(key));\n      deletedFetchersKeys.forEach(key => deleteFetcher(key));\n    } else {\n      // We already called deleteFetcher() on these, can remove them from this\n      // Set now that we've handed the keys off to the data layer\n      deletedFetchersKeys.forEach(key => deletedFetchers.delete(key));\n    }\n  }\n  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n  // and setting state.[historyAction/location/matches] to the new route.\n  // - Location is a required param\n  // - Navigation will always be set to IDLE_NAVIGATION\n  // - Can pass any other state in newState\n  function completeNavigation(location, newState, _temp) {\n    var _location$state, _location$state2;\n    let {\n      flushSync\n    } = _temp === void 0 ? {} : _temp;\n    // Deduce if we're in a loading/actionReload state:\n    // - We have committed actionData in the store\n    // - The current navigation was a mutation submission\n    // - We're past the submitting state and into the loading state\n    // - The location being loaded is not the result of a redirect\n    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n    let actionData;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        // Empty actionData -> clear prior actionData due to an action error\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      // Keep the current data if we're wrapping up the action reload\n      actionData = state.actionData;\n    } else {\n      // Clear actionData on any other completed navigations\n      actionData = null;\n    }\n    // Always preserve any existing loaderData from re-used routes\n    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n    // On a successful navigation we can assume we got through all blockers\n    // so we can start fresh\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n    // Always respect the user flag.  Otherwise don't reset on mutation\n    // submission navigations unless they redirect\n    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n    // Commit any in-flight routes at the end of the HMR revalidation \"navigation\"\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = undefined;\n    }\n    if (isUninterruptedRevalidation) ; else if (pendingAction === Action.Pop) ; else if (pendingAction === Action.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === Action.Replace) {\n      init.history.replace(location, location.state);\n    }\n    let viewTransitionOpts;\n    // On POP, enable transitions if they were enabled on the original navigation\n    if (pendingAction === Action.Pop) {\n      // Forward takes precedence so they behave like the original navigation\n      let priorPaths = appliedViewTransitions.get(state.location.pathname);\n      if (priorPaths && priorPaths.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: state.location,\n          nextLocation: location\n        };\n      } else if (appliedViewTransitions.has(location.pathname)) {\n        // If we don't have a previous forward nav, assume we're popping back to\n        // the new location and enable if that location previously enabled\n        viewTransitionOpts = {\n          currentLocation: location,\n          nextLocation: state.location\n        };\n      }\n    } else if (pendingViewTransitionEnabled) {\n      // Store the applied transition on PUSH/REPLACE\n      let toPaths = appliedViewTransitions.get(state.location.pathname);\n      if (toPaths) {\n        toPaths.add(location.pathname);\n      } else {\n        toPaths = new Set([location.pathname]);\n        appliedViewTransitions.set(state.location.pathname, toPaths);\n      }\n      viewTransitionOpts = {\n        currentLocation: state.location,\n        nextLocation: location\n      };\n    }\n    updateState(_extends({}, newState, {\n      actionData,\n      loaderData,\n      historyAction: pendingAction,\n      location,\n      initialized: true,\n      navigation: IDLE_NAVIGATION,\n      revalidation: \"idle\",\n      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n      preventScrollReset,\n      blockers\n    }), {\n      viewTransitionOpts,\n      flushSync: flushSync === true\n    });\n    // Reset stateful navigation vars\n    pendingAction = Action.Pop;\n    pendingPreventScrollReset = false;\n    pendingViewTransitionEnabled = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n  }\n  // Trigger a navigation event, which can either be a numerical POP or a PUSH\n  // replace with an optional submission\n  async function navigate(to, opts) {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n    // URL from window.location, so we need to encode it here so the behavior\n    // remains the same as POP and non-data-router usages.  new URL() does all\n    // the same encoding we'd get from a history.pushState/window.location read\n    // without having to touch history\n    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n    let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n    let historyAction = Action.Push;\n    if (userReplace === true) {\n      historyAction = Action.Replace;\n    } else if (userReplace === false) ; else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n      // By default on submissions to the current location we REPLACE so that\n      // users don't have to double-click the back button to get to the prior\n      // location.  If the user redirects to a different location from the\n      // action/loader this will be ignored and the redirect will be a PUSH\n      historyAction = Action.Replace;\n    }\n    let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : undefined;\n    let flushSync = (opts && opts.flushSync) === true;\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction\n    });\n    if (blockerKey) {\n      // Put the blocker into a blocked state\n      updateBlocker(blockerKey, {\n        state: \"blocked\",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey, {\n            state: \"proceeding\",\n            proceed: undefined,\n            reset: undefined,\n            location: nextLocation\n          });\n          // Send the same navigation through\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey, IDLE_BLOCKER);\n          updateState({\n            blockers\n          });\n        }\n      });\n      return;\n    }\n    return await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace,\n      enableViewTransition: opts && opts.viewTransition,\n      flushSync\n    });\n  }\n  // Revalidate all current loaders.  If a navigation is in progress or if this\n  // is interrupted by a navigation, allow this to \"succeed\" by calling all\n  // loaders during the next loader round\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({\n      revalidation: \"loading\"\n    });\n    // If we're currently submitting an action, we don't need to start a new\n    // navigation, we'll just let the follow up loader execution call all loaders\n    if (state.navigation.state === \"submitting\") {\n      return;\n    }\n    // If we're currently in an idle state, start a new navigation for the current\n    // action/location and mark it as uninterrupted, which will skip the history\n    // update in completeNavigation\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true\n      });\n      return;\n    }\n    // Otherwise, if we're currently in a loading state, just start a new\n    // navigation to the navigation.location but do not trigger an uninterrupted\n    // revalidation so that history correctly updates once the navigation completes\n    startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n      overrideNavigation: state.navigation,\n      // Proxy through any rending view transition\n      enableViewTransition: pendingViewTransitionEnabled === true\n    });\n  }\n  // Start a navigation to the given action/location.  Can optionally provide a\n  // overrideNavigation which will override the normalLoad in the case of a redirect\n  // navigation\n  async function startNavigation(historyAction, location, opts) {\n    // Abort any in-progress navigations and start a new one. Unset any ongoing\n    // uninterrupted revalidations unless told otherwise, since we want this\n    // new navigation to update history normally\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n    // Save the current scroll position every time we start a new navigation,\n    // and track whether we should reset scroll on completion\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = opts != null && opts.initialHydration && state.matches && state.matches.length > 0 && !initialMatchesIsFOW ?\n    // `matchRoutes()` has already been called if we're in here via `router.initialize()`\n    state.matches : matchRoutes(routesToUse, location, basename);\n    let flushSync = (opts && opts.flushSync) === true;\n    // Short circuit if it's only a hash change and not a revalidation or\n    // mutation submission.\n    //\n    // Ignore on initial page loads because since the initial hydration will always\n    // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n    // which will default to a navigation to /page\n    if (matches && state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n      completeNavigation(location, {\n        matches\n      }, {\n        flushSync\n      });\n      return;\n    }\n    let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname);\n    if (fogOfWar.active && fogOfWar.matches) {\n      matches = fogOfWar.matches;\n    }\n    // Short circuit with a 404 on the root error boundary if we match nothing\n    if (!matches) {\n      let {\n        error,\n        notFoundMatches,\n        route\n      } = handleNavigational404(location.pathname);\n      completeNavigation(location, {\n        matches: notFoundMatches,\n        loaderData: {},\n        errors: {\n          [route.id]: error\n        }\n      }, {\n        flushSync\n      });\n      return;\n    }\n    // Create a controller/Request for this navigation\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n    let pendingActionResult;\n    if (opts && opts.pendingError) {\n      // If we have a pendingError, it means the user attempted a GET submission\n      // with binary FormData so assign here and skip to handleLoaders.  That\n      // way we handle calling loaders above the boundary etc.  It's not really\n      // different from an actionError in that sense.\n      pendingActionResult = [findNearestBoundary(matches).route.id, {\n        type: ResultType.error,\n        error: opts.pendingError\n      }];\n    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n      // Call action if we received an action submission\n      let actionResult = await handleAction(request, location, opts.submission, matches, fogOfWar.active, {\n        replace: opts.replace,\n        flushSync\n      });\n      if (actionResult.shortCircuited) {\n        return;\n      }\n      // If we received a 404 from handleAction, it's because we couldn't lazily\n      // discover the destination route so we don't want to call loaders\n      if (actionResult.pendingActionResult) {\n        let [routeId, result] = actionResult.pendingActionResult;\n        if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {\n          pendingNavigationController = null;\n          completeNavigation(location, {\n            matches: actionResult.matches,\n            loaderData: {},\n            errors: {\n              [routeId]: result.error\n            }\n          });\n          return;\n        }\n      }\n      matches = actionResult.matches || matches;\n      pendingActionResult = actionResult.pendingActionResult;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n      flushSync = false;\n      // No need to do fog of war matching again on loader execution\n      fogOfWar.active = false;\n      // Create a GET request for the loaders\n      request = createClientSideRequest(init.history, request.url, request.signal);\n    }\n    // Call loaders\n    let {\n      shortCircuited,\n      matches: updatedMatches,\n      loaderData,\n      errors\n    } = await handleLoaders(request, location, matches, fogOfWar.active, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionResult);\n    if (shortCircuited) {\n      return;\n    }\n    // Clean up now that the action/loaders have completed.  Don't clean up if\n    // we short circuited because pendingNavigationController will have already\n    // been assigned to a new controller for the next navigation\n    pendingNavigationController = null;\n    completeNavigation(location, _extends({\n      matches: updatedMatches || matches\n    }, getActionDataForCommit(pendingActionResult), {\n      loaderData,\n      errors\n    }));\n  }\n  // Call the action matched by the leaf route for this navigation and handle\n  // redirects/errors\n  async function handleAction(request, location, submission, matches, isFogOfWar, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    interruptActiveLoads();\n    // Put us in a submitting state\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({\n      navigation\n    }, {\n      flushSync: opts.flushSync === true\n    });\n    if (isFogOfWar) {\n      let discoverResult = await discoverRoutes(matches, location.pathname, request.signal);\n      if (discoverResult.type === \"aborted\") {\n        return {\n          shortCircuited: true\n        };\n      } else if (discoverResult.type === \"error\") {\n        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;\n        return {\n          matches: discoverResult.partialMatches,\n          pendingActionResult: [boundaryId, {\n            type: ResultType.error,\n            error: discoverResult.error\n          }]\n        };\n      } else if (!discoverResult.matches) {\n        let {\n          notFoundMatches,\n          error,\n          route\n        } = handleNavigational404(location.pathname);\n        return {\n          matches: notFoundMatches,\n          pendingActionResult: [route.id, {\n            type: ResultType.error,\n            error\n          }]\n        };\n      } else {\n        matches = discoverResult.matches;\n      }\n    }\n    // Call our action and get the result\n    let result;\n    let actionMatch = getTargetMatch(matches, location);\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: ResultType.error,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id\n        })\n      };\n    } else {\n      let results = await callDataStrategy(\"action\", state, request, [actionMatch], matches, null);\n      result = results[actionMatch.route.id];\n      if (request.signal.aborted) {\n        return {\n          shortCircuited: true\n        };\n      }\n    }\n    if (isRedirectResult(result)) {\n      let replace;\n      if (opts && opts.replace != null) {\n        replace = opts.replace;\n      } else {\n        // If the user didn't explicity indicate replace behavior, replace if\n        // we redirected to the exact same location we're currently at to avoid\n        // double back-buttons\n        let location = normalizeRedirectLocation(result.response.headers.get(\"Location\"), new URL(request.url), basename);\n        replace = location === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(request, result, true, {\n        submission,\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    if (isDeferredResult(result)) {\n      throw getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n    }\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      // By default, all submissions to the current location are REPLACE\n      // navigations, but if the action threw an error that'll be rendered in\n      // an errorElement, we fall back to PUSH so that the user can use the\n      // back button to get back to the pre-submission form location to try\n      // again\n      if ((opts && opts.replace) !== true) {\n        pendingAction = Action.Push;\n      }\n      return {\n        matches,\n        pendingActionResult: [boundaryMatch.route.id, result]\n      };\n    }\n    return {\n      matches,\n      pendingActionResult: [actionMatch.route.id, result]\n    };\n  }\n  // Call all applicable loaders for the given matches, handling redirects,\n  // errors, etc.\n  async function handleLoaders(request, location, matches, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace, initialHydration, flushSync, pendingActionResult) {\n    // Figure out the right navigation we want to use for data loading\n    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n    // If this was a redirect from an action we don't have a \"submission\" but\n    // we have it on the loading navigation so use that if available\n    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n    // If this is an uninterrupted revalidation, we remain in our current idle\n    // state.  If not, we need to switch to our loading state and load data,\n    // preserving any new action data or existing action data (in the case of\n    // a revalidation interrupting an actionReload)\n    // If we have partialHydration enabled, then don't update the state for the\n    // initial data load since it's not a \"navigation\"\n    let shouldUpdateNavigationState = !isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration);\n    // When fog of war is enabled, we enter our `loading` state earlier so we\n    // can discover new routes during the `loading` state.  We skip this if\n    // we've already run actions since we would have done our matching already.\n    // If the children() function threw then, we want to proceed with the\n    // partial matches it discovered.\n    if (isFogOfWar) {\n      if (shouldUpdateNavigationState) {\n        let actionData = getUpdatedActionData(pendingActionResult);\n        updateState(_extends({\n          navigation: loadingNavigation\n        }, actionData !== undefined ? {\n          actionData\n        } : {}), {\n          flushSync\n        });\n      }\n      let discoverResult = await discoverRoutes(matches, location.pathname, request.signal);\n      if (discoverResult.type === \"aborted\") {\n        return {\n          shortCircuited: true\n        };\n      } else if (discoverResult.type === \"error\") {\n        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;\n        return {\n          matches: discoverResult.partialMatches,\n          loaderData: {},\n          errors: {\n            [boundaryId]: discoverResult.error\n          }\n        };\n      } else if (!discoverResult.matches) {\n        let {\n          error,\n          notFoundMatches,\n          route\n        } = handleNavigational404(location.pathname);\n        return {\n          matches: notFoundMatches,\n          loaderData: {},\n          errors: {\n            [route.id]: error\n          }\n        };\n      } else {\n        matches = discoverResult.matches;\n      }\n    }\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, future.v7_partialHydration && initialHydration === true, future.v7_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult);\n    // Cancel pending deferreds for no-longer-matched routes or routes we're\n    // about to reload.  Note that if this is an action reload we would have\n    // already cancelled all pending deferreds so this would be a no-op\n    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId));\n    pendingNavigationLoadId = ++incrementingLoadId;\n    // Short circuit if we have no loaders to run\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      let updatedFetchers = markFetchRedirectsDone();\n      completeNavigation(location, _extends({\n        matches,\n        loaderData: {},\n        // Commit pending error if we're short circuiting\n        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {\n          [pendingActionResult[0]]: pendingActionResult[1].error\n        } : null\n      }, getActionDataForCommit(pendingActionResult), updatedFetchers ? {\n        fetchers: new Map(state.fetchers)\n      } : {}), {\n        flushSync\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    if (shouldUpdateNavigationState) {\n      let updates = {};\n      if (!isFogOfWar) {\n        // Only update navigation/actionNData if we didn't already do it above\n        updates.navigation = loadingNavigation;\n        let actionData = getUpdatedActionData(pendingActionResult);\n        if (actionData !== undefined) {\n          updates.actionData = actionData;\n        }\n      }\n      if (revalidatingFetchers.length > 0) {\n        updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);\n      }\n      updateState(updates, {\n        flushSync\n      });\n    }\n    revalidatingFetchers.forEach(rf => {\n      abortFetcher(rf.key);\n      if (rf.controller) {\n        // Fetchers use an independent AbortController so that aborting a fetcher\n        // (via deleteFetcher) does not abort the triggering navigation that\n        // triggered the revalidation\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n    // Proxy navigation abort through to revalidation fetchers\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(f => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n    }\n    let {\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state, matches, matchesToLoad, revalidatingFetchers, request);\n    if (request.signal.aborted) {\n      return {\n        shortCircuited: true\n      };\n    }\n    // Clean up _after_ loaders have completed.  Don't clean up if we short\n    // circuited because fetchControllers would have been aborted and\n    // reassigned to new controllers for the next navigation\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n    }\n    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key));\n    // If any loaders returned a redirect Response, start a new REPLACE navigation\n    let redirect = findRedirect(loaderResults);\n    if (redirect) {\n      await startRedirectNavigation(request, redirect.result, true, {\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    redirect = findRedirect(fetcherResults);\n    if (redirect) {\n      // If this redirect came from a fetcher make sure we mark it in\n      // fetchRedirectIds so it doesn't get revalidated on the next set of\n      // loader executions\n      fetchRedirectIds.add(redirect.key);\n      await startRedirectNavigation(request, redirect.result, true, {\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    // Process and commit output from loaders\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, matches, loaderResults, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds);\n    // Wire up subscribers to update loaderData as promises settle\n    activeDeferreds.forEach((deferredData, routeId) => {\n      deferredData.subscribe(aborted => {\n        // Note: No need to updateState here since the TrackedPromise on\n        // loaderData is stable across resolve/reject\n        // Remove this instance if we were aborted or if promises have settled\n        if (aborted || deferredData.done) {\n          activeDeferreds.delete(routeId);\n        }\n      });\n    });\n    // Preserve SSR errors during partial hydration\n    if (future.v7_partialHydration && initialHydration && state.errors) {\n      errors = _extends({}, state.errors, errors);\n    }\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n    return _extends({\n      matches,\n      loaderData,\n      errors\n    }, shouldUpdateFetchers ? {\n      fetchers: new Map(state.fetchers)\n    } : {});\n  }\n  function getUpdatedActionData(pendingActionResult) {\n    if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {\n      // This is cast to `any` currently because `RouteData`uses any and it\n      // would be a breaking change to use any.\n      // TODO: v7 - change `RouteData` to use `unknown` instead of `any`\n      return {\n        [pendingActionResult[0]]: pendingActionResult[1].data\n      };\n    } else if (state.actionData) {\n      if (Object.keys(state.actionData).length === 0) {\n        return null;\n      } else {\n        return state.actionData;\n      }\n    }\n  }\n  function getUpdatedRevalidatingFetchers(revalidatingFetchers) {\n    revalidatingFetchers.forEach(rf => {\n      let fetcher = state.fetchers.get(rf.key);\n      let revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);\n      state.fetchers.set(rf.key, revalidatingFetcher);\n    });\n    return new Map(state.fetchers);\n  }\n  // Trigger a fetcher load/submit for the given fetcher key\n  function fetch(key, routeId, href, opts) {\n    if (isServer) {\n      throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. \" + \"You are likely calling a useFetcher() method in the body of your component. \" + \"Try moving it to a useEffect or a callback.\");\n    }\n    abortFetcher(key);\n    let flushSync = (opts && opts.flushSync) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n    let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);\n    if (fogOfWar.active && fogOfWar.matches) {\n      matches = fogOfWar.matches;\n    }\n    if (!matches) {\n      setFetcherError(key, routeId, getInternalRouterError(404, {\n        pathname: normalizedPath\n      }), {\n        flushSync\n      });\n      return;\n    }\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\n    if (error) {\n      setFetcherError(key, routeId, error, {\n        flushSync\n      });\n      return;\n    }\n    let match = getTargetMatch(matches, path);\n    let preventScrollReset = (opts && opts.preventScrollReset) === true;\n    if (submission && isMutationMethod(submission.formMethod)) {\n      handleFetcherAction(key, routeId, path, match, matches, fogOfWar.active, flushSync, preventScrollReset, submission);\n      return;\n    }\n    // Store off the match so we can call it's shouldRevalidate on subsequent\n    // revalidations\n    fetchLoadMatches.set(key, {\n      routeId,\n      path\n    });\n    handleFetcherLoader(key, routeId, path, match, matches, fogOfWar.active, flushSync, preventScrollReset, submission);\n  }\n  // Call the action for the matched fetcher.submit(), and then handle redirects,\n  // errors, and revalidation\n  async function handleFetcherAction(key, routeId, path, match, requestMatches, isFogOfWar, flushSync, preventScrollReset, submission) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n    function detectAndHandle405Error(m) {\n      if (!m.route.action && !m.route.lazy) {\n        let error = getInternalRouterError(405, {\n          method: submission.formMethod,\n          pathname: path,\n          routeId: routeId\n        });\n        setFetcherError(key, routeId, error, {\n          flushSync\n        });\n        return true;\n      }\n      return false;\n    }\n    if (!isFogOfWar && detectAndHandle405Error(match)) {\n      return;\n    }\n    // Put this fetcher into it's submitting state\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n      flushSync\n    });\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n    if (isFogOfWar) {\n      let discoverResult = await discoverRoutes(requestMatches, new URL(fetchRequest.url).pathname, fetchRequest.signal, key);\n      if (discoverResult.type === \"aborted\") {\n        return;\n      } else if (discoverResult.type === \"error\") {\n        setFetcherError(key, routeId, discoverResult.error, {\n          flushSync\n        });\n        return;\n      } else if (!discoverResult.matches) {\n        setFetcherError(key, routeId, getInternalRouterError(404, {\n          pathname: path\n        }), {\n          flushSync\n        });\n        return;\n      } else {\n        requestMatches = discoverResult.matches;\n        match = getTargetMatch(requestMatches, path);\n        if (detectAndHandle405Error(match)) {\n          return;\n        }\n      }\n    }\n    // Call the action for the fetcher\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let actionResults = await callDataStrategy(\"action\", state, fetchRequest, [match], requestMatches, key);\n    let actionResult = actionResults[match.route.id];\n    if (fetchRequest.signal.aborted) {\n      // We can delete this so long as we weren't aborted by our own fetcher\n      // re-submit which would have put _new_ controller is in fetchControllers\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n    // When using v7_fetcherPersist, we don't want errors bubbling up to the UI\n    // or redirects processed for unmounted fetchers so we just revert them to\n    // idle\n    if (future.v7_fetcherPersist && deletedFetchers.has(key)) {\n      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {\n        updateFetcherState(key, getDoneFetcher(undefined));\n        return;\n      }\n      // Let SuccessResult's fall through for revalidation\n    } else {\n      if (isRedirectResult(actionResult)) {\n        fetchControllers.delete(key);\n        if (pendingNavigationLoadId > originatingLoadId) {\n          // A new navigation was kicked off after our action started, so that\n          // should take precedence over this redirect navigation.  We already\n          // set isRevalidationRequired so all loaders for the new route should\n          // fire unless opted out via shouldRevalidate\n          updateFetcherState(key, getDoneFetcher(undefined));\n          return;\n        } else {\n          fetchRedirectIds.add(key);\n          updateFetcherState(key, getLoadingFetcher(submission));\n          return startRedirectNavigation(fetchRequest, actionResult, false, {\n            fetcherSubmission: submission,\n            preventScrollReset\n          });\n        }\n      }\n      // Process any non-redirect errors thrown\n      if (isErrorResult(actionResult)) {\n        setFetcherError(key, routeId, actionResult.error);\n        return;\n      }\n    }\n    if (isDeferredResult(actionResult)) {\n      throw getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n    }\n    // Start the data load for current matches, or the next location if we're\n    // in the middle of a navigation\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, false, future.v7_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, [match.route.id, actionResult]);\n    // Put all revalidating fetchers into the loading state, except for the\n    // current fetcher which we want to keep in it's current loading state which\n    // contains it's action submission info + action data\n    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {\n      let staleKey = rf.key;\n      let existingFetcher = state.fetchers.get(staleKey);\n      let revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);\n      state.fetchers.set(staleKey, revalidatingFetcher);\n      abortFetcher(staleKey);\n      if (rf.controller) {\n        fetchControllers.set(staleKey, rf.controller);\n      }\n    });\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(rf => abortFetcher(rf.key));\n    abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n    let {\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\n    if (abortController.signal.aborted) {\n      return;\n    }\n    abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));\n    let redirect = findRedirect(loaderResults);\n    if (redirect) {\n      return startRedirectNavigation(revalidationRequest, redirect.result, false, {\n        preventScrollReset\n      });\n    }\n    redirect = findRedirect(fetcherResults);\n    if (redirect) {\n      // If this redirect came from a fetcher make sure we mark it in\n      // fetchRedirectIds so it doesn't get revalidated on the next set of\n      // loader executions\n      fetchRedirectIds.add(redirect.key);\n      return startRedirectNavigation(revalidationRequest, redirect.result, false, {\n        preventScrollReset\n      });\n    }\n    // Process and commit output from loaders\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, matches, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);\n    // Since we let revalidations complete even if the submitting fetcher was\n    // deleted, only put it back to idle if it hasn't been deleted\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n    abortStaleFetchLoads(loadId);\n    // If we are currently in a navigation loading state and this fetcher is\n    // more recent than the navigation, we want the newer data so abort the\n    // navigation and complete it with the fetcher data\n    if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers)\n      });\n    } else {\n      // otherwise just update with the fetcher data, preserving any existing\n      // loaderData for loaders that did not need to reload.  We have to\n      // manually merge here since we aren't going through completeNavigation\n      updateState({\n        errors,\n        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\n        fetchers: new Map(state.fetchers)\n      });\n      isRevalidationRequired = false;\n    }\n  }\n  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n  async function handleFetcherLoader(key, routeId, path, match, matches, isFogOfWar, flushSync, preventScrollReset, submission) {\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined), {\n      flushSync\n    });\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n    if (isFogOfWar) {\n      let discoverResult = await discoverRoutes(matches, new URL(fetchRequest.url).pathname, fetchRequest.signal, key);\n      if (discoverResult.type === \"aborted\") {\n        return;\n      } else if (discoverResult.type === \"error\") {\n        setFetcherError(key, routeId, discoverResult.error, {\n          flushSync\n        });\n        return;\n      } else if (!discoverResult.matches) {\n        setFetcherError(key, routeId, getInternalRouterError(404, {\n          pathname: path\n        }), {\n          flushSync\n        });\n        return;\n      } else {\n        matches = discoverResult.matches;\n        match = getTargetMatch(matches, path);\n      }\n    }\n    // Call the loader for this fetcher route match\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let results = await callDataStrategy(\"loader\", state, fetchRequest, [match], matches, key);\n    let result = results[match.route.id];\n    // Deferred isn't supported for fetcher loads, await everything and treat it\n    // as a normal load.  resolveDeferredData will return undefined if this\n    // fetcher gets aborted, so we just leave result untouched and short circuit\n    // below if that happens\n    if (isDeferredResult(result)) {\n      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;\n    }\n    // We can delete this so long as we weren't aborted by our our own fetcher\n    // re-load which would have put _new_ controller is in fetchControllers\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n    // We don't want errors bubbling up or redirects followed for unmounted\n    // fetchers, so short circuit here if it was removed from the UI\n    if (deletedFetchers.has(key)) {\n      updateFetcherState(key, getDoneFetcher(undefined));\n      return;\n    }\n    // If the loader threw a redirect Response, start a new REPLACE navigation\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our loader started, so that\n        // should take precedence over this redirect navigation\n        updateFetcherState(key, getDoneFetcher(undefined));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(fetchRequest, result, false, {\n          preventScrollReset\n        });\n        return;\n      }\n    }\n    // Process any non-redirect errors thrown\n    if (isErrorResult(result)) {\n      setFetcherError(key, routeId, result.error);\n      return;\n    }\n    invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n    // Put the fetcher back into an idle state\n    updateFetcherState(key, getDoneFetcher(result.data));\n  }\n  /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */\n  async function startRedirectNavigation(request, redirect, isNavigation, _temp2) {\n    let {\n      submission,\n      fetcherSubmission,\n      preventScrollReset,\n      replace\n    } = _temp2 === void 0 ? {} : _temp2;\n    if (redirect.response.headers.has(\"X-Remix-Revalidate\")) {\n      isRevalidationRequired = true;\n    }\n    let location = redirect.response.headers.get(\"Location\");\n    invariant(location, \"Expected a Location header on the redirect Response\");\n    location = normalizeRedirectLocation(location, new URL(request.url), basename);\n    let redirectLocation = createLocation(state.location, location, {\n      _isRedirect: true\n    });\n    if (isBrowser) {\n      let isDocumentReload = false;\n      if (redirect.response.headers.has(\"X-Remix-Reload-Document\")) {\n        // Hard reload if the response contained X-Remix-Reload-Document\n        isDocumentReload = true;\n      } else if (ABSOLUTE_URL_REGEX.test(location)) {\n        const url = init.history.createURL(location);\n        isDocumentReload =\n        // Hard reload if it's an absolute URL to a new origin\n        url.origin !== routerWindow.location.origin ||\n        // Hard reload if it's an absolute URL that does not match our basename\n        stripBasename(url.pathname, basename) == null;\n      }\n      if (isDocumentReload) {\n        if (replace) {\n          routerWindow.location.replace(location);\n        } else {\n          routerWindow.location.assign(location);\n        }\n        return;\n      }\n    }\n    // There's no need to abort on redirects, since we don't detect the\n    // redirect until the action/loaders have settled\n    pendingNavigationController = null;\n    let redirectHistoryAction = replace === true || redirect.response.headers.has(\"X-Remix-Replace\") ? Action.Replace : Action.Push;\n    // Use the incoming submission if provided, fallback on the active one in\n    // state.navigation\n    let {\n      formMethod,\n      formAction,\n      formEncType\n    } = state.navigation;\n    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n      submission = getSubmissionFromNavigation(state.navigation);\n    }\n    // If this was a 307/308 submission we want to preserve the HTTP method and\n    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n    // redirected location\n    let activeSubmission = submission || fetcherSubmission;\n    if (redirectPreserveMethodStatusCodes.has(redirect.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        submission: _extends({}, activeSubmission, {\n          formAction: location\n        }),\n        // Preserve these flags across redirects\n        preventScrollReset: preventScrollReset || pendingPreventScrollReset,\n        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : undefined\n      });\n    } else {\n      // If we have a navigation submission, we will preserve it through the\n      // redirect navigation\n      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation,\n        // Send fetcher submissions through for shouldRevalidate\n        fetcherSubmission,\n        // Preserve these flags across redirects\n        preventScrollReset: preventScrollReset || pendingPreventScrollReset,\n        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : undefined\n      });\n    }\n  }\n  // Utility wrapper for calling dataStrategy client-side without having to\n  // pass around the manifest, mapRouteProperties, etc.\n  async function callDataStrategy(type, state, request, matchesToLoad, matches, fetcherKey) {\n    let results;\n    let dataResults = {};\n    try {\n      results = await callDataStrategyImpl(dataStrategyImpl, type, state, request, matchesToLoad, matches, fetcherKey, manifest, mapRouteProperties);\n    } catch (e) {\n      // If the outer dataStrategy method throws, just return the error for all\n      // matches - and it'll naturally bubble to the root\n      matchesToLoad.forEach(m => {\n        dataResults[m.route.id] = {\n          type: ResultType.error,\n          error: e\n        };\n      });\n      return dataResults;\n    }\n    for (let [routeId, result] of Object.entries(results)) {\n      if (isRedirectDataStrategyResultResult(result)) {\n        let response = result.result;\n        dataResults[routeId] = {\n          type: ResultType.redirect,\n          response: normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename, future.v7_relativeSplatPath)\n        };\n      } else {\n        dataResults[routeId] = await convertDataStrategyResultToDataResult(result);\n      }\n    }\n    return dataResults;\n  }\n  async function callLoadersAndMaybeResolveData(state, matches, matchesToLoad, fetchersToLoad, request) {\n    let currentMatches = state.matches;\n    // Kick off loaders and fetchers in parallel\n    let loaderResultsPromise = callDataStrategy(\"loader\", state, request, matchesToLoad, matches, null);\n    let fetcherResultsPromise = Promise.all(fetchersToLoad.map(async f => {\n      if (f.matches && f.match && f.controller) {\n        let results = await callDataStrategy(\"loader\", state, createClientSideRequest(init.history, f.path, f.controller.signal), [f.match], f.matches, f.key);\n        let result = results[f.match.route.id];\n        // Fetcher results are keyed by fetcher key from here on out, not routeId\n        return {\n          [f.key]: result\n        };\n      } else {\n        return Promise.resolve({\n          [f.key]: {\n            type: ResultType.error,\n            error: getInternalRouterError(404, {\n              pathname: f.path\n            })\n          }\n        });\n      }\n    }));\n    let loaderResults = await loaderResultsPromise;\n    let fetcherResults = (await fetcherResultsPromise).reduce((acc, r) => Object.assign(acc, r), {});\n    await Promise.all([resolveNavigationDeferredResults(matches, loaderResults, request.signal, currentMatches, state.loaderData), resolveFetcherDeferredResults(matches, fetcherResults, fetchersToLoad)]);\n    return {\n      loaderResults,\n      fetcherResults\n    };\n  }\n  function interruptActiveLoads() {\n    // Every interruption triggers a revalidation\n    isRevalidationRequired = true;\n    // Cancel pending route-level deferreds and mark cancelled routes for\n    // revalidation\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n    // Abort in-flight fetcher loads\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.add(key);\n      }\n      abortFetcher(key);\n    });\n  }\n  function updateFetcherState(key, fetcher, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    state.fetchers.set(key, fetcher);\n    updateState({\n      fetchers: new Map(state.fetchers)\n    }, {\n      flushSync: (opts && opts.flushSync) === true\n    });\n  }\n  function setFetcherError(key, routeId, error, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState({\n      errors: {\n        [boundaryMatch.route.id]: error\n      },\n      fetchers: new Map(state.fetchers)\n    }, {\n      flushSync: (opts && opts.flushSync) === true\n    });\n  }\n  function getFetcher(key) {\n    activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n    // If this fetcher was previously marked for deletion, unmark it since we\n    // have a new instance\n    if (deletedFetchers.has(key)) {\n      deletedFetchers.delete(key);\n    }\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n  function deleteFetcher(key) {\n    let fetcher = state.fetchers.get(key);\n    // Don't abort the controller if this is a deletion of a fetcher.submit()\n    // in it's loading phase since - we don't want to abort the corresponding\n    // revalidation and want them to complete and land\n    if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    // If we opted into the flag we can clear this now since we're calling\n    // deleteFetcher() at the end of updateState() and we've already handed the\n    // deleted fetcher keys off to the data layer.\n    // If not, we're eagerly calling deleteFetcher() and we need to keep this\n    // Set populated until the next updateState call, and we'll clear\n    // `deletedFetchers` then\n    if (future.v7_fetcherPersist) {\n      deletedFetchers.delete(key);\n    }\n    cancelledFetcherLoads.delete(key);\n    state.fetchers.delete(key);\n  }\n  function deleteFetcherAndUpdateState(key) {\n    let count = (activeFetchers.get(key) || 0) - 1;\n    if (count <= 0) {\n      activeFetchers.delete(key);\n      deletedFetchers.add(key);\n      if (!future.v7_fetcherPersist) {\n        deleteFetcher(key);\n      }\n    } else {\n      activeFetchers.set(key, count);\n    }\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n  }\n  function abortFetcher(key) {\n    let controller = fetchControllers.get(key);\n    if (controller) {\n      controller.abort();\n      fetchControllers.delete(key);\n    }\n  }\n  function markFetchersDone(keys) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  function markFetchRedirectsDone() {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, \"Expected fetcher: \" + key);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n  function abortStaleFetchLoads(landedId) {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, \"Expected fetcher: \" + key);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n  function getBlocker(key, fn) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n    return blocker;\n  }\n  function deleteBlocker(key) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n  // Utility function to update blockers, ensuring valid state transitions\n  function updateBlocker(key, newBlocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    // Poor mans state machine :)\n    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n    invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", \"Invalid blocker state transition: \" + blocker.state + \" -> \" + newBlocker.state);\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({\n      blockers\n    });\n  }\n  function shouldBlockNavigation(_ref2) {\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = _ref2;\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n    // We ony support a single active blocker at the moment since we don't have\n    // any compelling use cases for multi-blocker yet\n    if (blockerFunctions.size > 1) {\n      warning(false, \"A router only supports one blocker at a time\");\n    }\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n    if (blocker && blocker.state === \"proceeding\") {\n      // If the blocker is currently proceeding, we don't need to re-check\n      // it and can let this navigation continue\n      return;\n    }\n    // At this point, we know we're unblocked/blocked so we need to check the\n    // user-provided blocker function\n    if (blockerFunction({\n      currentLocation,\n      nextLocation,\n      historyAction\n    })) {\n      return blockerKey;\n    }\n  }\n  function handleNavigational404(pathname) {\n    let error = getInternalRouterError(404, {\n      pathname\n    });\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let {\n      matches,\n      route\n    } = getShortCircuitMatches(routesToUse);\n    // Cancel all pending deferred on 404s since we don't keep any routes\n    cancelActiveDeferreds();\n    return {\n      notFoundMatches: matches,\n      route,\n      error\n    };\n  }\n  function cancelActiveDeferreds(predicate) {\n    let cancelledRouteIds = [];\n    activeDeferreds.forEach((dfd, routeId) => {\n      if (!predicate || predicate(routeId)) {\n        // Cancel the deferred - but do not remove from activeDeferreds here -\n        // we rely on the subscribers to do that so our tests can assert proper\n        // cleanup via _internalActiveDeferreds\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds.delete(routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n  // Opt in to capturing and reporting scroll positions during navigations,\n  // used by the <ScrollRestoration> component\n  function enableScrollRestoration(positions, getPosition, getKey) {\n    savedScrollPositions = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || null;\n    // Perform initial hydration scroll restoration, since we miss the boat on\n    // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n    // and therefore have no savedScrollPositions available\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({\n          restoreScrollPosition: y\n        });\n      }\n    }\n    return () => {\n      savedScrollPositions = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n  function getScrollKey(location, matches) {\n    if (getScrollRestorationKey) {\n      let key = getScrollRestorationKey(location, matches.map(m => convertRouteMatchToUiMatch(m, state.loaderData)));\n      return key || location.key;\n    }\n    return location.key;\n  }\n  function saveScrollPosition(location, matches) {\n    if (savedScrollPositions && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions[key] = getScrollPosition();\n    }\n  }\n  function getSavedScrollPosition(location, matches) {\n    if (savedScrollPositions) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n  function checkFogOfWar(matches, routesToUse, pathname) {\n    if (patchRoutesOnNavigationImpl) {\n      if (!matches) {\n        let fogMatches = matchRoutesImpl(routesToUse, pathname, basename, true);\n        return {\n          active: true,\n          matches: fogMatches || []\n        };\n      } else {\n        if (Object.keys(matches[0].params).length > 0) {\n          // If we matched a dynamic param or a splat, it might only be because\n          // we haven't yet discovered other routes that would match with a\n          // higher score.  Call patchRoutesOnNavigation just to be sure\n          let partialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);\n          return {\n            active: true,\n            matches: partialMatches\n          };\n        }\n      }\n    }\n    return {\n      active: false,\n      matches: null\n    };\n  }\n  async function discoverRoutes(matches, pathname, signal, fetcherKey) {\n    if (!patchRoutesOnNavigationImpl) {\n      return {\n        type: \"success\",\n        matches\n      };\n    }\n    let partialMatches = matches;\n    while (true) {\n      let isNonHMR = inFlightDataRoutes == null;\n      let routesToUse = inFlightDataRoutes || dataRoutes;\n      let localManifest = manifest;\n      try {\n        await patchRoutesOnNavigationImpl({\n          signal,\n          path: pathname,\n          matches: partialMatches,\n          fetcherKey,\n          patch: (routeId, children) => {\n            if (signal.aborted) return;\n            patchRoutesImpl(routeId, children, routesToUse, localManifest, mapRouteProperties);\n          }\n        });\n      } catch (e) {\n        return {\n          type: \"error\",\n          error: e,\n          partialMatches\n        };\n      } finally {\n        // If we are not in the middle of an HMR revalidation and we changed the\n        // routes, provide a new identity so when we `updateState` at the end of\n        // this navigation/fetch `router.routes` will be a new identity and\n        // trigger a re-run of memoized `router.routes` dependencies.\n        // HMR will already update the identity and reflow when it lands\n        // `inFlightDataRoutes` in `completeNavigation`\n        if (isNonHMR && !signal.aborted) {\n          dataRoutes = [...dataRoutes];\n        }\n      }\n      if (signal.aborted) {\n        return {\n          type: \"aborted\"\n        };\n      }\n      let newMatches = matchRoutes(routesToUse, pathname, basename);\n      if (newMatches) {\n        return {\n          type: \"success\",\n          matches: newMatches\n        };\n      }\n      let newPartialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);\n      // Avoid loops if the second pass results in the same partial matches\n      if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every((m, i) => m.route.id === newPartialMatches[i].route.id)) {\n        return {\n          type: \"success\",\n          matches: null\n        };\n      }\n      partialMatches = newPartialMatches;\n    }\n  }\n  function _internalSetRoutes(newRoutes) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);\n  }\n  function patchRoutes(routeId, children) {\n    let isNonHMR = inFlightDataRoutes == null;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties);\n    // If we are not in the middle of an HMR revalidation and we changed the\n    // routes, provide a new identity and trigger a reflow via `updateState`\n    // to re-run memoized `router.routes` dependencies.\n    // HMR will already update the identity and reflow when it lands\n    // `inFlightDataRoutes` in `completeNavigation`\n    if (isNonHMR) {\n      dataRoutes = [...dataRoutes];\n      updateState({});\n    }\n  }\n  router = {\n    get basename() {\n      return basename;\n    },\n    get future() {\n      return future;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return routerWindow;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: to => init.history.createHref(to),\n    encodeLocation: to => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher: deleteFetcherAndUpdateState,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    patchRoutes,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes\n  };\n  return router;\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\nconst UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\nfunction createStaticHandler(routes, opts) {\n  invariant(routes.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\n  let manifest = {};\n  let basename = (opts ? opts.basename : null) || \"/\";\n  let mapRouteProperties;\n  if (opts != null && opts.mapRouteProperties) {\n    mapRouteProperties = opts.mapRouteProperties;\n  } else if (opts != null && opts.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = opts.detectErrorBoundary;\n    mapRouteProperties = route => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  // Config driven behavior flags\n  let future = _extends({\n    v7_relativeSplatPath: false,\n    v7_throwAbortReason: false\n  }, opts ? opts.future : null);\n  let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);\n  /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   *\n   * - `opts.requestContext` is an optional server context that will be passed\n   *   to actions/loaders in the `context` parameter\n   * - `opts.skipLoaderErrorBubbling` is an optional parameter that will prevent\n   *   the bubbling of errors which allows single-fetch-type implementations\n   *   where the client will handle the bubbling and we may need to return data\n   *   for the handling route\n   */\n  async function query(request, _temp3) {\n    let {\n      requestContext,\n      skipLoaderErrorBubbling,\n      dataStrategy\n    } = _temp3 === void 0 ? {} : _temp3;\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\") {\n      let error = getInternalRouterError(405, {\n        method\n      });\n      let {\n        matches: methodNotAllowedMatches,\n        route\n      } = getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: methodNotAllowedMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    } else if (!matches) {\n      let error = getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n      let {\n        matches: notFoundMatches,\n        route\n      } = getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: notFoundMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    let result = await queryImpl(request, location, matches, requestContext, dataStrategy || null, skipLoaderErrorBubbling === true, null);\n    if (isResponse(result)) {\n      return result;\n    }\n    // When returning StaticHandlerContext, we patch back in the location here\n    // since we need it for React Context.  But this helps keep our submit and\n    // loadRouteData operating on a Request instead of a Location\n    return _extends({\n      location,\n      basename\n    }, result);\n  }\n  /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   *\n   * - `opts.routeId` allows you to specify the specific route handler to call.\n   *   If not provided the handler will determine the proper route by matching\n   *   against `request.url`\n   * - `opts.requestContext` is an optional server context that will be passed\n   *    to actions/loaders in the `context` parameter\n   */\n  async function queryRoute(request, _temp4) {\n    let {\n      routeId,\n      requestContext,\n      dataStrategy\n    } = _temp4 === void 0 ? {} : _temp4;\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n      throw getInternalRouterError(405, {\n        method\n      });\n    } else if (!matches) {\n      throw getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n    }\n    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);\n    if (routeId && !match) {\n      throw getInternalRouterError(403, {\n        pathname: location.pathname,\n        routeId\n      });\n    } else if (!match) {\n      // This should never hit I don't think?\n      throw getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n    }\n    let result = await queryImpl(request, location, matches, requestContext, dataStrategy || null, false, match);\n    if (isResponse(result)) {\n      return result;\n    }\n    let error = result.errors ? Object.values(result.errors)[0] : undefined;\n    if (error !== undefined) {\n      // If we got back result.errors, that means the loader/action threw\n      // _something_ that wasn't a Response, but it's not guaranteed/required\n      // to be an `instanceof Error` either, so we have to use throw here to\n      // preserve the \"error\" state outside of queryImpl.\n      throw error;\n    }\n    // Pick off the right state value to return\n    if (result.actionData) {\n      return Object.values(result.actionData)[0];\n    }\n    if (result.loaderData) {\n      var _result$activeDeferre;\n      let data = Object.values(result.loaderData)[0];\n      if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {\n        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n      }\n      return data;\n    }\n    return undefined;\n  }\n  async function queryImpl(request, location, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch) {\n    invariant(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\n    try {\n      if (isMutationMethod(request.method.toLowerCase())) {\n        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch != null);\n        return result;\n      }\n      let result = await loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch);\n      return isResponse(result) ? result : _extends({}, result, {\n        actionData: null,\n        actionHeaders: {}\n      });\n    } catch (e) {\n      // If the user threw/returned a Response in callLoaderOrAction for a\n      // `queryRoute` call, we throw the `DataStrategyResult` to bail out early\n      // and then return or throw the raw Response here accordingly\n      if (isDataStrategyResult(e) && isResponse(e.result)) {\n        if (e.type === ResultType.error) {\n          throw e.result;\n        }\n        return e.result;\n      }\n      // Redirects are always returned since they don't propagate to catch\n      // boundaries\n      if (isRedirectResponse(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n  async function submit(request, matches, actionMatch, requestContext, dataStrategy, skipLoaderErrorBubbling, isRouteRequest) {\n    let result;\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: actionMatch.route.id\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error\n      };\n    } else {\n      let results = await callDataStrategy(\"action\", request, [actionMatch], matches, isRouteRequest, requestContext, dataStrategy);\n      result = results[actionMatch.route.id];\n      if (request.signal.aborted) {\n        throwStaticHandlerAbortedError(request, isRouteRequest, future);\n      }\n    }\n    if (isRedirectResult(result)) {\n      // Uhhhh - this should never happen, we should always throw these from\n      // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n      // can get back on the \"throw all redirect responses\" train here should\n      // this ever happen :/\n      throw new Response(null, {\n        status: result.response.status,\n        headers: {\n          Location: result.response.headers.get(\"Location\")\n        }\n      });\n    }\n    if (isDeferredResult(result)) {\n      let error = getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error\n      };\n    }\n    if (isRouteRequest) {\n      // Note: This should only be non-Response values if we get here, since\n      // isRouteRequest should throw any Response received in callLoaderOrAction\n      if (isErrorResult(result)) {\n        throw result.error;\n      }\n      return {\n        matches: [actionMatch],\n        loaderData: {},\n        actionData: {\n          [actionMatch.route.id]: result.data\n        },\n        errors: null,\n        // Note: statusCode + headers are unused here since queryRoute will\n        // return the raw Response or value\n        statusCode: 200,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    // Create a GET request for the loaders\n    let loaderRequest = new Request(request.url, {\n      headers: request.headers,\n      redirect: request.redirect,\n      signal: request.signal\n    });\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);\n      let context = await loadRouteData(loaderRequest, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, null, [boundaryMatch.route.id, result]);\n      // action status codes take precedence over loader status codes\n      return _extends({}, context, {\n        statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,\n        actionData: null,\n        actionHeaders: _extends({}, result.headers ? {\n          [actionMatch.route.id]: result.headers\n        } : {})\n      });\n    }\n    let context = await loadRouteData(loaderRequest, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, null);\n    return _extends({}, context, {\n      actionData: {\n        [actionMatch.route.id]: result.data\n      }\n    }, result.statusCode ? {\n      statusCode: result.statusCode\n    } : {}, {\n      actionHeaders: result.headers ? {\n        [actionMatch.route.id]: result.headers\n      } : {}\n    });\n  }\n  async function loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, pendingActionResult) {\n    let isRouteRequest = routeMatch != null;\n    // Short circuit if we have no loaders to run (queryRoute())\n    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {\n      throw getInternalRouterError(400, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: routeMatch == null ? void 0 : routeMatch.route.id\n      });\n    }\n    let requestMatches = routeMatch ? [routeMatch] : pendingActionResult && isErrorResult(pendingActionResult[1]) ? getLoaderMatchesUntilBoundary(matches, pendingActionResult[0]) : matches;\n    let matchesToLoad = requestMatches.filter(m => m.route.loader || m.route.lazy);\n    // Short circuit if we have no loaders to run (query())\n    if (matchesToLoad.length === 0) {\n      return {\n        matches,\n        // Add a null for all matched routes for proper revalidation on the client\n        loaderData: matches.reduce((acc, m) => Object.assign(acc, {\n          [m.route.id]: null\n        }), {}),\n        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {\n          [pendingActionResult[0]]: pendingActionResult[1].error\n        } : null,\n        statusCode: 200,\n        loaderHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    let results = await callDataStrategy(\"loader\", request, matchesToLoad, matches, isRouteRequest, requestContext, dataStrategy);\n    if (request.signal.aborted) {\n      throwStaticHandlerAbortedError(request, isRouteRequest, future);\n    }\n    // Process and commit output from loaders\n    let activeDeferreds = new Map();\n    let context = processRouteLoaderData(matches, results, pendingActionResult, activeDeferreds, skipLoaderErrorBubbling);\n    // Add a null for any non-loader matches for proper revalidation on the client\n    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));\n    matches.forEach(match => {\n      if (!executedLoaders.has(match.route.id)) {\n        context.loaderData[match.route.id] = null;\n      }\n    });\n    return _extends({}, context, {\n      matches,\n      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null\n    });\n  }\n  // Utility wrapper for calling dataStrategy server-side without having to\n  // pass around the manifest, mapRouteProperties, etc.\n  async function callDataStrategy(type, request, matchesToLoad, matches, isRouteRequest, requestContext, dataStrategy) {\n    let results = await callDataStrategyImpl(dataStrategy || defaultDataStrategy, type, null, request, matchesToLoad, matches, null, manifest, mapRouteProperties, requestContext);\n    let dataResults = {};\n    await Promise.all(matches.map(async match => {\n      if (!(match.route.id in results)) {\n        return;\n      }\n      let result = results[match.route.id];\n      if (isRedirectDataStrategyResultResult(result)) {\n        let response = result.result;\n        // Throw redirects and let the server handle them with an HTTP redirect\n        throw normalizeRelativeRoutingRedirectResponse(response, request, match.route.id, matches, basename, future.v7_relativeSplatPath);\n      }\n      if (isResponse(result.result) && isRouteRequest) {\n        // For SSR single-route requests, we want to hand Responses back\n        // directly without unwrapping\n        throw result;\n      }\n      dataResults[match.route.id] = await convertDataStrategyResultToDataResult(result);\n    }));\n    return dataResults;\n  }\n  return {\n    dataRoutes,\n    query,\n    queryRoute\n  };\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */\nfunction getStaticContextFromError(routes, context, error) {\n  let newContext = _extends({}, context, {\n    statusCode: isRouteErrorResponse(error) ? error.status : 500,\n    errors: {\n      [context._deepestRenderedBoundaryId || routes[0].id]: error\n    }\n  });\n  return newContext;\n}\nfunction throwStaticHandlerAbortedError(request, isRouteRequest, future) {\n  if (future.v7_throwAbortReason && request.signal.reason !== undefined) {\n    throw request.signal.reason;\n  }\n  let method = isRouteRequest ? \"queryRoute\" : \"query\";\n  throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\n}\nfunction isSubmissionNavigation(opts) {\n  return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== undefined);\n}\nfunction normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {\n  let contextualMatches;\n  let activeRouteMatch;\n  if (fromRouteId) {\n    // Grab matches up to the calling route so our route-relative logic is\n    // relative to the correct source route\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n  // Resolve the relative path\n  let path = resolveTo(to ? to : \".\", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\n  // When `to` is not specified we inherit search/hash from the current\n  // location, unlike when to=\".\" and we just inherit the path.\n  // See https://github.com/remix-run/remix/issues/927\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n  // Account for `?index` params when routing to the current location\n  if ((to == null || to === \"\" || to === \".\") && activeRouteMatch) {\n    let nakedIndex = hasNakedIndexQuery(path.search);\n    if (activeRouteMatch.route.index && !nakedIndex) {\n      // Add one when we're targeting an index route\n      path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    } else if (!activeRouteMatch.route.index && nakedIndex) {\n      // Remove existing ones when we're not\n      let params = new URLSearchParams(path.search);\n      let indexValues = params.getAll(\"index\");\n      params.delete(\"index\");\n      indexValues.filter(v => v).forEach(v => params.append(\"index\", v));\n      let qs = params.toString();\n      path.search = qs ? \"?\" + qs : \"\";\n    }\n  }\n  // If we're operating within a basename, prepend it to the pathname.  If\n  // this is a root navigation, then just use the raw basename which allows\n  // the basename to have full control over the presence of a trailing slash\n  // on root actions\n  if (prependBasename && basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n  // Return location verbatim on non-submission navigations\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return {\n      path\n    };\n  }\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, {\n        method: opts.formMethod\n      })\n    };\n  }\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, {\n      type: \"invalid-body\"\n    })\n  });\n  // Create a Submission on non-GET navigations\n  let rawFormMethod = opts.formMethod || \"get\";\n  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n  let formAction = stripHashFromPath(path);\n  if (opts.body !== undefined) {\n    if (opts.formEncType === \"text/plain\") {\n      // text only support POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ?\n      // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n      Array.from(opts.body.entries()).reduce((acc, _ref3) => {\n        let [name, value] = _ref3;\n        return \"\" + acc + name + \"=\" + value + \"\\n\";\n      }, \"\") : String(opts.body);\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: undefined,\n          json: undefined,\n          text\n        }\n      };\n    } else if (opts.formEncType === \"application/json\") {\n      // json only supports POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      try {\n        let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: undefined,\n            json,\n            text: undefined\n          }\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n  invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\n  let searchParams;\n  let formData;\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n  let submission = {\n    formMethod,\n    formAction,\n    formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n    formData,\n    json: undefined,\n    text: undefined\n  };\n  if (isMutationMethod(submission.formMethod)) {\n    return {\n      path,\n      submission\n    };\n  }\n  // Flatten submission onto URLSearchParams for GET submissions\n  let parsedPath = parsePath(path);\n  // On GET navigation submissions we can drop the ?index param from the\n  // resulting location since all loaders will run.  But fetcher GET submissions\n  // only run a single loader so we need to preserve any incoming ?index params\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append(\"index\", \"\");\n  }\n  parsedPath.search = \"?\" + searchParams;\n  return {\n    path: createPath(parsedPath),\n    submission\n  };\n}\n// Filter out all routes at/below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId, includeBoundary) {\n  if (includeBoundary === void 0) {\n    includeBoundary = false;\n  }\n  let index = matches.findIndex(m => m.route.id === boundaryId);\n  if (index >= 0) {\n    return matches.slice(0, includeBoundary ? index + 1 : index);\n  }\n  return matches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, initialHydration, skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {\n  let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : undefined;\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n  // Pick navigation matches that are net-new or qualify for revalidation\n  let boundaryMatches = matches;\n  if (initialHydration && state.errors) {\n    // On initial hydration, only consider matches up to _and including_ the boundary.\n    // This is inclusive to handle cases where a server loader ran successfully,\n    // a child server loader bubbled up to this route, but this route has\n    // `clientLoader.hydrate` so we want to still run the `clientLoader` so that\n    // we have a complete version of `loaderData`\n    boundaryMatches = getLoaderMatchesUntilBoundary(matches, Object.keys(state.errors)[0], true);\n  } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {\n    // If an action threw an error, we call loaders up to, but not including the\n    // boundary\n    boundaryMatches = getLoaderMatchesUntilBoundary(matches, pendingActionResult[0]);\n  }\n  // Don't revalidate loaders by default after action 4xx/5xx responses\n  // when the flag is enabled.  They can still opt-into revalidation via\n  // `shouldRevalidate` via `actionResult`\n  let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : undefined;\n  let shouldSkipRevalidation = skipActionErrorRevalidation && actionStatus && actionStatus >= 400;\n  let navigationMatches = boundaryMatches.filter((match, index) => {\n    let {\n      route\n    } = match;\n    if (route.lazy) {\n      // We haven't loaded this route yet so we don't know if it's got a loader!\n      return true;\n    }\n    if (route.loader == null) {\n      return false;\n    }\n    if (initialHydration) {\n      return shouldLoadRouteOnHydration(route, state.loaderData, state.errors);\n    }\n    // Always call the loader on new route instances and pending defer cancellations\n    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {\n      return true;\n    }\n    // This is the default implementation for when we revalidate.  If the route\n    // provides it's own implementation, then we give them full control but\n    // provide this value so they can leverage it if needed after they check\n    // their own specific use cases\n    let currentRouteMatch = state.matches[index];\n    let nextRouteMatch = match;\n    return shouldRevalidateLoader(match, _extends({\n      currentUrl,\n      currentParams: currentRouteMatch.params,\n      nextUrl,\n      nextParams: nextRouteMatch.params\n    }, submission, {\n      actionResult,\n      actionStatus,\n      defaultShouldRevalidate: shouldSkipRevalidation ? false :\n      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n      isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search ||\n      // Search params affect all loaders\n      currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n    }));\n  });\n  // Pick fetcher.loads that need to be revalidated\n  let revalidatingFetchers = [];\n  fetchLoadMatches.forEach((f, key) => {\n    // Don't revalidate:\n    //  - on initial hydration (shouldn't be any fetchers then anyway)\n    //  - if fetcher won't be present in the subsequent render\n    //    - no longer matches the URL (v7_fetcherPersist=false)\n    //    - was unmounted but persisted due to v7_fetcherPersist=true\n    if (initialHydration || !matches.some(m => m.route.id === f.routeId) || deletedFetchers.has(key)) {\n      return;\n    }\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n    // If the fetcher path no longer matches, push it in with null matches so\n    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n    // currently only a use-case for Remix HMR where the route tree can change\n    // at runtime and remove a route previously loaded via a fetcher\n    if (!fetcherMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        controller: null\n      });\n      return;\n    }\n    // Revalidating fetchers are decoupled from the route matches since they\n    // load from a static href.  They revalidate based on explicit revalidation\n    // (submission, useRevalidator, or X-Remix-Revalidate)\n    let fetcher = state.fetchers.get(key);\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n    let shouldRevalidate = false;\n    if (fetchRedirectIds.has(key)) {\n      // Never trigger a revalidation of an actively redirecting fetcher\n      shouldRevalidate = false;\n    } else if (cancelledFetcherLoads.has(key)) {\n      // Always mark for revalidation if the fetcher was cancelled\n      cancelledFetcherLoads.delete(key);\n      shouldRevalidate = true;\n    } else if (fetcher && fetcher.state !== \"idle\" && fetcher.data === undefined) {\n      // If the fetcher hasn't ever completed loading yet, then this isn't a\n      // revalidation, it would just be a brand new load if an explicit\n      // revalidation is required\n      shouldRevalidate = isRevalidationRequired;\n    } else {\n      // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n      // to explicit revalidations only\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\n        currentUrl,\n        currentParams: state.matches[state.matches.length - 1].params,\n        nextUrl,\n        nextParams: matches[matches.length - 1].params\n      }, submission, {\n        actionResult,\n        actionStatus,\n        defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired\n      }));\n    }\n    if (shouldRevalidate) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherMatches,\n        match: fetcherMatch,\n        controller: new AbortController()\n      });\n    }\n  });\n  return [navigationMatches, revalidatingFetchers];\n}\nfunction shouldLoadRouteOnHydration(route, loaderData, errors) {\n  // We dunno if we have a loader - gotta find out!\n  if (route.lazy) {\n    return true;\n  }\n  // No loader, nothing to initialize\n  if (!route.loader) {\n    return false;\n  }\n  let hasData = loaderData != null && loaderData[route.id] !== undefined;\n  let hasError = errors != null && errors[route.id] !== undefined;\n  // Don't run if we error'd during SSR\n  if (!hasData && hasError) {\n    return false;\n  }\n  // Explicitly opting-in to running on hydration\n  if (typeof route.loader === \"function\" && route.loader.hydrate === true) {\n    return true;\n  }\n  // Otherwise, run if we're not yet initialized with anything\n  return !hasData && !hasError;\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n  let isNew =\n  // [a] -> [a, b]\n  !currentMatch ||\n  // [a, b] -> [a, c]\n  match.route.id !== currentMatch.route.id;\n  // Handle the case that we don't have data for a re-used route, potentially\n  // from a prior error or from a cancelled pending deferred\n  let isMissingData = currentLoaderData[match.route.id] === undefined;\n  // Always load if this is a net-new route or we don't yet have data\n  return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname ||\n    // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]\n  );\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n  return arg.defaultShouldRevalidate;\n}\nfunction patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties) {\n  var _childrenToPatch;\n  let childrenToPatch;\n  if (routeId) {\n    let route = manifest[routeId];\n    invariant(route, \"No route found to patch children into: routeId = \" + routeId);\n    if (!route.children) {\n      route.children = [];\n    }\n    childrenToPatch = route.children;\n  } else {\n    childrenToPatch = routesToUse;\n  }\n  // Don't patch in routes we already know about so that `patch` is idempotent\n  // to simplify user-land code. This is useful because we re-call the\n  // `patchRoutesOnNavigation` function for matched routes with params.\n  let uniqueChildren = children.filter(newRoute => !childrenToPatch.some(existingRoute => isSameRoute(newRoute, existingRoute)));\n  let newRoutes = convertRoutesToDataRoutes(uniqueChildren, mapRouteProperties, [routeId || \"_\", \"patch\", String(((_childrenToPatch = childrenToPatch) == null ? void 0 : _childrenToPatch.length) || \"0\")], manifest);\n  childrenToPatch.push(...newRoutes);\n}\nfunction isSameRoute(newRoute, existingRoute) {\n  // Most optimal check is by id\n  if (\"id\" in newRoute && \"id\" in existingRoute && newRoute.id === existingRoute.id) {\n    return true;\n  }\n  // Second is by pathing differences\n  if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {\n    return false;\n  }\n  // Pathless layout routes are trickier since we need to check children.\n  // If they have no children then they're the same as far as we can tell\n  if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {\n    return true;\n  }\n  // Otherwise, we look to see if every child in the new route is already\n  // represented in the existing route's children\n  return newRoute.children.every((aChild, i) => {\n    var _existingRoute$childr;\n    return (_existingRoute$childr = existingRoute.children) == null ? void 0 : _existingRoute$childr.some(bChild => isSameRoute(aChild, bChild));\n  });\n}\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */\nasync function loadLazyRouteModule(route, mapRouteProperties, manifest) {\n  if (!route.lazy) {\n    return;\n  }\n  let lazyRoute = await route.lazy();\n  // If the lazy route function was executed and removed by another parallel\n  // call then we can return - first lazy() to finish wins because the return\n  // value of lazy is expected to be static\n  if (!route.lazy) {\n    return;\n  }\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n  // Update the route in place.  This should be safe because there's no way\n  // we could yet be sitting on this route as we can't get there without\n  // resolving lazy() first.\n  //\n  // This is different than the HMR \"update\" use-case where we may actively be\n  // on the route being updated.  The main concern boils down to \"does this\n  // mutation affect any ongoing navigations or any current state.matches\n  // values?\".  If not, it should be safe to update in place.\n  let routeUpdates = {};\n  for (let lazyRouteProperty in lazyRoute) {\n    let staticRouteValue = routeToUpdate[lazyRouteProperty];\n    let isPropertyStaticallyDefined = staticRouteValue !== undefined &&\n    // This property isn't static since it should always be updated based\n    // on the route updates\n    lazyRouteProperty !== \"hasErrorBoundary\";\n    warning(!isPropertyStaticallyDefined, \"Route \\\"\" + routeToUpdate.id + \"\\\" has a static property \\\"\" + lazyRouteProperty + \"\\\" \" + \"defined but its lazy function is also returning a value for this property. \" + (\"The lazy route property \\\"\" + lazyRouteProperty + \"\\\" will be ignored.\"));\n    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n    }\n  }\n  // Mutate the route with the provided updates.  Do this first so we pass\n  // the updated version to mapRouteProperties\n  Object.assign(routeToUpdate, routeUpdates);\n  // Mutate the `hasErrorBoundary` property on the route based on the route\n  // updates and remove the `lazy` function so we don't resolve the lazy\n  // route again.\n  Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {\n    lazy: undefined\n  }));\n}\n// Default implementation of `dataStrategy` which fetches all loaders in parallel\nasync function defaultDataStrategy(_ref4) {\n  let {\n    matches\n  } = _ref4;\n  let matchesToLoad = matches.filter(m => m.shouldLoad);\n  let results = await Promise.all(matchesToLoad.map(m => m.resolve()));\n  return results.reduce((acc, result, i) => Object.assign(acc, {\n    [matchesToLoad[i].route.id]: result\n  }), {});\n}\nasync function callDataStrategyImpl(dataStrategyImpl, type, state, request, matchesToLoad, matches, fetcherKey, manifest, mapRouteProperties, requestContext) {\n  let loadRouteDefinitionsPromises = matches.map(m => m.route.lazy ? loadLazyRouteModule(m.route, mapRouteProperties, manifest) : undefined);\n  let dsMatches = matches.map((match, i) => {\n    let loadRoutePromise = loadRouteDefinitionsPromises[i];\n    let shouldLoad = matchesToLoad.some(m => m.route.id === match.route.id);\n    // `resolve` encapsulates route.lazy(), executing the loader/action,\n    // and mapping return values/thrown errors to a `DataStrategyResult`.  Users\n    // can pass a callback to take fine-grained control over the execution\n    // of the loader/action\n    let resolve = async handlerOverride => {\n      if (handlerOverride && request.method === \"GET\" && (match.route.lazy || match.route.loader)) {\n        shouldLoad = true;\n      }\n      return shouldLoad ? callLoaderOrAction(type, request, match, loadRoutePromise, handlerOverride, requestContext) : Promise.resolve({\n        type: ResultType.data,\n        result: undefined\n      });\n    };\n    return _extends({}, match, {\n      shouldLoad,\n      resolve\n    });\n  });\n  // Send all matches here to allow for a middleware-type implementation.\n  // handler will be a no-op for unneeded routes and we filter those results\n  // back out below.\n  let results = await dataStrategyImpl({\n    matches: dsMatches,\n    request,\n    params: matches[0].params,\n    fetcherKey,\n    context: requestContext\n  });\n  // Wait for all routes to load here but 'swallow the error since we want\n  // it to bubble up from the `await loadRoutePromise` in `callLoaderOrAction` -\n  // called from `match.resolve()`\n  try {\n    await Promise.all(loadRouteDefinitionsPromises);\n  } catch (e) {\n    // No-op\n  }\n  return results;\n}\n// Default logic for calling a loader/action is the user has no specified a dataStrategy\nasync function callLoaderOrAction(type, request, match, loadRoutePromise, handlerOverride, staticContext) {\n  let result;\n  let onReject;\n  let runHandler = handler => {\n    // Setup a promise we can race against so that abort signals short circuit\n    let reject;\n    // This will never resolve so safe to type it as Promise<DataStrategyResult> to\n    // satisfy the function return value\n    let abortPromise = new Promise((_, r) => reject = r);\n    onReject = () => reject();\n    request.signal.addEventListener(\"abort\", onReject);\n    let actualHandler = ctx => {\n      if (typeof handler !== \"function\") {\n        return Promise.reject(new Error(\"You cannot call the handler for a route which defines a boolean \" + (\"\\\"\" + type + \"\\\" [routeId: \" + match.route.id + \"]\")));\n      }\n      return handler({\n        request,\n        params: match.params,\n        context: staticContext\n      }, ...(ctx !== undefined ? [ctx] : []));\n    };\n    let handlerPromise = (async () => {\n      try {\n        let val = await (handlerOverride ? handlerOverride(ctx => actualHandler(ctx)) : actualHandler());\n        return {\n          type: \"data\",\n          result: val\n        };\n      } catch (e) {\n        return {\n          type: \"error\",\n          result: e\n        };\n      }\n    })();\n    return Promise.race([handlerPromise, abortPromise]);\n  };\n  try {\n    let handler = match.route[type];\n    // If we have a route.lazy promise, await that first\n    if (loadRoutePromise) {\n      if (handler) {\n        // Run statically defined handler in parallel with lazy()\n        let handlerError;\n        let [value] = await Promise.all([\n        // If the handler throws, don't let it immediately bubble out,\n        // since we need to let the lazy() execution finish so we know if this\n        // route has a boundary that can handle the error\n        runHandler(handler).catch(e => {\n          handlerError = e;\n        }), loadRoutePromise]);\n        if (handlerError !== undefined) {\n          throw handlerError;\n        }\n        result = value;\n      } else {\n        // Load lazy route module, then run any returned handler\n        await loadRoutePromise;\n        handler = match.route[type];\n        if (handler) {\n          // Handler still runs even if we got interrupted to maintain consistency\n          // with un-abortable behavior of handler execution on non-lazy or\n          // previously-lazy-loaded routes\n          result = await runHandler(handler);\n        } else if (type === \"action\") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id\n          });\n        } else {\n          // lazy() route has no loader to run.  Short circuit here so we don't\n          // hit the invariant below that errors on returning undefined.\n          return {\n            type: ResultType.data,\n            result: undefined\n          };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n    invariant(result.result !== undefined, \"You defined \" + (type === \"action\" ? \"an action\" : \"a loader\") + \" for route \" + (\"\\\"\" + match.route.id + \"\\\" but didn't return anything from your `\" + type + \"` \") + \"function. Please return a value or `null`.\");\n  } catch (e) {\n    // We should already be catching and converting normal handler executions to\n    // DataStrategyResults and returning them, so anything that throws here is an\n    // unexpected error we still need to wrap\n    return {\n      type: ResultType.error,\n      result: e\n    };\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener(\"abort\", onReject);\n    }\n  }\n  return result;\n}\nasync function convertDataStrategyResultToDataResult(dataStrategyResult) {\n  let {\n    result,\n    type\n  } = dataStrategyResult;\n  if (isResponse(result)) {\n    let data;\n    try {\n      let contentType = result.headers.get(\"Content-Type\");\n      // Check between word boundaries instead of startsWith() due to the last\n      // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n      if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n        if (result.body == null) {\n          data = null;\n        } else {\n          data = await result.json();\n        }\n      } else {\n        data = await result.text();\n      }\n    } catch (e) {\n      return {\n        type: ResultType.error,\n        error: e\n      };\n    }\n    if (type === ResultType.error) {\n      return {\n        type: ResultType.error,\n        error: new ErrorResponseImpl(result.status, result.statusText, data),\n        statusCode: result.status,\n        headers: result.headers\n      };\n    }\n    return {\n      type: ResultType.data,\n      data,\n      statusCode: result.status,\n      headers: result.headers\n    };\n  }\n  if (type === ResultType.error) {\n    if (isDataWithResponseInit(result)) {\n      var _result$init3, _result$init4;\n      if (result.data instanceof Error) {\n        var _result$init, _result$init2;\n        return {\n          type: ResultType.error,\n          error: result.data,\n          statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n          headers: (_result$init2 = result.init) != null && _result$init2.headers ? new Headers(result.init.headers) : undefined\n        };\n      }\n      // Convert thrown data() to ErrorResponse instances\n      return {\n        type: ResultType.error,\n        error: new ErrorResponseImpl(((_result$init3 = result.init) == null ? void 0 : _result$init3.status) || 500, undefined, result.data),\n        statusCode: isRouteErrorResponse(result) ? result.status : undefined,\n        headers: (_result$init4 = result.init) != null && _result$init4.headers ? new Headers(result.init.headers) : undefined\n      };\n    }\n    return {\n      type: ResultType.error,\n      error: result,\n      statusCode: isRouteErrorResponse(result) ? result.status : undefined\n    };\n  }\n  if (isDeferredData(result)) {\n    var _result$init5, _result$init6;\n    return {\n      type: ResultType.deferred,\n      deferredData: result,\n      statusCode: (_result$init5 = result.init) == null ? void 0 : _result$init5.status,\n      headers: ((_result$init6 = result.init) == null ? void 0 : _result$init6.headers) && new Headers(result.init.headers)\n    };\n  }\n  if (isDataWithResponseInit(result)) {\n    var _result$init7, _result$init8;\n    return {\n      type: ResultType.data,\n      data: result.data,\n      statusCode: (_result$init7 = result.init) == null ? void 0 : _result$init7.status,\n      headers: (_result$init8 = result.init) != null && _result$init8.headers ? new Headers(result.init.headers) : undefined\n    };\n  }\n  return {\n    type: ResultType.data,\n    data: result\n  };\n}\n// Support relative routing in internal redirects\nfunction normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename, v7_relativeSplatPath) {\n  let location = response.headers.get(\"Location\");\n  invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n  if (!ABSOLUTE_URL_REGEX.test(location)) {\n    let trimmedMatches = matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1);\n    location = normalizeTo(new URL(request.url), trimmedMatches, basename, true, location, v7_relativeSplatPath);\n    response.headers.set(\"Location\", location);\n  }\n  return response;\n}\nfunction normalizeRedirectLocation(location, currentUrl, basename) {\n  if (ABSOLUTE_URL_REGEX.test(location)) {\n    // Strip off the protocol+origin for same-origin + same-basename absolute redirects\n    let normalizedLocation = location;\n    let url = normalizedLocation.startsWith(\"//\") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);\n    let isSameBasename = stripBasename(url.pathname, basename) != null;\n    if (url.origin === currentUrl.origin && isSameBasename) {\n      return url.pathname + url.search + url.hash;\n    }\n  }\n  return location;\n}\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(history, location, signal, submission) {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init = {\n    signal\n  };\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let {\n      formMethod,\n      formEncType\n    } = submission;\n    // Didn't think we needed this but it turns out unlike other methods, patch\n    // won't be properly normalized to uppercase and results in a 405 error.\n    // See: https://fetch.spec.whatwg.org/#concept-method\n    init.method = formMethod.toUpperCase();\n    if (formEncType === \"application/json\") {\n      init.headers = new Headers({\n        \"Content-Type\": formEncType\n      });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === \"text/plain\") {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.text;\n    } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.formData;\n    }\n  }\n  return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n  let searchParams = new URLSearchParams();\n  for (let [key, value] of formData.entries()) {\n    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\n  }\n  return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\nfunction processRouteLoaderData(matches, results, pendingActionResult, activeDeferreds, skipLoaderErrorBubbling) {\n  // Fill in loaderData/errors from our loaders\n  let loaderData = {};\n  let errors = null;\n  let statusCode;\n  let foundError = false;\n  let loaderHeaders = {};\n  let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : undefined;\n  // Process loader results into state.loaderData/state.errors\n  matches.forEach(match => {\n    if (!(match.route.id in results)) {\n      return;\n    }\n    let id = match.route.id;\n    let result = results[id];\n    invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n    if (isErrorResult(result)) {\n      let error = result.error;\n      // If we have a pending action error, we report it at the highest-route\n      // that throws a loader error, and then clear it out to indicate that\n      // it was consumed\n      if (pendingError !== undefined) {\n        error = pendingError;\n        pendingError = undefined;\n      }\n      errors = errors || {};\n      if (skipLoaderErrorBubbling) {\n        errors[id] = error;\n      } else {\n        // Look upwards from the matched route for the closest ancestor error\n        // boundary, defaulting to the root match.  Prefer higher error values\n        // if lower errors bubble to the same boundary\n        let boundaryMatch = findNearestBoundary(matches, id);\n        if (errors[boundaryMatch.route.id] == null) {\n          errors[boundaryMatch.route.id] = error;\n        }\n      }\n      // Clear our any prior loaderData for the throwing route\n      loaderData[id] = undefined;\n      // Once we find our first (highest) error, we set the status code and\n      // prevent deeper status codes from overriding\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      if (isDeferredResult(result)) {\n        activeDeferreds.set(id, result.deferredData);\n        loaderData[id] = result.deferredData.data;\n        // Error status codes always override success status codes, but if all\n        // loaders are successful we take the deepest status code.\n        if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n          statusCode = result.statusCode;\n        }\n        if (result.headers) {\n          loaderHeaders[id] = result.headers;\n        }\n      } else {\n        loaderData[id] = result.data;\n        // Error status codes always override success status codes, but if all\n        // loaders are successful we take the deepest status code.\n        if (result.statusCode && result.statusCode !== 200 && !foundError) {\n          statusCode = result.statusCode;\n        }\n        if (result.headers) {\n          loaderHeaders[id] = result.headers;\n        }\n      }\n    }\n  });\n  // If we didn't consume the pending action error (i.e., all loaders\n  // resolved), then consume it here.  Also clear out any loaderData for the\n  // throwing route\n  if (pendingError !== undefined && pendingActionResult) {\n    errors = {\n      [pendingActionResult[0]]: pendingError\n    };\n    loaderData[pendingActionResult[0]] = undefined;\n  }\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders\n  };\n}\nfunction processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds) {\n  let {\n    loaderData,\n    errors\n  } = processRouteLoaderData(matches, results, pendingActionResult, activeDeferreds, false // This method is only called client side so we always want to bubble\n  );\n  // Process results from our revalidating fetchers\n  revalidatingFetchers.forEach(rf => {\n    let {\n      key,\n      match,\n      controller\n    } = rf;\n    let result = fetcherResults[key];\n    invariant(result, \"Did not find corresponding fetcher result\");\n    // Process fetcher non-redirect errors\n    if (controller && controller.signal.aborted) {\n      // Nothing to do for aborted fetchers\n      return;\n    } else if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = _extends({}, errors, {\n          [boundaryMatch.route.id]: result.error\n        });\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      // Should never get here, redirects should get processed above, but we\n      // keep this to type narrow to a success result in the else\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\n    } else if (isDeferredResult(result)) {\n      // Should never get here, deferred data should be awaited for fetchers\n      // in resolveDeferredResults\n      invariant(false, \"Unhandled fetcher deferred data\");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  });\n  return {\n    loaderData,\n    errors\n  };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n  let mergedLoaderData = _extends({}, newLoaderData);\n  for (let match of matches) {\n    let id = match.route.id;\n    if (newLoaderData.hasOwnProperty(id)) {\n      if (newLoaderData[id] !== undefined) {\n        mergedLoaderData[id] = newLoaderData[id];\n      }\n    } else if (loaderData[id] !== undefined && match.route.loader) {\n      // Preserve existing keys not included in newLoaderData and where a loader\n      // wasn't removed by HMR\n      mergedLoaderData[id] = loaderData[id];\n    }\n    if (errors && errors.hasOwnProperty(id)) {\n      // Don't keep any loader data below the boundary\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\nfunction getActionDataForCommit(pendingActionResult) {\n  if (!pendingActionResult) {\n    return {};\n  }\n  return isErrorResult(pendingActionResult[1]) ? {\n    // Clear out prior actionData on errors\n    actionData: {}\n  } : {\n    actionData: {\n      [pendingActionResult[0]]: pendingActionResult[1].data\n    }\n  };\n}\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(matches, routeId) {\n  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];\n  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n  // Prefer a root layout route if present, otherwise shim in a route object\n  let route = routes.length === 1 ? routes[0] : routes.find(r => r.index || !r.path || r.path === \"/\") || {\n    id: \"__shim-error-route__\"\n  };\n  return {\n    matches: [{\n      params: {},\n      pathname: \"\",\n      pathnameBase: \"\",\n      route\n    }],\n    route\n  };\n}\nfunction getInternalRouterError(status, _temp5) {\n  let {\n    pathname,\n    routeId,\n    method,\n    type,\n    message\n  } = _temp5 === void 0 ? {} : _temp5;\n  let statusText = \"Unknown Server Error\";\n  let errorMessage = \"Unknown @remix-run/router error\";\n  if (status === 400) {\n    statusText = \"Bad Request\";\n    if (method && pathname && routeId) {\n      errorMessage = \"You made a \" + method + \" request to \\\"\" + pathname + \"\\\" but \" + (\"did not provide a `loader` for route \\\"\" + routeId + \"\\\", \") + \"so there is no way to handle the request.\";\n    } else if (type === \"defer-action\") {\n      errorMessage = \"defer() is not supported in actions\";\n    } else if (type === \"invalid-body\") {\n      errorMessage = \"Unable to encode submission body\";\n    }\n  } else if (status === 403) {\n    statusText = \"Forbidden\";\n    errorMessage = \"Route \\\"\" + routeId + \"\\\" does not match URL \\\"\" + pathname + \"\\\"\";\n  } else if (status === 404) {\n    statusText = \"Not Found\";\n    errorMessage = \"No route matches URL \\\"\" + pathname + \"\\\"\";\n  } else if (status === 405) {\n    statusText = \"Method Not Allowed\";\n    if (method && pathname && routeId) {\n      errorMessage = \"You made a \" + method.toUpperCase() + \" request to \\\"\" + pathname + \"\\\" but \" + (\"did not provide an `action` for route \\\"\" + routeId + \"\\\", \") + \"so there is no way to handle the request.\";\n    } else if (method) {\n      errorMessage = \"Invalid request method \\\"\" + method.toUpperCase() + \"\\\"\";\n    }\n  }\n  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results) {\n  let entries = Object.entries(results);\n  for (let i = entries.length - 1; i >= 0; i--) {\n    let [key, result] = entries[i];\n    if (isRedirectResult(result)) {\n      return {\n        key,\n        result\n      };\n    }\n  }\n}\nfunction stripHashFromPath(path) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath(_extends({}, parsedPath, {\n    hash: \"\"\n  }));\n}\nfunction isHashChangeOnly(a, b) {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n  if (a.hash === \"\") {\n    // /page -> /page#hash\n    return b.hash !== \"\";\n  } else if (a.hash === b.hash) {\n    // /page#hash -> /page#hash\n    return true;\n  } else if (b.hash !== \"\") {\n    // /page#hash -> /page#other\n    return true;\n  }\n  // If the hash is removed the browser will re-perform a request to the server\n  // /page#hash -> /page\n  return false;\n}\nfunction isDataStrategyResult(result) {\n  return result != null && typeof result === \"object\" && \"type\" in result && \"result\" in result && (result.type === ResultType.data || result.type === ResultType.error);\n}\nfunction isRedirectDataStrategyResultResult(result) {\n  return isResponse(result.result) && redirectStatusCodes.has(result.result.status);\n}\nfunction isDeferredResult(result) {\n  return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n  return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n  return (result && result.type) === ResultType.redirect;\n}\nfunction isDataWithResponseInit(value) {\n  return typeof value === \"object\" && value != null && \"type\" in value && \"data\" in value && \"init\" in value && value.type === \"DataWithResponseInit\";\n}\nfunction isDeferredData(value) {\n  let deferred = value;\n  return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isRedirectResponse(result) {\n  if (!isResponse(result)) {\n    return false;\n  }\n  let status = result.status;\n  let location = result.headers.get(\"Location\");\n  return status >= 300 && status <= 399 && location != null;\n}\nfunction isValidMethod(method) {\n  return validRequestMethods.has(method.toLowerCase());\n}\nfunction isMutationMethod(method) {\n  return validMutationMethods.has(method.toLowerCase());\n}\nasync function resolveNavigationDeferredResults(matches, results, signal, currentMatches, currentLoaderData) {\n  let entries = Object.entries(results);\n  for (let index = 0; index < entries.length; index++) {\n    let [routeId, result] = entries[index];\n    let match = matches.find(m => (m == null ? void 0 : m.route.id) === routeId);\n    // If we don't have a match, then we can have a deferred result to do\n    // anything with.  This is for revalidating fetchers where the route was\n    // removed during HMR\n    if (!match) {\n      continue;\n    }\n    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);\n    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n    if (isDeferredResult(result) && isRevalidatingLoader) {\n      // Note: we do not have to touch activeDeferreds here since we race them\n      // against the signal in resolveDeferredData and they'll get aborted\n      // there if needed\n      await resolveDeferredData(result, signal, false).then(result => {\n        if (result) {\n          results[routeId] = result;\n        }\n      });\n    }\n  }\n}\nasync function resolveFetcherDeferredResults(matches, results, revalidatingFetchers) {\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\n    let {\n      key,\n      routeId,\n      controller\n    } = revalidatingFetchers[index];\n    let result = results[key];\n    let match = matches.find(m => (m == null ? void 0 : m.route.id) === routeId);\n    // If we don't have a match, then we can have a deferred result to do\n    // anything with.  This is for revalidating fetchers where the route was\n    // removed during HMR\n    if (!match) {\n      continue;\n    }\n    if (isDeferredResult(result)) {\n      // Note: we do not have to touch activeDeferreds here since we race them\n      // against the signal in resolveDeferredData and they'll get aborted\n      // there if needed\n      invariant(controller, \"Expected an AbortController for revalidating fetcher deferred result\");\n      await resolveDeferredData(result, controller.signal, true).then(result => {\n        if (result) {\n          results[key] = result;\n        }\n      });\n    }\n  }\n}\nasync function resolveDeferredData(result, signal, unwrap) {\n  if (unwrap === void 0) {\n    unwrap = false;\n  }\n  let aborted = await result.deferredData.resolveData(signal);\n  if (aborted) {\n    return;\n  }\n  if (unwrap) {\n    try {\n      return {\n        type: ResultType.data,\n        data: result.deferredData.unwrappedData\n      };\n    } catch (e) {\n      // Handle any TrackedPromise._error values encountered while unwrapping\n      return {\n        type: ResultType.error,\n        error: e\n      };\n    }\n  }\n  return {\n    type: ResultType.data,\n    data: result.deferredData.data\n  };\n}\nfunction hasNakedIndexQuery(search) {\n  return new URLSearchParams(search).getAll(\"index\").some(v => v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n  let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n    // Return the leaf index route when index is present\n    return matches[matches.length - 1];\n  }\n  // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n  // pathless layout routes)\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n  let {\n    formMethod,\n    formAction,\n    formEncType,\n    text,\n    formData,\n    json\n  } = navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json: undefined,\n      text\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: undefined,\n      text: undefined\n    };\n  } else if (json !== undefined) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json,\n      text: undefined\n    };\n  }\n}\nfunction getLoadingNavigation(location, submission) {\n  if (submission) {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text\n    };\n    return navigation;\n  } else {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined\n    };\n    return navigation;\n  }\n}\nfunction getSubmittingNavigation(location, submission) {\n  let navigation = {\n    state: \"submitting\",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text\n  };\n  return navigation;\n}\nfunction getLoadingFetcher(submission, data) {\n  if (submission) {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data\n    };\n    return fetcher;\n  } else {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n      data\n    };\n    return fetcher;\n  }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n  let fetcher = {\n    state: \"submitting\",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : undefined\n  };\n  return fetcher;\n}\nfunction getDoneFetcher(data) {\n  let fetcher = {\n    state: \"idle\",\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined,\n    data\n  };\n  return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n  try {\n    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\n    if (sessionPositions) {\n      let json = JSON.parse(sessionPositions);\n      for (let [k, v] of Object.entries(json || {})) {\n        if (v && Array.isArray(v)) {\n          transitions.set(k, new Set(v || []));\n        }\n      }\n    }\n  } catch (e) {\n    // no-op, use default empty object\n  }\n}\nfunction persistAppliedTransitions(_window, transitions) {\n  if (transitions.size > 0) {\n    let json = {};\n    for (let [k, v] of transitions) {\n      json[k] = [...v];\n    }\n    try {\n      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));\n    } catch (error) {\n      warning(false, \"Failed to save applied view transitions in sessionStorage (\" + error + \").\");\n    }\n  }\n}\n//#endregion\n\nexport { AbortedDeferredError, Action, IDLE_BLOCKER, IDLE_FETCHER, IDLE_NAVIGATION, UNSAFE_DEFERRED_SYMBOL, DeferredData as UNSAFE_DeferredData, ErrorResponseImpl as UNSAFE_ErrorResponseImpl, convertRouteMatchToUiMatch as UNSAFE_convertRouteMatchToUiMatch, convertRoutesToDataRoutes as UNSAFE_convertRoutesToDataRoutes, decodePath as UNSAFE_decodePath, getResolveToMatches as UNSAFE_getResolveToMatches, invariant as UNSAFE_invariant, warning as UNSAFE_warning, createBrowserHistory, createHashHistory, createMemoryHistory, createPath, createRouter, createStaticHandler, data, defer, generatePath, getStaticContextFromError, getToPathname, isDataWithResponseInit, isDeferredData, isRouteErrorResponse, joinPaths, json, matchPath, matchRoutes, normalizePathname, parsePath, redirect, redirectDocument, replace, resolvePath, resolveTo, stripBasename };\n//# sourceMappingURL=router.js.map\n","/**\n * React Router v6.30.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { UNSAFE_invariant, joinPaths, matchPath, UNSAFE_decodePath, UNSAFE_getResolveToMatches, UNSAFE_warning, resolveTo, parsePath, matchRoutes, Action, UNSAFE_convertRouteMatchToUiMatch, stripBasename, IDLE_BLOCKER, isRouteErrorResponse, createMemoryHistory, AbortedDeferredError, createRouter } from '@remix-run/router';\nexport { AbortedDeferredError, Action as NavigationType, createPath, defer, generatePath, isRouteErrorResponse, json, matchPath, matchRoutes, parsePath, redirect, redirectDocument, replace, resolvePath } from '@remix-run/router';\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// Create react-specific types from the agnostic types in @remix-run/router to\n// export from react-router\nconst DataRouterContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  DataRouterContext.displayName = \"DataRouter\";\n}\nconst DataRouterStateContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  DataRouterStateContext.displayName = \"DataRouterState\";\n}\nconst AwaitContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  AwaitContext.displayName = \"Await\";\n}\n\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level `<Router>` API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */\n\nconst NavigationContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  NavigationContext.displayName = \"Navigation\";\n}\nconst LocationContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  LocationContext.displayName = \"Location\";\n}\nconst RouteContext = /*#__PURE__*/React.createContext({\n  outlet: null,\n  matches: [],\n  isDataRoute: false\n});\nif (process.env.NODE_ENV !== \"production\") {\n  RouteContext.displayName = \"Route\";\n}\nconst RouteErrorContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  RouteErrorContext.displayName = \"RouteError\";\n}\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/v6/hooks/use-href\n */\nfunction useHref(to, _temp) {\n  let {\n    relative\n  } = _temp === void 0 ? {} : _temp;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useHref() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  let {\n    basename,\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    hash,\n    pathname,\n    search\n  } = useResolvedPath(to, {\n    relative\n  });\n  let joinedPathname = pathname;\n\n  // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the href.  If this is a root navigation, then just use the raw\n  // basename which allows the basename to have full control over the presence\n  // of a trailing slash on root links\n  if (basename !== \"/\") {\n    joinedPathname = pathname === \"/\" ? basename : joinPaths([basename, pathname]);\n  }\n  return navigator.createHref({\n    pathname: joinedPathname,\n    search,\n    hash\n  });\n}\n\n/**\n * Returns true if this component is a descendant of a `<Router>`.\n *\n * @see https://reactrouter.com/v6/hooks/use-in-router-context\n */\nfunction useInRouterContext() {\n  return React.useContext(LocationContext) != null;\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/v6/hooks/use-location\n */\nfunction useLocation() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useLocation() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  return React.useContext(LocationContext).location;\n}\n\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/v6/hooks/use-navigation-type\n */\nfunction useNavigationType() {\n  return React.useContext(LocationContext).navigationType;\n}\n\n/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * `<NavLink>`.\n *\n * @see https://reactrouter.com/v6/hooks/use-match\n */\nfunction useMatch(pattern) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useMatch() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  let {\n    pathname\n  } = useLocation();\n  return React.useMemo(() => matchPath(pattern, UNSAFE_decodePath(pathname)), [pathname, pattern]);\n}\n\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\n\nconst navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\";\n\n// Mute warnings for calls to useNavigate in SSR environments\nfunction useIsomorphicLayoutEffect(cb) {\n  let isStatic = React.useContext(NavigationContext).static;\n  if (!isStatic) {\n    // We should be able to get rid of this once react 18.3 is released\n    // See: https://github.com/facebook/react/pull/26395\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(cb);\n  }\n}\n\n/**\n * Returns an imperative method for changing the location. Used by `<Link>`s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/v6/hooks/use-navigate\n */\nfunction useNavigate() {\n  let {\n    isDataRoute\n  } = React.useContext(RouteContext);\n  // Conditional usage is OK here because the usage of a data router is static\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useNavigate() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  let dataRouterContext = React.useContext(DataRouterContext);\n  let {\n    basename,\n    future,\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify(UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath));\n  let activeRef = React.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React.useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(activeRef.current, navigateEffectWarning) : void 0;\n\n    // Short circuit here since if this happens on first render the navigate\n    // is useless because we haven't wired up our history listener yet\n    if (!activeRef.current) return;\n    if (typeof to === \"number\") {\n      navigator.go(to);\n      return;\n    }\n    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to handing off to history (but only if we're not in a data router,\n    // otherwise it'll prepend the basename inside of the router).\n    // If this is a root navigation, then we navigate to the raw basename\n    // which allows the basename to have full control over the presence of a\n    // trailing slash on root links\n    if (dataRouterContext == null && basename !== \"/\") {\n      path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n    }\n    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n  }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);\n  return navigate;\n}\nconst OutletContext = /*#__PURE__*/React.createContext(null);\n\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/v6/hooks/use-outlet-context\n */\nfunction useOutletContext() {\n  return React.useContext(OutletContext);\n}\n\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by `<Outlet>` to render child routes.\n *\n * @see https://reactrouter.com/v6/hooks/use-outlet\n */\nfunction useOutlet(context) {\n  let outlet = React.useContext(RouteContext).outlet;\n  if (outlet) {\n    return /*#__PURE__*/React.createElement(OutletContext.Provider, {\n      value: context\n    }, outlet);\n  }\n  return outlet;\n}\n\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/v6/hooks/use-params\n */\nfunction useParams() {\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? routeMatch.params : {};\n}\n\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/v6/hooks/use-resolved-path\n */\nfunction useResolvedPath(to, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    future\n  } = React.useContext(NavigationContext);\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify(UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath));\n  return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [to, routePathnamesJson, locationPathname, relative]);\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an `<Outlet>` to render their child route's\n * element.\n *\n * @see https://reactrouter.com/v6/hooks/use-routes\n */\nfunction useRoutes(routes, locationArg) {\n  return useRoutesImpl(routes, locationArg);\n}\n\n// Internal implementation with accept optional param for RouterProvider usage\nfunction useRoutesImpl(routes, locationArg, dataRouterState, future) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useRoutes() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  let {\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    matches: parentMatches\n  } = React.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n  if (process.env.NODE_ENV !== \"production\") {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    let parentPath = parentRoute && parentRoute.path || \"\";\n    warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + \"\\\">.\"));\n  }\n  let locationFromContext = useLocation();\n  let location;\n  if (locationArg) {\n    var _parsedLocationArg$pa;\n    let parsedLocationArg = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + (\"matched by all parent routes. The current pathname base is \\\"\" + parentPathnameBase + \"\\\" \") + (\"but pathname \\\"\" + parsedLocationArg.pathname + \"\\\" was given in the `location` prop.\")) : UNSAFE_invariant(false) : void 0;\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n  let pathname = location.pathname || \"/\";\n  let remainingPathname = pathname;\n  if (parentPathnameBase !== \"/\") {\n    // Determine the remaining pathname by removing the # of URL segments the\n    // parentPathnameBase has, instead of removing based on character count.\n    // This is because we can't guarantee that incoming/outgoing encodings/\n    // decodings will match exactly.\n    // We decode paths before matching on a per-segment basis with\n    // decodeURIComponent(), but we re-encode pathnames via `new URL()` so they\n    // match what `window.location.pathname` would reflect.  Those don't 100%\n    // align when it comes to encoded URI characters such as % and &.\n    //\n    // So we may end up with:\n    //   pathname:           \"/descendant/a%25b/match\"\n    //   parentPathnameBase: \"/descendant/a%b\"\n    //\n    // And the direct substring removal approach won't work :/\n    let parentSegments = parentPathnameBase.replace(/^\\//, \"\").split(\"/\");\n    let segments = pathname.replace(/^\\//, \"\").split(\"/\");\n    remainingPathname = \"/\" + segments.slice(parentSegments.length).join(\"/\");\n  }\n  let matches = matchRoutes(routes, {\n    pathname: remainingPathname\n  });\n  if (process.env.NODE_ENV !== \"production\") {\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(parentRoute || matches != null, \"No routes matched location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \") : void 0;\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(matches == null || matches[matches.length - 1].route.element !== undefined || matches[matches.length - 1].route.Component !== undefined || matches[matches.length - 1].route.lazy !== undefined, \"Matched leaf route at location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \" + \"does not have an element or Component. This means it will render an <Outlet /> with a \" + \"null value by default resulting in an \\\"empty\\\" page.\") : void 0;\n  }\n  let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {\n    params: Object.assign({}, parentParams, match.params),\n    pathname: joinPaths([parentPathnameBase,\n    // Re-encode pathnames that were decoded inside matchRoutes\n    navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),\n    pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : joinPaths([parentPathnameBase,\n    // Re-encode pathnames that were decoded inside matchRoutes\n    navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])\n  })), parentMatches, dataRouterState, future);\n\n  // When a user passes in a `locationArg`, the associated routes need to\n  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n  // to use the scoped location instead of the global location.\n  if (locationArg && renderedMatches) {\n    return /*#__PURE__*/React.createElement(LocationContext.Provider, {\n      value: {\n        location: _extends({\n          pathname: \"/\",\n          search: \"\",\n          hash: \"\",\n          state: null,\n          key: \"default\"\n        }, location),\n        navigationType: Action.Pop\n      }\n    }, renderedMatches);\n  }\n  return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n  let error = useRouteError();\n  let message = isRouteErrorResponse(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n  let stack = error instanceof Error ? error.stack : null;\n  let lightgrey = \"rgba(200,200,200, 0.5)\";\n  let preStyles = {\n    padding: \"0.5rem\",\n    backgroundColor: lightgrey\n  };\n  let codeStyles = {\n    padding: \"2px 4px\",\n    backgroundColor: lightgrey\n  };\n  let devInfo = null;\n  if (process.env.NODE_ENV !== \"production\") {\n    console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n    devInfo = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/React.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /*#__PURE__*/React.createElement(\"code\", {\n      style: codeStyles\n    }, \"ErrorBoundary\"), \" or\", \" \", /*#__PURE__*/React.createElement(\"code\", {\n      style: codeStyles\n    }, \"errorElement\"), \" prop on your route.\"));\n  }\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"h2\", null, \"Unexpected Application Error!\"), /*#__PURE__*/React.createElement(\"h3\", {\n    style: {\n      fontStyle: \"italic\"\n    }\n  }, message), stack ? /*#__PURE__*/React.createElement(\"pre\", {\n    style: preStyles\n  }, stack) : null, devInfo);\n}\nconst defaultErrorElement = /*#__PURE__*/React.createElement(DefaultErrorComponent, null);\nclass RenderErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      location: props.location,\n      revalidation: props.revalidation,\n      error: props.error\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error: error\n    };\n  }\n  static getDerivedStateFromProps(props, state) {\n    // When we get into an error state, the user will likely click \"back\" to the\n    // previous page that didn't have an error. Because this wraps the entire\n    // application, that will have no effect--the error page continues to display.\n    // This gives us a mechanism to recover from the error when the location changes.\n    //\n    // Whether we're in an error state or not, we update the location in state\n    // so that when we are in an error state, it gets reset when a new location\n    // comes in and the user recovers from the error.\n    if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n      return {\n        error: props.error,\n        location: props.location,\n        revalidation: props.revalidation\n      };\n    }\n\n    // If we're not changing locations, preserve the location but still surface\n    // any new errors that may come through. We retain the existing error, we do\n    // this because the error provided from the app state may be cleared without\n    // the location changing.\n    return {\n      error: props.error !== undefined ? props.error : state.error,\n      location: state.location,\n      revalidation: props.revalidation || state.revalidation\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\"React Router caught the following error during render\", error, errorInfo);\n  }\n  render() {\n    return this.state.error !== undefined ? /*#__PURE__*/React.createElement(RouteContext.Provider, {\n      value: this.props.routeContext\n    }, /*#__PURE__*/React.createElement(RouteErrorContext.Provider, {\n      value: this.state.error,\n      children: this.props.component\n    })) : this.props.children;\n  }\n}\nfunction RenderedRoute(_ref) {\n  let {\n    routeContext,\n    match,\n    children\n  } = _ref;\n  let dataRouterContext = React.useContext(DataRouterContext);\n\n  // Track how deep we got in our render pass to emulate SSR componentDidCatch\n  // in a DataStaticRouter\n  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n  }\n  return /*#__PURE__*/React.createElement(RouteContext.Provider, {\n    value: routeContext\n  }, children);\n}\nfunction _renderMatches(matches, parentMatches, dataRouterState, future) {\n  var _dataRouterState;\n  if (parentMatches === void 0) {\n    parentMatches = [];\n  }\n  if (dataRouterState === void 0) {\n    dataRouterState = null;\n  }\n  if (future === void 0) {\n    future = null;\n  }\n  if (matches == null) {\n    var _future;\n    if (!dataRouterState) {\n      return null;\n    }\n    if (dataRouterState.errors) {\n      // Don't bail if we have data router errors so we can render them in the\n      // boundary.  Use the pre-matched (or shimmed) matches\n      matches = dataRouterState.matches;\n    } else if ((_future = future) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {\n      // Don't bail if we're initializing with partial hydration and we have\n      // router matches.  That means we're actively running `patchRoutesOnNavigation`\n      // so we should render down the partial matches to the appropriate\n      // `HydrateFallback`.  We only do this if `parentMatches` is empty so it\n      // only impacts the root matches for `RouterProvider` and no descendant\n      // `<Routes>`\n      matches = dataRouterState.matches;\n    } else {\n      return null;\n    }\n  }\n  let renderedMatches = matches;\n\n  // If we have data errors, trim matches to the highest error boundary\n  let errors = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;\n  if (errors != null) {\n    let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== undefined);\n    !(errorIndex >= 0) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\")) : UNSAFE_invariant(false) : void 0;\n    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n  }\n\n  // If we're in a partial hydration mode, detect if we need to render down to\n  // a given HydrateFallback while we load the rest of the hydration data\n  let renderFallback = false;\n  let fallbackIndex = -1;\n  if (dataRouterState && future && future.v7_partialHydration) {\n    for (let i = 0; i < renderedMatches.length; i++) {\n      let match = renderedMatches[i];\n      // Track the deepest fallback up until the first route without data\n      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\n        fallbackIndex = i;\n      }\n      if (match.route.id) {\n        let {\n          loaderData,\n          errors\n        } = dataRouterState;\n        let needsToRunLoader = match.route.loader && loaderData[match.route.id] === undefined && (!errors || errors[match.route.id] === undefined);\n        if (match.route.lazy || needsToRunLoader) {\n          // We found the first route that's not ready to render (waiting on\n          // lazy, or has a loader that hasn't run yet).  Flag that we need to\n          // render a fallback and render up until the appropriate fallback\n          renderFallback = true;\n          if (fallbackIndex >= 0) {\n            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\n          } else {\n            renderedMatches = [renderedMatches[0]];\n          }\n          break;\n        }\n      }\n    }\n  }\n  return renderedMatches.reduceRight((outlet, match, index) => {\n    // Only data routers handle errors/fallbacks\n    let error;\n    let shouldRenderHydrateFallback = false;\n    let errorElement = null;\n    let hydrateFallbackElement = null;\n    if (dataRouterState) {\n      error = errors && match.route.id ? errors[match.route.id] : undefined;\n      errorElement = match.route.errorElement || defaultErrorElement;\n      if (renderFallback) {\n        if (fallbackIndex < 0 && index === 0) {\n          warningOnce(\"route-fallback\", false, \"No `HydrateFallback` element provided to render during initial hydration\");\n          shouldRenderHydrateFallback = true;\n          hydrateFallbackElement = null;\n        } else if (fallbackIndex === index) {\n          shouldRenderHydrateFallback = true;\n          hydrateFallbackElement = match.route.hydrateFallbackElement || null;\n        }\n      }\n    }\n    let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n    let getChildren = () => {\n      let children;\n      if (error) {\n        children = errorElement;\n      } else if (shouldRenderHydrateFallback) {\n        children = hydrateFallbackElement;\n      } else if (match.route.Component) {\n        // Note: This is a de-optimized path since React won't re-use the\n        // ReactElement since it's identity changes with each new\n        // React.createElement call.  We keep this so folks can use\n        // `<Route Component={...}>` in `<Routes>` but generally `Component`\n        // usage is only advised in `RouterProvider` when we can convert it to\n        // `element` ahead of time.\n        children = /*#__PURE__*/React.createElement(match.route.Component, null);\n      } else if (match.route.element) {\n        children = match.route.element;\n      } else {\n        children = outlet;\n      }\n      return /*#__PURE__*/React.createElement(RenderedRoute, {\n        match: match,\n        routeContext: {\n          outlet,\n          matches,\n          isDataRoute: dataRouterState != null\n        },\n        children: children\n      });\n    };\n    // Only wrap in an error boundary within data router usages when we have an\n    // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n    // an ancestor ErrorBoundary/errorElement\n    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/React.createElement(RenderErrorBoundary, {\n      location: dataRouterState.location,\n      revalidation: dataRouterState.revalidation,\n      component: errorElement,\n      error: error,\n      children: getChildren(),\n      routeContext: {\n        outlet: null,\n        matches,\n        isDataRoute: true\n      }\n    }) : getChildren();\n  }, null);\n}\nvar DataRouterHook = /*#__PURE__*/function (DataRouterHook) {\n  DataRouterHook[\"UseBlocker\"] = \"useBlocker\";\n  DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\n  DataRouterHook[\"UseNavigateStable\"] = \"useNavigate\";\n  return DataRouterHook;\n}(DataRouterHook || {});\nvar DataRouterStateHook = /*#__PURE__*/function (DataRouterStateHook) {\n  DataRouterStateHook[\"UseBlocker\"] = \"useBlocker\";\n  DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\n  DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\n  DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\n  DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\n  DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n  DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\n  DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\n  DataRouterStateHook[\"UseNavigateStable\"] = \"useNavigate\";\n  DataRouterStateHook[\"UseRouteId\"] = \"useRouteId\";\n  return DataRouterStateHook;\n}(DataRouterStateHook || {});\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = React.useContext(DataRouterContext);\n  !ctx ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = React.useContext(DataRouterStateContext);\n  !state ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return state;\n}\nfunction useRouteContext(hookName) {\n  let route = React.useContext(RouteContext);\n  !route ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return route;\n}\n\n// Internal version with hookName-aware debugging\nfunction useCurrentRouteId(hookName) {\n  let route = useRouteContext(hookName);\n  let thisRoute = route.matches[route.matches.length - 1];\n  !thisRoute.route.id ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, hookName + \" can only be used on routes that contain a unique \\\"id\\\"\") : UNSAFE_invariant(false) : void 0;\n  return thisRoute.route.id;\n}\n\n/**\n * Returns the ID for the nearest contextual route\n */\nfunction useRouteId() {\n  return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n}\n\n/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */\nfunction useNavigation() {\n  let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n  return state.navigation;\n}\n\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */\nfunction useRevalidator() {\n  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n  return React.useMemo(() => ({\n    revalidate: dataRouterContext.router.revalidate,\n    state: state.revalidation\n  }), [dataRouterContext.router.revalidate, state.revalidation]);\n}\n\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */\nfunction useMatches() {\n  let {\n    matches,\n    loaderData\n  } = useDataRouterState(DataRouterStateHook.UseMatches);\n  return React.useMemo(() => matches.map(m => UNSAFE_convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);\n}\n\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */\nfunction useLoaderData() {\n  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n  if (state.errors && state.errors[routeId] != null) {\n    console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n    return undefined;\n  }\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the loaderData for the given routeId\n */\nfunction useRouteLoaderData(routeId) {\n  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the action data for the nearest ancestor Route action\n */\nfunction useActionData() {\n  let state = useDataRouterState(DataRouterStateHook.UseActionData);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n  return state.actionData ? state.actionData[routeId] : undefined;\n}\n\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * ErrorBoundary/errorElement to display a proper error message.\n */\nfunction useRouteError() {\n  var _state$errors;\n  let error = React.useContext(RouteErrorContext);\n  let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n\n  // If this was a render error, we put it in a RouteError context inside\n  // of RenderErrorBoundary\n  if (error !== undefined) {\n    return error;\n  }\n\n  // Otherwise look for errors from our data router state\n  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n}\n\n/**\n * Returns the happy-path data from the nearest ancestor `<Await />` value\n */\nfunction useAsyncValue() {\n  let value = React.useContext(AwaitContext);\n  return value == null ? void 0 : value._data;\n}\n\n/**\n * Returns the error from the nearest ancestor `<Await />` value\n */\nfunction useAsyncError() {\n  let value = React.useContext(AwaitContext);\n  return value == null ? void 0 : value._error;\n}\nlet blockerId = 0;\n\n/**\n * Allow the application to block navigations within the SPA and present the\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n * using half-filled form data.  This does not handle hard-reloads or\n * cross-origin navigations.\n */\nfunction useBlocker(shouldBlock) {\n  let {\n    router,\n    basename\n  } = useDataRouterContext(DataRouterHook.UseBlocker);\n  let state = useDataRouterState(DataRouterStateHook.UseBlocker);\n  let [blockerKey, setBlockerKey] = React.useState(\"\");\n  let blockerFunction = React.useCallback(arg => {\n    if (typeof shouldBlock !== \"function\") {\n      return !!shouldBlock;\n    }\n    if (basename === \"/\") {\n      return shouldBlock(arg);\n    }\n\n    // If they provided us a function and we've got an active basename, strip\n    // it from the locations we expose to the user to match the behavior of\n    // useLocation\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = arg;\n    return shouldBlock({\n      currentLocation: _extends({}, currentLocation, {\n        pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\n      }),\n      nextLocation: _extends({}, nextLocation, {\n        pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\n      }),\n      historyAction\n    });\n  }, [basename, shouldBlock]);\n\n  // This effect is in charge of blocker key assignment and deletion (which is\n  // tightly coupled to the key)\n  React.useEffect(() => {\n    let key = String(++blockerId);\n    setBlockerKey(key);\n    return () => router.deleteBlocker(key);\n  }, [router]);\n\n  // This effect handles assigning the blockerFunction.  This is to handle\n  // unstable blocker function identities, and happens only after the prior\n  // effect so we don't get an orphaned blockerFunction in the router with a\n  // key of \"\".  Until then we just have the IDLE_BLOCKER.\n  React.useEffect(() => {\n    if (blockerKey !== \"\") {\n      router.getBlocker(blockerKey, blockerFunction);\n    }\n  }, [router, blockerKey, blockerFunction]);\n\n  // Prefer the blocker from `state` not `router.state` since DataRouterContext\n  // is memoized so this ensures we update on blocker state updates\n  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;\n}\n\n/**\n * Stable version of useNavigate that is used when we are in the context of\n * a RouterProvider.\n */\nfunction useNavigateStable() {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseNavigateStable);\n  let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n  let activeRef = React.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React.useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(activeRef.current, navigateEffectWarning) : void 0;\n\n    // Short circuit here since if this happens on first render the navigate\n    // is useless because we haven't wired up our router subscriber yet\n    if (!activeRef.current) return;\n    if (typeof to === \"number\") {\n      router.navigate(to);\n    } else {\n      router.navigate(to, _extends({\n        fromRouteId: id\n      }, options));\n    }\n  }, [router, id]);\n  return navigate;\n}\nconst alreadyWarned$1 = {};\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned$1[key]) {\n    alreadyWarned$1[key] = true;\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, message) : void 0;\n  }\n}\n\nconst alreadyWarned = {};\nfunction warnOnce(key, message) {\n  if (process.env.NODE_ENV !== \"production\" && !alreadyWarned[message]) {\n    alreadyWarned[message] = true;\n    console.warn(message);\n  }\n}\nconst logDeprecation = (flag, msg, link) => warnOnce(flag, \"\\u26A0\\uFE0F React Router Future Flag Warning: \" + msg + \". \" + (\"You can use the `\" + flag + \"` future flag to opt-in early. \") + (\"For more information, see \" + link + \".\"));\nfunction logV6DeprecationWarnings(renderFuture, routerFuture) {\n  if ((renderFuture == null ? void 0 : renderFuture.v7_startTransition) === undefined) {\n    logDeprecation(\"v7_startTransition\", \"React Router will begin wrapping state updates in `React.startTransition` in v7\", \"https://reactrouter.com/v6/upgrading/future#v7_starttransition\");\n  }\n  if ((renderFuture == null ? void 0 : renderFuture.v7_relativeSplatPath) === undefined && (!routerFuture || routerFuture.v7_relativeSplatPath === undefined)) {\n    logDeprecation(\"v7_relativeSplatPath\", \"Relative route resolution within Splat routes is changing in v7\", \"https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath\");\n  }\n  if (routerFuture) {\n    if (routerFuture.v7_fetcherPersist === undefined) {\n      logDeprecation(\"v7_fetcherPersist\", \"The persistence behavior of fetchers is changing in v7\", \"https://reactrouter.com/v6/upgrading/future#v7_fetcherpersist\");\n    }\n    if (routerFuture.v7_normalizeFormMethod === undefined) {\n      logDeprecation(\"v7_normalizeFormMethod\", \"Casing of `formMethod` fields is being normalized to uppercase in v7\", \"https://reactrouter.com/v6/upgrading/future#v7_normalizeformmethod\");\n    }\n    if (routerFuture.v7_partialHydration === undefined) {\n      logDeprecation(\"v7_partialHydration\", \"`RouterProvider` hydration behavior is changing in v7\", \"https://reactrouter.com/v6/upgrading/future#v7_partialhydration\");\n    }\n    if (routerFuture.v7_skipActionErrorRevalidation === undefined) {\n      logDeprecation(\"v7_skipActionErrorRevalidation\", \"The revalidation behavior after 4xx/5xx `action` responses is changing in v7\", \"https://reactrouter.com/v6/upgrading/future#v7_skipactionerrorrevalidation\");\n    }\n  }\n}\n\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nconst START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = React[START_TRANSITION];\n\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nfunction RouterProvider(_ref) {\n  let {\n    fallbackElement,\n    router,\n    future\n  } = _ref;\n  let [state, setStateImpl] = React.useState(router.state);\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    if (v7_startTransition && startTransitionImpl) {\n      startTransitionImpl(() => setStateImpl(newState));\n    } else {\n      setStateImpl(newState);\n    }\n  }, [setStateImpl, v7_startTransition]);\n\n  // Need to use a layout effect here so we are subscribed early enough to\n  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n  React.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n  React.useEffect(() => {\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(fallbackElement == null || !router.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using \" + \"`v7_partialHydration`, use a `HydrateFallback` component instead\") : void 0;\n    // Only log this once on initial mount\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  let navigator = React.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: n => router.navigate(n),\n      push: (to, state, opts) => router.navigate(to, {\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      }),\n      replace: (to, state, opts) => router.navigate(to, {\n        replace: true,\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || \"/\";\n  let dataRouterContext = React.useMemo(() => ({\n    router,\n    navigator,\n    static: false,\n    basename\n  }), [router, navigator, basename]);\n  React.useEffect(() => logV6DeprecationWarnings(future, router.future), [router, future]);\n\n  // The fragment and {null} here are important!  We need them to keep React 18's\n  // useId happy when we are server-rendering since we may have a <script> here\n  // containing the hydrated server-side staticContext (from StaticRouterProvider).\n  // useId relies on the component tree structure to generate deterministic id's\n  // so we need to ensure it remains the same on the client even though\n  // we don't need the <script> tag\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, /*#__PURE__*/React.createElement(DataRouterStateContext.Provider, {\n    value: state\n  }, /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator: navigator,\n    future: {\n      v7_relativeSplatPath: router.future.v7_relativeSplatPath\n    }\n  }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/React.createElement(DataRoutes, {\n    routes: router.routes,\n    future: router.future,\n    state: state\n  }) : fallbackElement))), null);\n}\nfunction DataRoutes(_ref2) {\n  let {\n    routes,\n    future,\n    state\n  } = _ref2;\n  return useRoutesImpl(routes, undefined, state, future);\n}\n/**\n * A `<Router>` that stores all entries in memory.\n *\n * @see https://reactrouter.com/v6/router-components/memory-router\n */\nfunction MemoryRouter(_ref3) {\n  let {\n    basename,\n    children,\n    initialEntries,\n    initialIndex,\n    future\n  } = _ref3;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries,\n      initialIndex,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  React.useEffect(() => logV6DeprecationWarnings(future), [future]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future: future\n  });\n}\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/v6/components/navigate\n */\nfunction Navigate(_ref4) {\n  let {\n    to,\n    replace,\n    state,\n    relative\n  } = _ref4;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of\n  // the router loaded. We can help them understand how to avoid that.\n  \"<Navigate> may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  let {\n    future,\n    static: isStatic\n  } = React.useContext(NavigationContext);\n  process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(!isStatic, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : void 0;\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let navigate = useNavigate();\n\n  // Resolve the path outside of the effect so that when effects run twice in\n  // StrictMode they navigate to the same place\n  let path = resolveTo(to, UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath), locationPathname, relative === \"path\");\n  let jsonPath = JSON.stringify(path);\n  React.useEffect(() => navigate(JSON.parse(jsonPath), {\n    replace,\n    state,\n    relative\n  }), [navigate, jsonPath, relative, replace, state]);\n  return null;\n}\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/v6/components/outlet\n */\nfunction Outlet(props) {\n  return useOutlet(props.context);\n}\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/v6/components/route\n */\nfunction Route(_props) {\n  process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : UNSAFE_invariant(false) ;\n}\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a `<Router>` directly. Instead, you'll render a\n * router that is more specific to your environment such as a `<BrowserRouter>`\n * in web browsers or a `<StaticRouter>` for server rendering.\n *\n * @see https://reactrouter.com/v6/router-components/router\n */\nfunction Router(_ref5) {\n  let {\n    basename: basenameProp = \"/\",\n    children = null,\n    location: locationProp,\n    navigationType = Action.Pop,\n    navigator,\n    static: staticProp = false,\n    future\n  } = _ref5;\n  !!useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\") : UNSAFE_invariant(false) : void 0;\n\n  // Preserve trailing slashes on basename, so we can let the user control\n  // the enforcement of trailing slashes throughout the app\n  let basename = basenameProp.replace(/^\\/*/, \"/\");\n  let navigationContext = React.useMemo(() => ({\n    basename,\n    navigator,\n    static: staticProp,\n    future: _extends({\n      v7_relativeSplatPath: false\n    }, future)\n  }), [basename, future, navigator, staticProp]);\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\"\n  } = locationProp;\n  let locationContext = React.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n    if (trailingPathname == null) {\n      return null;\n    }\n    return {\n      location: {\n        pathname: trailingPathname,\n        search,\n        hash,\n        state,\n        key\n      },\n      navigationType\n    };\n  }, [basename, pathname, search, hash, state, key, navigationType]);\n  process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(locationContext != null, \"<Router basename=\\\"\" + basename + \"\\\"> is not able to match the URL \" + (\"\\\"\" + pathname + search + hash + \"\\\" because it does not start with the \") + \"basename, so the <Router> won't render anything.\") : void 0;\n  if (locationContext == null) {\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(NavigationContext.Provider, {\n    value: navigationContext\n  }, /*#__PURE__*/React.createElement(LocationContext.Provider, {\n    children: children,\n    value: locationContext\n  }));\n}\n/**\n * A container for a nested tree of `<Route>` elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/v6/components/routes\n */\nfunction Routes(_ref6) {\n  let {\n    children,\n    location\n  } = _ref6;\n  return useRoutes(createRoutesFromChildren(children), location);\n}\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */\nfunction Await(_ref7) {\n  let {\n    children,\n    errorElement,\n    resolve\n  } = _ref7;\n  return /*#__PURE__*/React.createElement(AwaitErrorBoundary, {\n    resolve: resolve,\n    errorElement: errorElement\n  }, /*#__PURE__*/React.createElement(ResolveAwait, null, children));\n}\nvar AwaitRenderStatus = /*#__PURE__*/function (AwaitRenderStatus) {\n  AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\n  AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\n  AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\n  return AwaitRenderStatus;\n}(AwaitRenderStatus || {});\nconst neverSettledPromise = new Promise(() => {});\nclass AwaitErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: null\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\"<Await> caught the following error during render\", error, errorInfo);\n  }\n  render() {\n    let {\n      children,\n      errorElement,\n      resolve\n    } = this.props;\n    let promise = null;\n    let status = AwaitRenderStatus.pending;\n    if (!(resolve instanceof Promise)) {\n      // Didn't get a promise - provide as a resolved promise\n      status = AwaitRenderStatus.success;\n      promise = Promise.resolve();\n      Object.defineProperty(promise, \"_tracked\", {\n        get: () => true\n      });\n      Object.defineProperty(promise, \"_data\", {\n        get: () => resolve\n      });\n    } else if (this.state.error) {\n      // Caught a render error, provide it as a rejected promise\n      status = AwaitRenderStatus.error;\n      let renderError = this.state.error;\n      promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings\n      Object.defineProperty(promise, \"_tracked\", {\n        get: () => true\n      });\n      Object.defineProperty(promise, \"_error\", {\n        get: () => renderError\n      });\n    } else if (resolve._tracked) {\n      // Already tracked promise - check contents\n      promise = resolve;\n      status = \"_error\" in promise ? AwaitRenderStatus.error : \"_data\" in promise ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n    } else {\n      // Raw (untracked) promise - track it\n      status = AwaitRenderStatus.pending;\n      Object.defineProperty(resolve, \"_tracked\", {\n        get: () => true\n      });\n      promise = resolve.then(data => Object.defineProperty(resolve, \"_data\", {\n        get: () => data\n      }), error => Object.defineProperty(resolve, \"_error\", {\n        get: () => error\n      }));\n    }\n    if (status === AwaitRenderStatus.error && promise._error instanceof AbortedDeferredError) {\n      // Freeze the UI by throwing a never resolved promise\n      throw neverSettledPromise;\n    }\n    if (status === AwaitRenderStatus.error && !errorElement) {\n      // No errorElement, throw to the nearest route-level error boundary\n      throw promise._error;\n    }\n    if (status === AwaitRenderStatus.error) {\n      // Render via our errorElement\n      return /*#__PURE__*/React.createElement(AwaitContext.Provider, {\n        value: promise,\n        children: errorElement\n      });\n    }\n    if (status === AwaitRenderStatus.success) {\n      // Render children with resolved value\n      return /*#__PURE__*/React.createElement(AwaitContext.Provider, {\n        value: promise,\n        children: children\n      });\n    }\n\n    // Throw to the suspense boundary\n    throw promise;\n  }\n}\n\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on `<Await>`\n */\nfunction ResolveAwait(_ref8) {\n  let {\n    children\n  } = _ref8;\n  let data = useAsyncValue();\n  let toRender = typeof children === \"function\" ? children(data) : children;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, toRender);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/v6/utils/create-routes-from-children\n */\nfunction createRoutesFromChildren(children, parentPath) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  let routes = [];\n  React.Children.forEach(children, (element, index) => {\n    if (! /*#__PURE__*/React.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n    let treePath = [...parentPath, index];\n    if (element.type === React.Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n      return;\n    }\n    !(element.type === Route) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : UNSAFE_invariant(false) : void 0;\n    !(!element.props.index || !element.props.children) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"An index route cannot have child routes.\") : UNSAFE_invariant(false) : void 0;\n    let route = {\n      id: element.props.id || treePath.join(\"-\"),\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      Component: element.props.Component,\n      index: element.props.index,\n      path: element.props.path,\n      loader: element.props.loader,\n      action: element.props.action,\n      errorElement: element.props.errorElement,\n      ErrorBoundary: element.props.ErrorBoundary,\n      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n      shouldRevalidate: element.props.shouldRevalidate,\n      handle: element.props.handle,\n      lazy: element.props.lazy\n    };\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children, treePath);\n    }\n    routes.push(route);\n  });\n  return routes;\n}\n\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\nfunction renderMatches(matches) {\n  return _renderMatches(matches);\n}\n\nfunction mapRouteProperties(route) {\n  let updates = {\n    // Note: this check also occurs in createRoutesFromChildren so update\n    // there if you change this -- please and thank you!\n    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n  };\n  if (route.Component) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (route.element) {\n        process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"You should not include both `Component` and `element` on your route - \" + \"`Component` will be used.\") : void 0;\n      }\n    }\n    Object.assign(updates, {\n      element: /*#__PURE__*/React.createElement(route.Component),\n      Component: undefined\n    });\n  }\n  if (route.HydrateFallback) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (route.hydrateFallbackElement) {\n        process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - \" + \"`HydrateFallback` will be used.\") : void 0;\n      }\n    }\n    Object.assign(updates, {\n      hydrateFallbackElement: /*#__PURE__*/React.createElement(route.HydrateFallback),\n      HydrateFallback: undefined\n    });\n  }\n  if (route.ErrorBoundary) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (route.errorElement) {\n        process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - \" + \"`ErrorBoundary` will be used.\") : void 0;\n      }\n    }\n    Object.assign(updates, {\n      errorElement: /*#__PURE__*/React.createElement(route.ErrorBoundary),\n      ErrorBoundary: undefined\n    });\n  }\n  return updates;\n}\nfunction createMemoryRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createMemoryHistory({\n      initialEntries: opts == null ? void 0 : opts.initialEntries,\n      initialIndex: opts == null ? void 0 : opts.initialIndex\n    }),\n    hydrationData: opts == null ? void 0 : opts.hydrationData,\n    routes,\n    mapRouteProperties,\n    dataStrategy: opts == null ? void 0 : opts.dataStrategy,\n    patchRoutesOnNavigation: opts == null ? void 0 : opts.patchRoutesOnNavigation\n  }).initialize();\n}\n\nexport { Await, MemoryRouter, Navigate, Outlet, Route, Router, RouterProvider, Routes, DataRouterContext as UNSAFE_DataRouterContext, DataRouterStateContext as UNSAFE_DataRouterStateContext, LocationContext as UNSAFE_LocationContext, NavigationContext as UNSAFE_NavigationContext, RouteContext as UNSAFE_RouteContext, logV6DeprecationWarnings as UNSAFE_logV6DeprecationWarnings, mapRouteProperties as UNSAFE_mapRouteProperties, useRouteId as UNSAFE_useRouteId, useRoutesImpl as UNSAFE_useRoutesImpl, createMemoryRouter, createRoutesFromChildren, createRoutesFromChildren as createRoutesFromElements, renderMatches, useActionData, useAsyncError, useAsyncValue, useBlocker, useHref, useInRouterContext, useLoaderData, useLocation, useMatch, useMatches, useNavigate, useNavigation, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRevalidator, useRouteError, useRouteLoaderData, useRoutes };\n//# sourceMappingURL=index.js.map\n","/**\n * React Router DOM v6.30.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { UNSAFE_mapRouteProperties, UNSAFE_logV6DeprecationWarnings, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, Router, UNSAFE_useRoutesImpl, UNSAFE_NavigationContext, useHref, useResolvedPath, useLocation, useNavigate, createPath, UNSAFE_useRouteId, UNSAFE_RouteContext, useMatches, useNavigation, useBlocker } from 'react-router';\nexport { AbortedDeferredError, Await, MemoryRouter, Navigate, NavigationType, Outlet, Route, Router, Routes, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, UNSAFE_LocationContext, UNSAFE_NavigationContext, UNSAFE_RouteContext, UNSAFE_useRouteId, createMemoryRouter, createPath, createRoutesFromChildren, createRoutesFromElements, defer, generatePath, isRouteErrorResponse, json, matchPath, matchRoutes, parsePath, redirect, redirectDocument, renderMatches, replace, resolvePath, useActionData, useAsyncError, useAsyncValue, useBlocker, useHref, useInRouterContext, useLoaderData, useLocation, useMatch, useMatches, useNavigate, useNavigation, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRevalidator, useRouteError, useRouteLoaderData, useRoutes } from 'react-router';\nimport { stripBasename, UNSAFE_warning, createRouter, createBrowserHistory, createHashHistory, UNSAFE_ErrorResponseImpl, UNSAFE_invariant, joinPaths, IDLE_FETCHER, matchPath } from '@remix-run/router';\nexport { UNSAFE_ErrorResponseImpl } from '@remix-run/router';\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nconst defaultMethod = \"get\";\nconst defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n  return event.button === 0 && (\n  // Ignore everything but left clicks\n  !target || target === \"_self\") &&\n  // Let browser handle \"target=_blank\" etc.\n  !isModifiedEvent(event) // Ignore clicks with modifier keys\n  ;\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */\nfunction createSearchParams(init) {\n  if (init === void 0) {\n    init = \"\";\n  }\n  return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {\n    let value = init[key];\n    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);\n  }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n  let searchParams = createSearchParams(locationSearch);\n  if (defaultSearchParams) {\n    // Use `defaultSearchParams.forEach(...)` here instead of iterating of\n    // `defaultSearchParams.keys()` to work-around a bug in Firefox related to\n    // web extensions. Relevant Bugzilla tickets:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984\n    defaultSearchParams.forEach((_, key) => {\n      if (!searchParams.has(key)) {\n        defaultSearchParams.getAll(key).forEach(value => {\n          searchParams.append(key, value);\n        });\n      }\n    });\n  }\n  return searchParams;\n}\n// One-time check for submitter support\nlet _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n  if (_formDataSupportsSubmitter === null) {\n    try {\n      new FormData(document.createElement(\"form\"),\n      // @ts-expect-error if FormData supports the submitter parameter, this will throw\n      0);\n      _formDataSupportsSubmitter = false;\n    } catch (e) {\n      _formDataSupportsSubmitter = true;\n    }\n  }\n  return _formDataSupportsSubmitter;\n}\nconst supportedFormEncTypes = new Set([\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"]);\nfunction getFormEncType(encType) {\n  if (encType != null && !supportedFormEncTypes.has(encType)) {\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"\\\"\" + encType + \"\\\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` \" + (\"and will default to \\\"\" + defaultEncType + \"\\\"\")) : void 0;\n    return null;\n  }\n  return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n  let method;\n  let action;\n  let encType;\n  let formData;\n  let body;\n  if (isFormElement(target)) {\n    // When grabbing the action from the element, it will have had the basename\n    // prefixed to ensure non-JS scenarios work, so strip it since we'll\n    // re-prefix in the router\n    let attr = target.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n    formData = new FormData(target);\n  } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n    let form = target.form;\n    if (form == null) {\n      throw new Error(\"Cannot submit a <button> or <input type=\\\"submit\\\"> without a <form>\");\n    }\n    // <button>/<input type=\"submit\"> may override attributes of <form>\n    // When grabbing the action from the element, it will have had the basename\n    // prefixed to ensure non-JS scenarios work, so strip it since we'll\n    // re-prefix in the router\n    let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n    // Build a FormData object populated from a form and submitter\n    formData = new FormData(form, target);\n    // If this browser doesn't support the `FormData(el, submitter)` format,\n    // then tack on the submitter value at the end.  This is a lightweight\n    // solution that is not 100% spec compliant.  For complete support in older\n    // browsers, consider using the `formdata-submitter-polyfill` package\n    if (!isFormDataSubmitterSupported()) {\n      let {\n        name,\n        type,\n        value\n      } = target;\n      if (type === \"image\") {\n        let prefix = name ? name + \".\" : \"\";\n        formData.append(prefix + \"x\", \"0\");\n        formData.append(prefix + \"y\", \"0\");\n      } else if (name) {\n        formData.append(name, value);\n      }\n    }\n  } else if (isHtmlElement(target)) {\n    throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + \"<input type=\\\"submit|image\\\">\");\n  } else {\n    method = defaultMethod;\n    action = null;\n    encType = defaultEncType;\n    body = target;\n  }\n  // Send body for <Form encType=\"text/plain\" so we encode it into text\n  if (formData && encType === \"text/plain\") {\n    body = formData;\n    formData = undefined;\n  }\n  return {\n    action,\n    method: method.toLowerCase(),\n    encType,\n    formData,\n    body\n  };\n}\n\nconst _excluded = [\"onClick\", \"relative\", \"reloadDocument\", \"replace\", \"state\", \"target\", \"to\", \"preventScrollReset\", \"viewTransition\"],\n  _excluded2 = [\"aria-current\", \"caseSensitive\", \"className\", \"end\", \"style\", \"to\", \"viewTransition\", \"children\"],\n  _excluded3 = [\"fetcherKey\", \"navigate\", \"reloadDocument\", \"replace\", \"state\", \"method\", \"action\", \"onSubmit\", \"relative\", \"preventScrollReset\", \"viewTransition\"];\n// HEY YOU! DON'T TOUCH THIS VARIABLE!\n//\n// It is replaced with the proper version at build time via a babel plugin in\n// the rollup config.\n//\n// Export a global property onto the window for React Router detection by the\n// Core Web Vitals Technology Report.  This way they can configure the `wappalyzer`\n// to detect and properly classify live websites as being built with React Router:\n// https://github.com/HTTPArchive/wappalyzer/blob/main/src/technologies/r.json\nconst REACT_ROUTER_VERSION = \"6\";\ntry {\n  window.__reactRouterVersion = REACT_ROUTER_VERSION;\n} catch (e) {\n  // no-op\n}\nfunction createBrowserRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createBrowserHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties: UNSAFE_mapRouteProperties,\n    dataStrategy: opts == null ? void 0 : opts.dataStrategy,\n    patchRoutesOnNavigation: opts == null ? void 0 : opts.patchRoutesOnNavigation,\n    window: opts == null ? void 0 : opts.window\n  }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createHashHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties: UNSAFE_mapRouteProperties,\n    dataStrategy: opts == null ? void 0 : opts.dataStrategy,\n    patchRoutesOnNavigation: opts == null ? void 0 : opts.patchRoutesOnNavigation,\n    window: opts == null ? void 0 : opts.window\n  }).initialize();\n}\nfunction parseHydrationData() {\n  var _window;\n  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n  if (state && state.errors) {\n    state = _extends({}, state, {\n      errors: deserializeErrors(state.errors)\n    });\n  }\n  return state;\n}\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // serializeErrors in react-router-dom/server.tsx :)\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n    } else if (val && val.__type === \"Error\") {\n      // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            // @ts-expect-error\n            let error = new ErrorConstructor(val.message);\n            // Wipe away the client-side stack trace.  Nothing to fill it in with\n            // because we don't serialize SSR stack traces for security reasons\n            error.stack = \"\";\n            serialized[key] = error;\n          } catch (e) {\n            // no-op - fall through and create a normal Error\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        // Wipe away the client-side stack trace.  Nothing to fill it in with\n        // because we don't serialize SSR stack traces for security reasons\n        error.stack = \"\";\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nconst ViewTransitionContext = /*#__PURE__*/React.createContext({\n  isTransitioning: false\n});\nif (process.env.NODE_ENV !== \"production\") {\n  ViewTransitionContext.displayName = \"ViewTransition\";\n}\nconst FetchersContext = /*#__PURE__*/React.createContext(new Map());\nif (process.env.NODE_ENV !== \"production\") {\n  FetchersContext.displayName = \"Fetchers\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nconst START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = React[START_TRANSITION];\nconst FLUSH_SYNC = \"flushSync\";\nconst flushSyncImpl = ReactDOM[FLUSH_SYNC];\nconst USE_ID = \"useId\";\nconst useIdImpl = React[USE_ID];\nfunction startTransitionSafe(cb) {\n  if (startTransitionImpl) {\n    startTransitionImpl(cb);\n  } else {\n    cb();\n  }\n}\nfunction flushSyncSafe(cb) {\n  if (flushSyncImpl) {\n    flushSyncImpl(cb);\n  } else {\n    cb();\n  }\n}\nclass Deferred {\n  constructor() {\n    this.status = \"pending\";\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = value => {\n        if (this.status === \"pending\") {\n          this.status = \"resolved\";\n          resolve(value);\n        }\n      };\n      this.reject = reason => {\n        if (this.status === \"pending\") {\n          this.status = \"rejected\";\n          reject(reason);\n        }\n      };\n    });\n  }\n}\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nfunction RouterProvider(_ref) {\n  let {\n    fallbackElement,\n    router,\n    future\n  } = _ref;\n  let [state, setStateImpl] = React.useState(router.state);\n  let [pendingState, setPendingState] = React.useState();\n  let [vtContext, setVtContext] = React.useState({\n    isTransitioning: false\n  });\n  let [renderDfd, setRenderDfd] = React.useState();\n  let [transition, setTransition] = React.useState();\n  let [interruption, setInterruption] = React.useState();\n  let fetcherData = React.useRef(new Map());\n  let {\n    v7_startTransition\n  } = future || {};\n  let optInStartTransition = React.useCallback(cb => {\n    if (v7_startTransition) {\n      startTransitionSafe(cb);\n    } else {\n      cb();\n    }\n  }, [v7_startTransition]);\n  let setState = React.useCallback((newState, _ref2) => {\n    let {\n      deletedFetchers,\n      flushSync: flushSync,\n      viewTransitionOpts: viewTransitionOpts\n    } = _ref2;\n    newState.fetchers.forEach((fetcher, key) => {\n      if (fetcher.data !== undefined) {\n        fetcherData.current.set(key, fetcher.data);\n      }\n    });\n    deletedFetchers.forEach(key => fetcherData.current.delete(key));\n    let isViewTransitionUnavailable = router.window == null || router.window.document == null || typeof router.window.document.startViewTransition !== \"function\";\n    // If this isn't a view transition or it's not available in this browser,\n    // just update and be done with it\n    if (!viewTransitionOpts || isViewTransitionUnavailable) {\n      if (flushSync) {\n        flushSyncSafe(() => setStateImpl(newState));\n      } else {\n        optInStartTransition(() => setStateImpl(newState));\n      }\n      return;\n    }\n    // flushSync + startViewTransition\n    if (flushSync) {\n      // Flush through the context to mark DOM elements as transition=ing\n      flushSyncSafe(() => {\n        // Cancel any pending transitions\n        if (transition) {\n          renderDfd && renderDfd.resolve();\n          transition.skipTransition();\n        }\n        setVtContext({\n          isTransitioning: true,\n          flushSync: true,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      });\n      // Update the DOM\n      let t = router.window.document.startViewTransition(() => {\n        flushSyncSafe(() => setStateImpl(newState));\n      });\n      // Clean up after the animation completes\n      t.finished.finally(() => {\n        flushSyncSafe(() => {\n          setRenderDfd(undefined);\n          setTransition(undefined);\n          setPendingState(undefined);\n          setVtContext({\n            isTransitioning: false\n          });\n        });\n      });\n      flushSyncSafe(() => setTransition(t));\n      return;\n    }\n    // startTransition + startViewTransition\n    if (transition) {\n      // Interrupting an in-progress transition, cancel and let everything flush\n      // out, and then kick off a new transition from the interruption state\n      renderDfd && renderDfd.resolve();\n      transition.skipTransition();\n      setInterruption({\n        state: newState,\n        currentLocation: viewTransitionOpts.currentLocation,\n        nextLocation: viewTransitionOpts.nextLocation\n      });\n    } else {\n      // Completed navigation update with opted-in view transitions, let 'er rip\n      setPendingState(newState);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: viewTransitionOpts.currentLocation,\n        nextLocation: viewTransitionOpts.nextLocation\n      });\n    }\n  }, [router.window, transition, renderDfd, fetcherData, optInStartTransition]);\n  // Need to use a layout effect here so we are subscribed early enough to\n  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n  React.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n  // When we start a view transition, create a Deferred we can use for the\n  // eventual \"completed\" render\n  React.useEffect(() => {\n    if (vtContext.isTransitioning && !vtContext.flushSync) {\n      setRenderDfd(new Deferred());\n    }\n  }, [vtContext]);\n  // Once the deferred is created, kick off startViewTransition() to update the\n  // DOM and then wait on the Deferred to resolve (indicating the DOM update has\n  // happened)\n  React.useEffect(() => {\n    if (renderDfd && pendingState && router.window) {\n      let newState = pendingState;\n      let renderPromise = renderDfd.promise;\n      let transition = router.window.document.startViewTransition(async () => {\n        optInStartTransition(() => setStateImpl(newState));\n        await renderPromise;\n      });\n      transition.finished.finally(() => {\n        setRenderDfd(undefined);\n        setTransition(undefined);\n        setPendingState(undefined);\n        setVtContext({\n          isTransitioning: false\n        });\n      });\n      setTransition(transition);\n    }\n  }, [optInStartTransition, pendingState, renderDfd, router.window]);\n  // When the new location finally renders and is committed to the DOM, this\n  // effect will run to resolve the transition\n  React.useEffect(() => {\n    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n      renderDfd.resolve();\n    }\n  }, [renderDfd, transition, state.location, pendingState]);\n  // If we get interrupted with a new navigation during a transition, we skip\n  // the active transition, let it cleanup, then kick it off again here\n  React.useEffect(() => {\n    if (!vtContext.isTransitioning && interruption) {\n      setPendingState(interruption.state);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: interruption.currentLocation,\n        nextLocation: interruption.nextLocation\n      });\n      setInterruption(undefined);\n    }\n  }, [vtContext.isTransitioning, interruption]);\n  React.useEffect(() => {\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(fallbackElement == null || !router.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using \" + \"`v7_partialHydration`, use a `HydrateFallback` component instead\") : void 0;\n    // Only log this once on initial mount\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  let navigator = React.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: n => router.navigate(n),\n      push: (to, state, opts) => router.navigate(to, {\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      }),\n      replace: (to, state, opts) => router.navigate(to, {\n        replace: true,\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || \"/\";\n  let dataRouterContext = React.useMemo(() => ({\n    router,\n    navigator,\n    static: false,\n    basename\n  }), [router, navigator, basename]);\n  let routerFuture = React.useMemo(() => ({\n    v7_relativeSplatPath: router.future.v7_relativeSplatPath\n  }), [router.future.v7_relativeSplatPath]);\n  React.useEffect(() => UNSAFE_logV6DeprecationWarnings(future, router.future), [future, router.future]);\n  // The fragment and {null} here are important!  We need them to keep React 18's\n  // useId happy when we are server-rendering since we may have a <script> here\n  // containing the hydrated server-side staticContext (from StaticRouterProvider).\n  // useId relies on the component tree structure to generate deterministic id's\n  // so we need to ensure it remains the same on the client even though\n  // we don't need the <script> tag\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(UNSAFE_DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, /*#__PURE__*/React.createElement(UNSAFE_DataRouterStateContext.Provider, {\n    value: state\n  }, /*#__PURE__*/React.createElement(FetchersContext.Provider, {\n    value: fetcherData.current\n  }, /*#__PURE__*/React.createElement(ViewTransitionContext.Provider, {\n    value: vtContext\n  }, /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator: navigator,\n    future: routerFuture\n  }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/React.createElement(MemoizedDataRoutes, {\n    routes: router.routes,\n    future: router.future,\n    state: state\n  }) : fallbackElement))))), null);\n}\n// Memoize to avoid re-renders when updating `ViewTransitionContext`\nconst MemoizedDataRoutes = /*#__PURE__*/React.memo(DataRoutes);\nfunction DataRoutes(_ref3) {\n  let {\n    routes,\n    future,\n    state\n  } = _ref3;\n  return UNSAFE_useRoutesImpl(routes, undefined, state, future);\n}\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */\nfunction BrowserRouter(_ref4) {\n  let {\n    basename,\n    children,\n    future,\n    window\n  } = _ref4;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({\n      window,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  React.useEffect(() => UNSAFE_logV6DeprecationWarnings(future), [future]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future: future\n  });\n}\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */\nfunction HashRouter(_ref5) {\n  let {\n    basename,\n    children,\n    future,\n    window\n  } = _ref5;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({\n      window,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  React.useEffect(() => UNSAFE_logV6DeprecationWarnings(future), [future]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future: future\n  });\n}\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */\nfunction HistoryRouter(_ref6) {\n  let {\n    basename,\n    children,\n    future,\n    history\n  } = _ref6;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  React.useEffect(() => UNSAFE_logV6DeprecationWarnings(future), [future]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future: future\n  });\n}\nif (process.env.NODE_ENV !== \"production\") {\n  HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\nconst isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n/**\n * The public API for rendering a history-aware `<a>`.\n */\nconst Link = /*#__PURE__*/React.forwardRef(function LinkWithRef(_ref7, ref) {\n  let {\n      onClick,\n      relative,\n      reloadDocument,\n      replace,\n      state,\n      target,\n      to,\n      preventScrollReset,\n      viewTransition\n    } = _ref7,\n    rest = _objectWithoutPropertiesLoose(_ref7, _excluded);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  // Rendered into <a href> for absolute URLs\n  let absoluteHref;\n  let isExternal = false;\n  if (typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to)) {\n    // Render the absolute href server- and client-side\n    absoluteHref = to;\n    // Only check for external origins client-side\n    if (isBrowser) {\n      try {\n        let currentUrl = new URL(window.location.href);\n        let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n        let path = stripBasename(targetUrl.pathname, basename);\n        if (targetUrl.origin === currentUrl.origin && path != null) {\n          // Strip the protocol/origin/basename for same-origin absolute URLs\n          to = path + targetUrl.search + targetUrl.hash;\n        } else {\n          isExternal = true;\n        }\n      } catch (e) {\n        // We can't do external URL detection without a valid URL\n        process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"<Link to=\\\"\" + to + \"\\\"> contains an invalid URL which will probably break \" + \"when clicked - please update to a valid URL path.\") : void 0;\n      }\n    }\n  }\n  // Rendered into <a href> for relative URLs\n  let href = useHref(to, {\n    relative\n  });\n  let internalOnClick = useLinkClickHandler(to, {\n    replace,\n    state,\n    target,\n    preventScrollReset,\n    relative,\n    viewTransition\n  });\n  function handleClick(event) {\n    if (onClick) onClick(event);\n    if (!event.defaultPrevented) {\n      internalOnClick(event);\n    }\n  }\n  return (\n    /*#__PURE__*/\n    // eslint-disable-next-line jsx-a11y/anchor-has-content\n    React.createElement(\"a\", _extends({}, rest, {\n      href: absoluteHref || href,\n      onClick: isExternal || reloadDocument ? onClick : handleClick,\n      ref: ref,\n      target: target\n    }))\n  );\n});\nif (process.env.NODE_ENV !== \"production\") {\n  Link.displayName = \"Link\";\n}\n/**\n * A `<Link>` wrapper that knows if it's \"active\" or not.\n */\nconst NavLink = /*#__PURE__*/React.forwardRef(function NavLinkWithRef(_ref8, ref) {\n  let {\n      \"aria-current\": ariaCurrentProp = \"page\",\n      caseSensitive = false,\n      className: classNameProp = \"\",\n      end = false,\n      style: styleProp,\n      to,\n      viewTransition,\n      children\n    } = _ref8,\n    rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);\n  let path = useResolvedPath(to, {\n    relative: rest.relative\n  });\n  let location = useLocation();\n  let routerState = React.useContext(UNSAFE_DataRouterStateContext);\n  let {\n    navigator,\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let isTransitioning = routerState != null &&\n  // Conditional usage is OK here because the usage of a data router is static\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  useViewTransitionState(path) && viewTransition === true;\n  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n  let locationPathname = location.pathname;\n  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n  if (!caseSensitive) {\n    locationPathname = locationPathname.toLowerCase();\n    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n    toPathname = toPathname.toLowerCase();\n  }\n  if (nextLocationPathname && basename) {\n    nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;\n  }\n  // If the `to` has a trailing slash, look at that exact spot.  Otherwise,\n  // we're looking for a slash _after_ what's in `to`.  For example:\n  //\n  // <NavLink to=\"/users\"> and <NavLink to=\"/users/\">\n  // both want to look for a / at index 6 to match URL `/users/matt`\n  const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n  let renderProps = {\n    isActive,\n    isPending,\n    isTransitioning\n  };\n  let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n  let className;\n  if (typeof classNameProp === \"function\") {\n    className = classNameProp(renderProps);\n  } else {\n    // If the className prop is not a function, we use a default `active`\n    // class for <NavLink />s that are active. In v5 `active` was the default\n    // value for `activeClassName`, but we are removing that API and can still\n    // use the old default behavior for a cleaner upgrade path and keep the\n    // simple styling rules working as they currently do.\n    className = [classNameProp, isActive ? \"active\" : null, isPending ? \"pending\" : null, isTransitioning ? \"transitioning\" : null].filter(Boolean).join(\" \");\n  }\n  let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n  return /*#__PURE__*/React.createElement(Link, _extends({}, rest, {\n    \"aria-current\": ariaCurrent,\n    className: className,\n    ref: ref,\n    style: style,\n    to: to,\n    viewTransition: viewTransition\n  }), typeof children === \"function\" ? children(renderProps) : children);\n});\nif (process.env.NODE_ENV !== \"production\") {\n  NavLink.displayName = \"NavLink\";\n}\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\nconst Form = /*#__PURE__*/React.forwardRef((_ref9, forwardedRef) => {\n  let {\n      fetcherKey,\n      navigate,\n      reloadDocument,\n      replace,\n      state,\n      method = defaultMethod,\n      action,\n      onSubmit,\n      relative,\n      preventScrollReset,\n      viewTransition\n    } = _ref9,\n    props = _objectWithoutPropertiesLoose(_ref9, _excluded3);\n  let submit = useSubmit();\n  let formAction = useFormAction(action, {\n    relative\n  });\n  let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  let submitHandler = event => {\n    onSubmit && onSubmit(event);\n    if (event.defaultPrevented) return;\n    event.preventDefault();\n    let submitter = event.nativeEvent.submitter;\n    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n    submit(submitter || event.currentTarget, {\n      fetcherKey,\n      method: submitMethod,\n      navigate,\n      replace,\n      state,\n      relative,\n      preventScrollReset,\n      viewTransition\n    });\n  };\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\n    ref: forwardedRef,\n    method: formMethod,\n    action: formAction,\n    onSubmit: reloadDocument ? onSubmit : submitHandler\n  }, props));\n});\nif (process.env.NODE_ENV !== \"production\") {\n  Form.displayName = \"Form\";\n}\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */\nfunction ScrollRestoration(_ref10) {\n  let {\n    getKey,\n    storageKey\n  } = _ref10;\n  useScrollRestoration({\n    getKey,\n    storageKey\n  });\n  return null;\n}\nif (process.env.NODE_ENV !== \"production\") {\n  ScrollRestoration.displayName = \"ScrollRestoration\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar DataRouterHook;\n(function (DataRouterHook) {\n  DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n  DataRouterHook[\"UseSubmit\"] = \"useSubmit\";\n  DataRouterHook[\"UseSubmitFetcher\"] = \"useSubmitFetcher\";\n  DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\n  DataRouterHook[\"useViewTransitionState\"] = \"useViewTransitionState\";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function (DataRouterStateHook) {\n  DataRouterStateHook[\"UseFetcher\"] = \"useFetcher\";\n  DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\n  DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\n// Internal hooks\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = React.useContext(UNSAFE_DataRouterContext);\n  !ctx ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = React.useContext(UNSAFE_DataRouterStateContext);\n  !state ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return state;\n}\n// External hooks\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */\nfunction useLinkClickHandler(to, _temp) {\n  let {\n    target,\n    replace: replaceProp,\n    state,\n    preventScrollReset,\n    relative,\n    viewTransition\n  } = _temp === void 0 ? {} : _temp;\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to, {\n    relative\n  });\n  return React.useCallback(event => {\n    if (shouldProcessLinkClick(event, target)) {\n      event.preventDefault();\n      // If the URL hasn't changed, a regular <a> will do a replace instead of\n      // a push, so do the same here unless the replace prop is explicitly set\n      let replace = replaceProp !== undefined ? replaceProp : createPath(location) === createPath(path);\n      navigate(to, {\n        replace,\n        state,\n        preventScrollReset,\n        relative,\n        viewTransition\n      });\n    }\n  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, viewTransition]);\n}\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */\nfunction useSearchParams(defaultInit) {\n  process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params.\") : void 0;\n  let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n  let hasSetSearchParamsRef = React.useRef(false);\n  let location = useLocation();\n  let searchParams = React.useMemo(() =>\n  // Only merge in the defaults if we haven't yet called setSearchParams.\n  // Once we call that we want those to take precedence, otherwise you can't\n  // remove a param with setSearchParams({}) if it has an initial value\n  getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);\n  let navigate = useNavigate();\n  let setSearchParams = React.useCallback((nextInit, navigateOptions) => {\n    const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n    hasSetSearchParamsRef.current = true;\n    navigate(\"?\" + newSearchParams, navigateOptions);\n  }, [navigate, searchParams]);\n  return [searchParams, setSearchParams];\n}\nfunction validateClientSideSubmission() {\n  if (typeof document === \"undefined\") {\n    throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\n  }\n}\nlet fetcherId = 0;\nlet getUniqueFetcherId = () => \"__\" + String(++fetcherId) + \"__\";\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */\nfunction useSubmit() {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseSubmit);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let currentRouteId = UNSAFE_useRouteId();\n  return React.useCallback(function (target, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    validateClientSideSubmission();\n    let {\n      action,\n      method,\n      encType,\n      formData,\n      body\n    } = getFormSubmissionInfo(target, basename);\n    if (options.navigate === false) {\n      let key = options.fetcherKey || getUniqueFetcherId();\n      router.fetch(key, currentRouteId, options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        flushSync: options.flushSync\n      });\n    } else {\n      router.navigate(options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        replace: options.replace,\n        state: options.state,\n        fromRouteId: currentRouteId,\n        flushSync: options.flushSync,\n        viewTransition: options.viewTransition\n      });\n    }\n  }, [router, basename, currentRouteId]);\n}\n// v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nfunction useFormAction(action, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let routeContext = React.useContext(UNSAFE_RouteContext);\n  !routeContext ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFormAction must be used inside a RouteContext\") : UNSAFE_invariant(false) : void 0;\n  let [match] = routeContext.matches.slice(-1);\n  // Shallow clone path so we can modify it below, otherwise we modify the\n  // object referenced by useMemo inside useResolvedPath\n  let path = _extends({}, useResolvedPath(action ? action : \".\", {\n    relative\n  }));\n  // If no action was specified, browsers will persist current search params\n  // when determining the path, so match that behavior\n  // https://github.com/remix-run/remix/issues/927\n  let location = useLocation();\n  if (action == null) {\n    // Safe to write to this directly here since if action was undefined, we\n    // would have called useResolvedPath(\".\") which will never include a search\n    path.search = location.search;\n    // When grabbing search params from the URL, remove any included ?index param\n    // since it might not apply to our contextual route.  We add it back based\n    // on match.route.index below\n    let params = new URLSearchParams(path.search);\n    let indexValues = params.getAll(\"index\");\n    let hasNakedIndexParam = indexValues.some(v => v === \"\");\n    if (hasNakedIndexParam) {\n      params.delete(\"index\");\n      indexValues.filter(v => v).forEach(v => params.append(\"index\", v));\n      let qs = params.toString();\n      path.search = qs ? \"?\" + qs : \"\";\n    }\n  }\n  if ((!action || action === \".\") && match.route.index) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the form action.  If this is a root navigation, then just use\n  // the raw basename which allows the basename to have full control over the\n  // presence of a trailing slash on root actions\n  if (basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\n// TODO: (v7) Change the useFetcher generic default from `any` to `unknown`\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */\nfunction useFetcher(_temp3) {\n  var _route$matches;\n  let {\n    key\n  } = _temp3 === void 0 ? {} : _temp3;\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseFetcher);\n  let state = useDataRouterState(DataRouterStateHook.UseFetcher);\n  let fetcherData = React.useContext(FetchersContext);\n  let route = React.useContext(UNSAFE_RouteContext);\n  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n  !fetcherData ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFetcher must be used inside a FetchersContext\") : UNSAFE_invariant(false) : void 0;\n  !route ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFetcher must be used inside a RouteContext\") : UNSAFE_invariant(false) : void 0;\n  !(routeId != null) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFetcher can only be used on routes that contain a unique \\\"id\\\"\") : UNSAFE_invariant(false) : void 0;\n  // Fetcher key handling\n  // OK to call conditionally to feature detect `useId`\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  let defaultKey = useIdImpl ? useIdImpl() : \"\";\n  let [fetcherKey, setFetcherKey] = React.useState(key || defaultKey);\n  if (key && key !== fetcherKey) {\n    setFetcherKey(key);\n  } else if (!fetcherKey) {\n    // We will only fall through here when `useId` is not available\n    setFetcherKey(getUniqueFetcherId());\n  }\n  // Registration/cleanup\n  React.useEffect(() => {\n    router.getFetcher(fetcherKey);\n    return () => {\n      // Tell the router we've unmounted - if v7_fetcherPersist is enabled this\n      // will not delete immediately but instead queue up a delete after the\n      // fetcher returns to an `idle` state\n      router.deleteFetcher(fetcherKey);\n    };\n  }, [router, fetcherKey]);\n  // Fetcher additions\n  let load = React.useCallback((href, opts) => {\n    !routeId ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"No routeId available for fetcher.load()\") : UNSAFE_invariant(false) : void 0;\n    router.fetch(fetcherKey, routeId, href, opts);\n  }, [fetcherKey, routeId, router]);\n  let submitImpl = useSubmit();\n  let submit = React.useCallback((target, opts) => {\n    submitImpl(target, _extends({}, opts, {\n      navigate: false,\n      fetcherKey\n    }));\n  }, [fetcherKey, submitImpl]);\n  let FetcherForm = React.useMemo(() => {\n    let FetcherForm = /*#__PURE__*/React.forwardRef((props, ref) => {\n      return /*#__PURE__*/React.createElement(Form, _extends({}, props, {\n        navigate: false,\n        fetcherKey: fetcherKey,\n        ref: ref\n      }));\n    });\n    if (process.env.NODE_ENV !== \"production\") {\n      FetcherForm.displayName = \"fetcher.Form\";\n    }\n    return FetcherForm;\n  }, [fetcherKey]);\n  // Exposed FetcherWithComponents\n  let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;\n  let data = fetcherData.get(fetcherKey);\n  let fetcherWithComponents = React.useMemo(() => _extends({\n    Form: FetcherForm,\n    submit,\n    load\n  }, fetcher, {\n    data\n  }), [FetcherForm, submit, load, fetcher, data]);\n  return fetcherWithComponents;\n}\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */\nfunction useFetchers() {\n  let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n  return Array.from(state.fetchers.entries()).map(_ref11 => {\n    let [key, fetcher] = _ref11;\n    return _extends({}, fetcher, {\n      key\n    });\n  });\n}\nconst SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nlet savedScrollPositions = {};\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */\nfunction useScrollRestoration(_temp4) {\n  let {\n    getKey,\n    storageKey\n  } = _temp4 === void 0 ? {} : _temp4;\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n  let {\n    restoreScrollPosition,\n    preventScrollReset\n  } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let location = useLocation();\n  let matches = useMatches();\n  let navigation = useNavigation();\n  // Trigger manual scroll restoration while we're active\n  React.useEffect(() => {\n    window.history.scrollRestoration = \"manual\";\n    return () => {\n      window.history.scrollRestoration = \"auto\";\n    };\n  }, []);\n  // Save positions on pagehide\n  usePageHide(React.useCallback(() => {\n    if (navigation.state === \"idle\") {\n      let key = (getKey ? getKey(location, matches) : null) || location.key;\n      savedScrollPositions[key] = window.scrollY;\n    }\n    try {\n      sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n    } catch (error) {\n      process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (\" + error + \").\") : void 0;\n    }\n    window.history.scrollRestoration = \"auto\";\n  }, [storageKey, getKey, navigation.state, location, matches]));\n  // Read in any saved scroll locations\n  if (typeof document !== \"undefined\") {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      try {\n        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n        if (sessionPositions) {\n          savedScrollPositions = JSON.parse(sessionPositions);\n        }\n      } catch (e) {\n        // no-op, use default empty object\n      }\n    }, [storageKey]);\n    // Enable scroll restoration in the router\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      let getKeyWithoutBasename = getKey && basename !== \"/\" ? (location, matches) => getKey( // Strip the basename to match useLocation()\n      _extends({}, location, {\n        pathname: stripBasename(location.pathname, basename) || location.pathname\n      }), matches) : getKey;\n      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);\n      return () => disableScrollRestoration && disableScrollRestoration();\n    }, [router, basename, getKey]);\n    // Restore scrolling when state.restoreScrollPosition changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      // Explicit false means don't do anything (used for submissions)\n      if (restoreScrollPosition === false) {\n        return;\n      }\n      // been here before, scroll to it\n      if (typeof restoreScrollPosition === \"number\") {\n        window.scrollTo(0, restoreScrollPosition);\n        return;\n      }\n      // try to scroll to the hash\n      if (location.hash) {\n        let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n        if (el) {\n          el.scrollIntoView();\n          return;\n        }\n      }\n      // Don't reset if this navigation opted out\n      if (preventScrollReset === true) {\n        return;\n      }\n      // otherwise go to the top on new locations\n      window.scrollTo(0, 0);\n    }, [location, restoreScrollPosition, preventScrollReset]);\n  }\n}\n/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction useBeforeUnload(callback, options) {\n  let {\n    capture\n  } = options || {};\n  React.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : undefined;\n    window.addEventListener(\"beforeunload\", callback, opts);\n    return () => {\n      window.removeEventListener(\"beforeunload\", callback, opts);\n    };\n  }, [callback, capture]);\n}\n/**\n * Setup a callback to be fired on the window's `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction usePageHide(callback, options) {\n  let {\n    capture\n  } = options || {};\n  React.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : undefined;\n    window.addEventListener(\"pagehide\", callback, opts);\n    return () => {\n      window.removeEventListener(\"pagehide\", callback, opts);\n    };\n  }, [callback, capture]);\n}\n/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */\nfunction usePrompt(_ref12) {\n  let {\n    when,\n    message\n  } = _ref12;\n  let blocker = useBlocker(when);\n  React.useEffect(() => {\n    if (blocker.state === \"blocked\") {\n      let proceed = window.confirm(message);\n      if (proceed) {\n        // This timeout is needed to avoid a weird \"race\" on POP navigations\n        // between the `window.history` revert navigation and the result of\n        // `window.confirm`\n        setTimeout(blocker.proceed, 0);\n      } else {\n        blocker.reset();\n      }\n    }\n  }, [blocker, message]);\n  React.useEffect(() => {\n    if (blocker.state === \"blocked\" && !when) {\n      blocker.reset();\n    }\n  }, [blocker, when]);\n}\n/**\n * Return a boolean indicating if there is an active view transition to the\n * given href.  You can use this value to render CSS classes or viewTransitionName\n * styles onto your elements\n *\n * @param href The destination href\n * @param [opts.relative] Relative routing type (\"route\" | \"path\")\n */\nfunction useViewTransitionState(to, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  let vtContext = React.useContext(ViewTransitionContext);\n  !(vtContext != null) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  \" + \"Did you accidentally import `RouterProvider` from `react-router`?\") : UNSAFE_invariant(false) : void 0;\n  let {\n    basename\n  } = useDataRouterContext(DataRouterHook.useViewTransitionState);\n  let path = useResolvedPath(to, {\n    relative: opts.relative\n  });\n  if (!vtContext.isTransitioning) {\n    return false;\n  }\n  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n  // Transition is active if we're going to or coming from the indicated\n  // destination.  This ensures that other PUSH navigations that reverse\n  // an indicated transition apply.  I.e., on the list view you have:\n  //\n  //   <NavLink to=\"/details/1\" viewTransition>\n  //\n  // If you click the breadcrumb back to the list view:\n  //\n  //   <NavLink to=\"/list\" viewTransition>\n  //\n  // We should apply the transition because it's indicated as active going\n  // from /list -> /details/1 and therefore should be active on the reverse\n  // (even though this isn't strictly a POP reverse)\n  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;\n}\n//#endregion\n\nexport { BrowserRouter, Form, HashRouter, Link, NavLink, RouterProvider, ScrollRestoration, FetchersContext as UNSAFE_FetchersContext, ViewTransitionContext as UNSAFE_ViewTransitionContext, useScrollRestoration as UNSAFE_useScrollRestoration, createBrowserRouter, createHashRouter, createSearchParams, HistoryRouter as unstable_HistoryRouter, usePrompt as unstable_usePrompt, useBeforeUnload, useFetcher, useFetchers, useFormAction, useLinkClickHandler, useSearchParams, useSubmit, useViewTransitionState };\n//# sourceMappingURL=index.js.map\n","const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, getInitialState, subscribe, destroy };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\nexport { createStore, vanilla as default };\n","/**\n * @license React\n * use-sync-external-store-shim.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar React = require(\"react\");\nfunction is(x, y) {\n  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\nvar objectIs = \"function\" === typeof Object.is ? Object.is : is,\n  useState = React.useState,\n  useEffect = React.useEffect,\n  useLayoutEffect = React.useLayoutEffect,\n  useDebugValue = React.useDebugValue;\nfunction useSyncExternalStore$2(subscribe, getSnapshot) {\n  var value = getSnapshot(),\n    _useState = useState({ inst: { value: value, getSnapshot: getSnapshot } }),\n    inst = _useState[0].inst,\n    forceUpdate = _useState[1];\n  useLayoutEffect(\n    function () {\n      inst.value = value;\n      inst.getSnapshot = getSnapshot;\n      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n    },\n    [subscribe, value, getSnapshot]\n  );\n  useEffect(\n    function () {\n      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n      return subscribe(function () {\n        checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n      });\n    },\n    [subscribe]\n  );\n  useDebugValue(value);\n  return value;\n}\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  inst = inst.value;\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(inst, nextValue);\n  } catch (error) {\n    return !0;\n  }\n}\nfunction useSyncExternalStore$1(subscribe, getSnapshot) {\n  return getSnapshot();\n}\nvar shim =\n  \"undefined\" === typeof window ||\n  \"undefined\" === typeof window.document ||\n  \"undefined\" === typeof window.document.createElement\n    ? useSyncExternalStore$1\n    : useSyncExternalStore$2;\nexports.useSyncExternalStore =\n  void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n","/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar React = require(\"react\"),\n  shim = require(\"use-sync-external-store/shim\");\nfunction is(x, y) {\n  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\nvar objectIs = \"function\" === typeof Object.is ? Object.is : is,\n  useSyncExternalStore = shim.useSyncExternalStore,\n  useRef = React.useRef,\n  useEffect = React.useEffect,\n  useMemo = React.useMemo,\n  useDebugValue = React.useDebugValue;\nexports.useSyncExternalStoreWithSelector = function (\n  subscribe,\n  getSnapshot,\n  getServerSnapshot,\n  selector,\n  isEqual\n) {\n  var instRef = useRef(null);\n  if (null === instRef.current) {\n    var inst = { hasValue: !1, value: null };\n    instRef.current = inst;\n  } else inst = instRef.current;\n  instRef = useMemo(\n    function () {\n      function memoizedSelector(nextSnapshot) {\n        if (!hasMemo) {\n          hasMemo = !0;\n          memoizedSnapshot = nextSnapshot;\n          nextSnapshot = selector(nextSnapshot);\n          if (void 0 !== isEqual && inst.hasValue) {\n            var currentSelection = inst.value;\n            if (isEqual(currentSelection, nextSnapshot))\n              return (memoizedSelection = currentSelection);\n          }\n          return (memoizedSelection = nextSnapshot);\n        }\n        currentSelection = memoizedSelection;\n        if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;\n        var nextSelection = selector(nextSnapshot);\n        if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))\n          return (memoizedSnapshot = nextSnapshot), currentSelection;\n        memoizedSnapshot = nextSnapshot;\n        return (memoizedSelection = nextSelection);\n      }\n      var hasMemo = !1,\n        memoizedSnapshot,\n        memoizedSelection,\n        maybeGetServerSnapshot =\n          void 0 === getServerSnapshot ? null : getServerSnapshot;\n      return [\n        function () {\n          return memoizedSelector(getSnapshot());\n        },\n        null === maybeGetServerSnapshot\n          ? void 0\n          : function () {\n              return memoizedSelector(maybeGetServerSnapshot());\n            }\n      ];\n    },\n    [getSnapshot, getServerSnapshot, selector, isEqual]\n  );\n  var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n  useEffect(\n    function () {\n      inst.hasValue = !0;\n      inst.value = value;\n    },\n    [value]\n  );\n  useDebugValue(value);\n  return value;\n};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n","import { createStore } from 'zustand/vanilla';\nexport * from 'zustand/vanilla';\nimport ReactExports from 'react';\nimport useSyncExternalStoreExports from 'use-sync-external-store/shim/with-selector.js';\n\nconst { useDebugValue } = ReactExports;\nconst { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;\nlet didWarnAboutEqualityFn = false;\nconst identity = (arg) => arg;\nfunction useStore(api, selector = identity, equalityFn) {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && equalityFn && !didWarnAboutEqualityFn) {\n    console.warn(\n      \"[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937\"\n    );\n    didWarnAboutEqualityFn = true;\n  }\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getInitialState,\n    selector,\n    equalityFn\n  );\n  useDebugValue(slice);\n  return slice;\n}\nconst createImpl = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && typeof createState !== \"function\") {\n    console.warn(\n      \"[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.\"\n    );\n  }\n  const api = typeof createState === \"function\" ? createStore(createState) : createState;\n  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nconst create = (createState) => createState ? createImpl(createState) : createImpl;\nvar react = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`.\"\n    );\n  }\n  return create(createState);\n};\n\nexport { create, react as default, useStore };\n","export const CHARACTER_ORDER = [\n  'frieren',\n  'himmel',\n  'heiter',\n  'eisen',\n  'fern',\n  'stark',\n  'sein',\n  'übel'\n] as const;\n\nexport type CharacterId = typeof CHARACTER_ORDER[number];\n\nexport const CHARACTER_COLORS: Record<CharacterId, string> = {\n  frieren: '#7f7c84',\n  himmel: '#bddaf9',\n  heiter: '#78855e',\n  eisen: '#cfccc0',\n  fern: '#794983',\n  stark: '#af4a33',\n  sein: '#936f42',\n  'übel': '#667240'\n};\n\nexport function nextUnassignedCharacter(used: Set<string>): CharacterId | null {\n  for (const c of CHARACTER_ORDER) {\n    if (!used.has(c)) return c;\n  }\n  return null;\n}\n\nexport function spriteUrlFor(character: CharacterId): string {\n  // Relative path leverages Vite dev proxy and absolute static in prod\n  return `/media/sprites/square_${character}.png`;\n}\n","import { create } from 'zustand';\nimport { CHARACTER_ORDER } from './characters';\n\n// --- Phase 2 types ---\nexport interface RosterUser {\n  clientId: string;\n  name: string;\n  sprite: string | null;\n  isLeader?: boolean;\n}\n\nexport interface SnapshotState {\n  mediaId: string | null;\n  playheadMs: number;\n  playing: boolean;\n  serverSeq: number; // last authoritative seq applied\n  leaderId: string | null;\n}\n\nexport interface MeState {\n  clientId: string | null;\n  nextClientSeq: number; // local incrementing control seq (client scoped)\n}\n\nexport interface DriftState {\n  rtts: number[]; // last 5 RTT samples (ms)\n  offsetMs: number; // estimated serverTime - clientTime\n}\n\nexport interface ChatMessage {\n  id: string; // could be server seq or timestamp derived\n  clientId: string;\n  name: string;\n  sprite: string | null;\n  text: string;\n  ts: number; // epoch ms\n}\n\ninterface AppState {\n  // existing identity/admin\n  ready: boolean;\n  name: string;\n  sprite: string | null;\n  adminKey: string | null;\n  rememberAdmin: boolean;\n  // networking + protocol state\n  me: MeState;\n  snapshot: SnapshotState;\n  roster: Record<string, RosterUser>; // keyed by clientId\n  chat: ChatMessage[];\n  drift: DriftState;\n  readiness: { mediaId: string | null; ready: boolean; readyCount: number; total: number };\n  // maps client_seq -> server_seq (populated on ack)\n  seqMap: Record<number, number>;\n  toasts: { id: string; kind: 'error' | 'info'; msg: string; ts: number }[];\n  // actions\n  setReady: () => void;\n  setIdentity: (name: string, sprite: string | null) => void;\n  ensureAutoIdentity: () => void;\n  setAdminKey: (key: string | null, remember: boolean) => void;\n  hydrateAdminKey: () => void;\n  ensureMe: (clientId: string) => void;\n  applySnapshot: (snap: Partial<SnapshotState> & { users?: RosterUser[] }) => void;\n  upsertUser: (u: RosterUser) => void;\n  removeUser: (clientId: string) => void;\n  appendChat: (m: ChatMessage) => void;\n  recordAck: (clientSeq: number, serverSeq: number) => void;\n  allocateClientSeq: () => number;\n  updateControlState: (delta: { playheadMs?: number; playing?: boolean; serverSeq?: number; leaderId?: string }) => void;\n  addRttSample: (rtt: number, serverTime?: number, clientSendTs?: number) => void;\n  pushToast: (kind: 'error' | 'info', msg: string) => void;\n  popToast: (id: string) => void;\n  setReadiness: (r: { mediaId: string; ready: boolean; readyCount: number; total: number }) => void;\n}\n\nconst ADMIN_KEY_STORAGE = 'wp_leader_key';\n\nexport const useAppStore = create<AppState>((set, get) => ({\n  ready: false,\n  name: '',\n  sprite: null,\n  adminKey: null,\n  rememberAdmin: false,\n  me: { clientId: null, nextClientSeq: 1 },\n  snapshot: { mediaId: null, playheadMs: 0, playing: false, serverSeq: 0, leaderId: null },\n  roster: {},\n  chat: [],\n  drift: { rtts: [], offsetMs: 0 },\n  readiness: { mediaId: null, ready: false, readyCount: 0, total: 0 },\n  seqMap: {},\n  toasts: [],\n  setReady: () => set({ ready: true }),\n  setIdentity: (name, sprite) => set({ name, sprite }),\n  ensureAutoIdentity: () => set((s) => {\n    if (s.name) return {};\n    const used = new Set(Object.values(s.roster).map(r => r.name).filter(Boolean));\n    for (const c of CHARACTER_ORDER) {\n      if (!used.has(c)) {\n        return { name: c, sprite: c };\n      }\n    }\n    // If all characters taken, keep anonymous but do not force 'Guest'\n    return { name: CHARACTER_ORDER[0], sprite: CHARACTER_ORDER[0] };\n  }),\n  setAdminKey: (key, remember) => {\n    if (remember && key) localStorage.setItem(ADMIN_KEY_STORAGE, key);\n    else localStorage.removeItem(ADMIN_KEY_STORAGE);\n    set({ adminKey: key, rememberAdmin: remember });\n  },\n  hydrateAdminKey: () => {\n    const stored = localStorage.getItem(ADMIN_KEY_STORAGE);\n    if (stored) set({ adminKey: stored, rememberAdmin: true });\n  },\n  ensureMe: (clientId) => set((s) => ({ me: { ...s.me, clientId } })),\n  applySnapshot: (snap) => set((s) => {\n    const rosterUpdates: Record<string, RosterUser> = { ...s.roster };\n    if (snap.users) {\n      for (const u of snap.users) rosterUpdates[u.clientId] = u;\n    }\n    return {\n      snapshot: {\n        mediaId: snap.mediaId ?? s.snapshot.mediaId,\n        playheadMs: snap.playheadMs ?? s.snapshot.playheadMs,\n        playing: snap.playing ?? s.snapshot.playing,\n        serverSeq: snap.serverSeq ?? s.snapshot.serverSeq,\n        leaderId: snap.leaderId ?? s.snapshot.leaderId\n      },\n      roster: rosterUpdates\n    };\n  }),\n  upsertUser: (u) => set((s) => ({ roster: { ...s.roster, [u.clientId]: u } })),\n  removeUser: (clientId) => set((s) => {\n    const copy = { ...s.roster }; delete copy[clientId]; return { roster: copy };\n  }),\n  appendChat: (m) => set((s) => ({ chat: [...s.chat, m].slice(-500) })),\n  recordAck: (clientSeq, serverSeq) => set((s) => ({ seqMap: { ...s.seqMap, [clientSeq]: serverSeq } })),\n  allocateClientSeq: () => {\n    const n = get().me.nextClientSeq;\n    set((s) => ({ me: { ...s.me, nextClientSeq: n + 1 } }));\n    return n;\n  },\n  updateControlState: (delta) => set((s) => ({\n    snapshot: { ...s.snapshot, ...delta }\n  })),\n  addRttSample: (rtt, serverTime, clientSendTs) => set((s) => {\n    const rtts = [...s.drift.rtts, rtt].slice(-5);\n    let offsetMs = s.drift.offsetMs;\n    if (serverTime && clientSendTs) {\n      const clientReceive = Date.now();\n      const clientMid = clientSendTs + rtt / 2;\n      offsetMs = serverTime - clientMid;\n    }\n    return { drift: { rtts, offsetMs } };\n  })\n  ,\n  pushToast: (kind, msg) => set((s) => ({ toasts: [...s.toasts, { id: Math.random().toString(36).slice(2), kind, msg, ts: Date.now() }].slice(-5) })),\n  popToast: (id) => set((s) => ({ toasts: s.toasts.filter(t => t.id !== id) }))\n  ,setReadiness: (r) => set({ readiness: { mediaId: r.mediaId, ready: r.ready, readyCount: r.readyCount, total: r.total } })\n}));\n","import React, { useEffect } from 'react';\nimport { useAppStore } from '../lib/store';\n\nexport default function Toasts() {\n  const toasts = useAppStore(s => s.toasts);\n  const pop = useAppStore(s => s.popToast);\n  useEffect(() => {\n    const timers = toasts.map(t => setTimeout(() => pop(t.id), 4000));\n    return () => { timers.forEach(clearTimeout); };\n  }, [toasts, pop]);\n  return (\n    <div className=\"fixed bottom-4 left-1/2 -translate-x-1/2 flex flex-col gap-2 z-50\">\n      {toasts.map(t => (\n        <div key={t.id} className={`px-3 py-2 rounded text-sm shadow font-medium bg-slate-800 border ${t.kind==='error' ? 'border-red-500 text-red-300' : 'border-slate-600 text-slate-200'}`}>{t.msg}</div>\n      ))}\n    </div>\n  );\n}\n","import React, { useEffect, useRef } from 'react';\n\ninterface Star {\n  x: number; y: number; z: number; speed: number; size: number; alpha: number;\n  // Color twinkle / rare hue cycling\n  colorRare: boolean; colorPhase: number; colorSpeed: number; colorMode: number;\n  // Brightness twinkle (new model)\n  twinkleAmount: number; // amplitude factor (0..~0.5 used to derive dim floor)\n  twinkleEnabled: boolean; // whether this star participates in brightness interpolation\n  dimFloor: number; // fraction of alpha at darkest (0..1)\n  twinkleStart: number; // starting alpha value for current segment\n  twinkleTarget: number; // target alpha value for current segment\n  twinkleT: number; // progress time (frame units) in current segment\n  twinkleDuration: number; // total duration (frame units) of current segment\n  microPhase: number; // small fast phase for subtle sparkle (ultra mostly)\n  microSpeed: number;\n  ultraRare: boolean; trail?: { x: number; y: number }[]; maxTrail?: number; currentAlpha?: number;\n  lifeMsRemaining: number; // remaining life in milliseconds\n  lifeMsTotal: number; // total assigned life\n}\n\nconst STAR_COUNT = 400; \n\nexport default function StarfieldCanvas() {\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\n  const starsRef = useRef<Star[]>([]);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    const resize = () => {\n      canvas.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n    };\n    resize();\n    window.addEventListener('resize', resize);\n\n  let creationCounter = 0; // tracks total stars ever created (including replacements) if we decide to extend taper later\n\n  function biasForIndex(i: number) {\n    if (i < 300) return { scale: 0.5, demote: 0.5 };      // first 300 -> 50%\n    if (i < 400) return { scale: 0.6, demote: 0.4 };      // next 100 -> 40%\n    if (i < 500) return { scale: 0.7, demote: 0.3 };      // next 100 -> 30%\n    if (i < 600) return { scale: 0.8, demote: 0.2 };      // next 100 -> 20%\n    if (i < 700) return { scale: 0.9, demote: 0.1 };      // next 100 -> 10%\n    return { scale: 1.0, demote: 0 };                     // afterward -> no reduction\n  }\n\n  function makeStar(x?: number, y?: number, initial=false, index?: number): Star {\n      // Bias toward smaller z (slower/smaller) making large/bright rare\n      let r = Math.random();\n      // Determine bias bucket\n      const creationIndex = index ?? creationCounter;\n      if (index === undefined) creationCounter++;\n      const bias = initial ? biasForIndex(creationIndex) : { scale: 1.0, demote: 0 };\n  let ultraRare = r > 0.998; // base ultra threshold (~0.2%)\n  let rare = !ultraRare && r > 0.98; // base rare threshold (~2%)\n      if (bias.demote > 0) {\n        if (ultraRare && Math.random() < bias.demote) ultraRare = false;\n        if (rare && Math.random() < bias.demote) rare = false;\n      }\n      // If this is part of the initial population, suppress rare / ultra entirely per request\n      if (initial) {\n        ultraRare = false;\n        rare = false;\n      }\n  // Color-twinkle rare: pick from remaining base population (~1% of non-rare/non-ultra)\n  const colorRare = rare; // only rare stars twinkle (white↔blue or white↔red)\n      let z: number;\n      if (ultraRare) {\n        // Force ultra-rare into highest depth band so they are always fast/bright\n        z = 0.92 + Math.random() * 0.08; // 0.92 - 1.0\n      } else if (rare) {\n        z = 0.85 + Math.random() * 0.15;\n      } else {\n        z = 0.05 + (Math.random() ** 2.2) * 0.75; // mostly 0.05-0.6 range\n      }\n        // Utility triangular distribution (center bias => extremes rarer)\n        const tri = (min: number, max: number) => {\n          const u1 = Math.random();\n          const u2 = Math.random();\n          return min + ((u1 + u2) / 2) * (max - min);\n        };\n        // Broaden size range with center bias; ultra can get larger; allow smaller floor\n  let sizeBase = tri(0.9, 1.4) + (z ** 1.2) * (ultraRare ? 5.5 : rare ? 4.0 : 3.2);\n        const sizeVariance = tri(0.85, 1.25); // multiplicative tweak (extremes rarer)\n  let size = sizeBase * sizeVariance;\n  if (initial && bias.scale < 1) size *= bias.scale; // tapered size reduction\n        // Broaden alpha range; allow overbright (>1) which will be rendered with an additive pass\n        let alpha: number;\n        if (ultraRare) {\n          // Ultra: high baseline with large possible overbright tail (1.05 - 1.55)\n            alpha = 1.05 + Math.random() * 0.50; \n        } else if (rare) {\n          // Rare: mid-high brightness (approx 0.65 - 1.25)\n          alpha = 0.55 + (z ** 1.05) * 0.70 + Math.random() * 0.25; // typical ~0.8-1.1\n          if (alpha > 1.25) alpha = 1.25;\n        } else {\n          // Common: ~0.15 - 1.05 (most <0.9)\n          alpha = 0.15 + (z ** 1.05) * 0.60 + Math.random() * 0.15;\n          if (alpha > 1.05) alpha = 1.05;\n        }\n  if (!ultraRare && alpha < 0.15) alpha = 0.15; // raise minimal base brightness to 15%\n        // Speed now broader with variance factor; maintain z influence\n        const speedBase = 0.035 + tri(0, 0.08); // lower floor & occasional higher base\n        const speedScale = (z ** 1.45) * (ultraRare ? 4.9 : rare ? 1.55 : 1.25);\n  let speed = speedBase + speedScale * tri(0.85, 1.3);\n  if (initial && bias.scale < 1) speed *= bias.scale; // tapered speed reduction\n        // Additional minor coupling to size/alpha (extremes give mild boost)\n        const normAlpha = Math.min(1, alpha);\n        const normSize = Math.min(1, (size - 1) / 4.5);\n        speed *= 1 + 0.18 * Math.max(normAlpha, normSize);\n        if (ultraRare && speed < 1.25) speed = 1.25 + Math.random() * 0.4;\n  const cw = canvas!.width;\n  const ch = canvas!.height;\n      const twinkleAmount = 0.18 + Math.random() * 0.28; // base amplitude for brightness variance\n  // Enable twinkle for ~18% of non-ultra stars; ultra always twinkle for distinctiveness\n  const twinkleEnabled = ultraRare || Math.random() < 0.18;\n      // Deeper dim for common stars, shallower for rare/ultra\n      const dimFloor = ultraRare ? 0.55 : (colorRare ? 0.38 : Math.max(0.10, 0.28 - twinkleAmount * 0.25));\n  // Immediate visibility: choose a starting brightness within allowed range\n  const startVal = alpha * (dimFloor + Math.random() * (1 - dimFloor));\n  const targetVal = alpha * (dimFloor + Math.random() * (1 - dimFloor));\n      const duration = (ultraRare ? 130 : colorRare ? 160 : 120) + Math.random() * (ultraRare ? 140 : 150); // frame units (~2-5s)\n  // Lifetime 10s..120s weighted by speed.\n  // All stars can occupy full range; slow stars biased longer (typically >=40s) but still small chance below 40.\n  // Fast stars biased shorter. Achieved via exponent shaping + floor lift proportional to (1 - speedNorm).\n  const EXPECTED_MAX_SPEED = 2.5; // heuristic ceiling for normalization\n  const speedNorm = Math.min(1, speed / EXPECTED_MAX_SPEED);\n  const MIN_SEC = 10;\n  const MAX_SEC = 120;\n  const spanSec = MAX_SEC - MIN_SEC; // 110\n  let u = Math.random();\n  const exp = 0.8 + speedNorm * 1.4; // slow ~0.8 (bias high), fast ~2.2 (bias low)\n  u = Math.pow(u, exp);\n  const floorLift = (1 - speedNorm) * ((40 - MIN_SEC) / spanSec); // up to ~0.2727 for slowest so min ~40s typical\n  u = u * (1 - floorLift) + floorLift; // raise lower bound proportionally for slow stars\n  const lifeMsTotal = (MIN_SEC + u * spanSec) * 1000; // final ms\n      return {\n  x: x == null ? Math.random() * cw : x,\n  y: y != null ? y : (initial ? Math.random() * ch : -Math.random() * ch),\n        z,\n        speed,\n        size,\n        alpha,\n        colorRare,\n        colorPhase: Math.random() * Math.PI * 2,\n        colorSpeed: 0.01 + Math.random() * 0.02,\n        colorMode: Math.random() < 0.5 ? 0 : 1,\n        twinkleAmount,\n  twinkleEnabled,\n        dimFloor,\n        twinkleStart: startVal,\n        twinkleTarget: targetVal,\n        twinkleT: 0,\n        twinkleDuration: duration,\n        microPhase: Math.random() * Math.PI * 2,\n        microSpeed: (ultraRare ? 0.18 : 0.10) + Math.random() * 0.05,\n        ultraRare,\n        trail: ultraRare ? [] : undefined,\n        currentAlpha: startVal,\n        lifeMsRemaining: lifeMsTotal,\n        lifeMsTotal\n      };\n    }\n\n    if (!starsRef.current.length) {\n  for (let i = 0; i < STAR_COUNT; i++) starsRef.current.push(makeStar(undefined, undefined, true, i));\n    }\n\n    let lastTime = performance.now();\n    function drawCurvedBottomRect(x: number, y: number, size: number, speed: number) {\n      const maxExpectedSpeed = 2.0;\n      const n = Math.min(1, speed / maxExpectedSpeed);\n      const bottomR = (0.15 + 0.75 * n) * size; // more curvature with speed\n      const w = size;\n      const h = size;\n      const r = Math.min(bottomR, h * 0.95, w * 0.48);\n      const x0 = x;\n      const y0 = y;\n      const x1 = x + w;\n      const y1 = y + h;\n      const c = ctx!;\n      c.beginPath();\n      c.moveTo(x0, y0);\n      c.lineTo(x1, y0); // top edge\n      c.lineTo(x1, y1 - r);\n      c.quadraticCurveTo(x1, y1, x1 - r, y1);\n      c.lineTo(x0 + r, y1);\n      c.quadraticCurveTo(x0, y1, x0, y1 - r);\n      c.lineTo(x0, y0);\n      c.closePath();\n      c.fill();\n    }\n\n    // New brightness model: interpolate between random targets (value noise) to avoid flicker at troughs\n    function updateAlpha(s: Star, dt: number) {\n      if (dt > 3) dt = 3; // cap runaway dt\n      if (!s.twinkleEnabled) { // no brightness interpolation; maintain stable alpha\n        s.currentAlpha = s.alpha;\n        return;\n      }\n      s.twinkleT += dt;\n      if (s.twinkleT >= s.twinkleDuration) {\n        // Start a new segment\n        s.twinkleStart = s.twinkleTarget;\n        // Pick a new target in [dimFloor*alpha, alpha]\n        s.twinkleTarget = s.alpha * (s.dimFloor + Math.random() * (1 - s.dimFloor));\n        // Duration with some variability; ultra get longer smoother drifts\n        const baseDur = s.ultraRare ? 150 : (s.colorRare ? 140 : 110);\n        const jitter = s.ultraRare ? 170 : 140;\n        s.twinkleDuration = baseDur + Math.random() * jitter;\n        s.twinkleT = 0;\n      }\n      const p = Math.min(1, s.twinkleT / s.twinkleDuration);\n      // Smoothstep easing\n      const eased = p * p * (3 - 2 * p);\n      let val = s.twinkleStart + (s.twinkleTarget - s.twinkleStart) * eased;\n      // Ultra rare micro sparkle (very subtle, high frequency, low amplitude)\n      s.microPhase += s.microSpeed * dt;\n      if (s.ultraRare) {\n        const micro = Math.sin(s.microPhase) * 0.04; // ±0.04\n        val = Math.min(1, Math.max(s.alpha * s.dimFloor, val * (1 + micro)));\n      }\n      s.currentAlpha = val;\n    }\n\n    // Update only color related state & return fillStyle\n    function updateColor(s: Star, dt: number): string {\n      if (s.ultraRare) {\n        s.colorPhase += (s.colorSpeed * 2.2) * dt; // faster cycle for ultra rare\n        const colors = [\n          [255, 120, 220], // pink\n          [120, 255, 170], // green\n          [255, 255, 255]  // white\n        ];\n        const cycle = s.colorPhase % colors.length;\n        const idx = Math.floor(cycle);\n        const next = (idx + 1) % colors.length;\n        const t = cycle - idx;\n        const c0 = colors[idx];\n        const c1 = colors[next];\n        const rCol = Math.round(c0[0] + (c1[0] - c0[0]) * t);\n        const gCol = Math.round(c0[1] + (c1[1] - c0[1]) * t);\n        const bCol = Math.round(c0[2] + (c1[2] - c0[2]) * t);\n        return `rgb(${rCol},${gCol},${bCol})`;\n      }\n      if (s.colorRare) {\n        s.colorPhase += s.colorSpeed * dt;\n        const t = (Math.sin(s.colorPhase) + 1) / 2; // 0..1\n        if (s.colorMode === 0) {\n          const rCol = Math.round(255 - (255 - 90) * t);\n          const gCol = Math.round(255 - (255 - 150) * t);\n          const bCol = 255;\n          return `rgb(${rCol},${gCol},${bCol})`;\n        } else {\n          const rCol = 255;\n          const gCol = Math.round(255 - (255 - 80) * t);\n          const bCol = Math.round(255 - (255 - 80) * t);\n          return `rgb(${rCol},${gCol},${bCol})`;\n        }\n      }\n      return '#ffffff';\n    }\n    const render = () => {\n      const now = performance.now();\n  const deltaMs = now - lastTime;\n  const dt = deltaMs / 16.666; // frame units (~60fps)\n      lastTime = now;\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      const w = canvas.width;\n      const h = canvas.height;\n      const OFFSCREEN_BUFFER = 220; // allow trails to finish below view\n      for (let i = 0; i < starsRef.current.length; i++) {\n        const s = starsRef.current[i];\n        // Maintain/update trail data before drawing\n        if (s.ultraRare) {\n          if (!s.trail) s.trail = [];\n          if (!s.maxTrail) {\n            const maxExpectedSpeed = 1.9;\n            const base = s.speed * 14;\n            const norm = Math.min(1, s.speed / maxExpectedSpeed);\n            const scaled = base * (1 + 8 * norm);\n            s.maxTrail = Math.min(300, Math.floor(scaled));\n          }\n          s.trail.push({ x: s.x + s.size / 2, y: s.y + s.size / 2 });\n          if (s.trail.length > s.maxTrail) s.trail.splice(0, s.trail.length - s.maxTrail);\n        }\n        // Lifetime handling\n        s.lifeMsRemaining -= deltaMs;\n        if (s.lifeMsRemaining <= 0) {\n          // Respawn new star from top (non-initial)\n          const newStar = makeStar(Math.random() * canvas.width, undefined, false);\n          // Position just above view\n          newStar.y = -newStar.size - 1;\n          starsRef.current[i] = newStar;\n          continue;\n        }\n        s.y += s.speed * dt;\n        if (s.y - s.size > canvas.height + OFFSCREEN_BUFFER) {\n          starsRef.current[i] = makeStar(Math.random() * canvas.width, -s.size - 1);\n          continue;\n        }\n    updateAlpha(s, dt);\n    const baseAlphaRaw = s.currentAlpha ?? s.alpha; // previous baseAlpha replaced by fade logic\n    const FADE_MS = 1500; // fade duration window\n    const lifeFade = s.lifeMsRemaining < FADE_MS ? Math.max(0, s.lifeMsRemaining / FADE_MS) : 1;\n    const baseAlpha = baseAlphaRaw * lifeFade;\n    let starFillStyle = updateColor(s, dt);\n        if (s.ultraRare) {\n          const enhanced = baseAlpha;\n          if (s.trail && s.trail.length) {\n            const len = s.trail.length;\n            for (let ti = 0; ti < len; ti++) {\n              const tp = s.trail[len - 1 - ti];\n              const linear = (1 - ti / len);\n              const fade = Math.pow(linear, 3);\n              ctx.globalAlpha = Math.min(1, enhanced) * fade * 0.6;\n              const scale = 0.35 + 0.65 * fade;\n              ctx.fillStyle = starFillStyle;\n              const drawSize = s.size * scale;\n              ctx.fillRect(tp.x - drawSize / 2, tp.y - drawSize / 2, drawSize, drawSize);\n            }\n          }\n          ctx.globalAlpha = Math.min(1, enhanced * 1.02);\n          ctx.fillStyle = starFillStyle;\n          const headLeft = s.x - s.size * 0.1;\n          const headTop = s.y - s.size * 0.1;\n          drawCurvedBottomRect(headLeft, headTop, s.size * 1.2, s.speed);\n          // Overbright additive pass for alpha >1\n          if (enhanced > 1.02) {\n            const over = Math.min(1, (enhanced - 1) * 0.85); // compress tail\n            ctx.save();\n            ctx.globalCompositeOperation = 'lighter';\n            ctx.globalAlpha = over;\n            ctx.fillStyle = starFillStyle;\n            const glowSize = s.size * 0.75;\n            drawCurvedBottomRect(headLeft + s.size * 0.225, headTop + s.size * 0.225, glowSize, s.speed);\n            ctx.restore();\n          }\n        } else {\n          ctx.globalAlpha = Math.min(1, baseAlpha);\n          ctx.fillStyle = starFillStyle;\n          drawCurvedBottomRect(s.x, s.y, s.size, s.speed);\n          if (baseAlpha > 1.01) {\n            const over = Math.min(0.9, (baseAlpha - 1) * 0.8);\n            ctx.save();\n            ctx.globalCompositeOperation = 'lighter';\n            ctx.globalAlpha = over;\n            ctx.fillStyle = starFillStyle;\n            const glowSize = s.size * 0.55;\n            drawCurvedBottomRect(s.x + s.size * 0.225, s.y + s.size * 0.225, glowSize, s.speed);\n            ctx.restore();\n          }\n        }\n      }\n      ctx.globalAlpha = 1;\n      requestAnimationFrame(render);\n    };\n    render();\n    return () => window.removeEventListener('resize', resize);\n  }, []);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      data-darkreader-ignore\n      className=\"fixed inset-0 z-0 bg-black pointer-events-none [isolation:isolate]\"\n    />\n  );\n}\n","import React from 'react';\nimport StarfieldCanvas from '../components/StarfieldCanvas';\nimport { Link } from 'react-router-dom';\n\nexport default function Home() {\n  const defaultRooms = ['dev-room-1000'];\n  return (\n    <div className=\"relative h-full flex flex-col items-center justify-center gap-10 py-24\">\n      <StarfieldCanvas />\n      <h1 className=\"text-4xl font-bold tracking-tight drop-shadow\">Watchparty</h1>\n      <div className=\"w-full max-w-md space-y-4 z-10\">\n        <h2 className=\"text-sm uppercase tracking-wide opacity-70\">Rooms</h2>\n        <ul className=\"space-y-2\">\n          {defaultRooms.map(r => (\n            <li key={r}>\n              <Link to={`/room/${encodeURIComponent(r)}`} className=\"block bg-slate-900/80 backdrop-blur border border-slate-700 hover:border-slate-500 rounded px-4 py-3 transition-colors\">\n                <div className=\"font-medium\">{r}</div>\n                <div className=\"text-[11px] opacity-60\">Join room</div>\n              </Link>\n            </li>\n          ))}\n        </ul>\n        <div className=\"pt-6 text-xs opacity-50\">\n          Provide ?roomKey=&leaderKey= query params to deep link directly.\n        </div>\n      </div>\n    </div>\n  );\n}\n","import React from 'react';\nimport { useAppStore } from '../lib/store';\nimport { CHARACTER_COLORS, spriteUrlFor } from '../lib/characters';\n\nexport default function Roster() {\n  const roster = useAppStore(s => s.roster);\n  const users = Object.values(roster);\n  if (!users.length) return <div className=\"text-xs opacity-50\">No users</div>;\n  return (\n    <ul className=\"text-xs space-y-1\">\n      {users.map(u => {\n        const color = (u.name && (CHARACTER_COLORS as any)[u.name]) || '#cbd5e1';\n        return (\n          <li key={u.clientId} className=\"flex items-center gap-2\">\n            {u.sprite ? (\n              <img src={spriteUrlFor(u.sprite as any)} alt={u.sprite} className=\"w-7 h-7 rounded object-cover\" />\n            ) : (\n              <span className=\"inline-block w-7 h-7 bg-slate-700/50 rounded\" />\n            )}\n            <span className=\"truncate max-w-[120px] font-medium\" style={{ color }}>{u.name || 'Anon'}</span>\n            {u.isLeader && <span className=\"px-1 rounded bg-emerald-600 text-[9px]\">L</span>}\n          </li>\n        );\n      })}\n    </ul>\n  );\n}\n","const PACKET_TYPES = Object.create(null); // no Map = no polyfill\nPACKET_TYPES[\"open\"] = \"0\";\nPACKET_TYPES[\"close\"] = \"1\";\nPACKET_TYPES[\"ping\"] = \"2\";\nPACKET_TYPES[\"pong\"] = \"3\";\nPACKET_TYPES[\"message\"] = \"4\";\nPACKET_TYPES[\"upgrade\"] = \"5\";\nPACKET_TYPES[\"noop\"] = \"6\";\nconst PACKET_TYPES_REVERSE = Object.create(null);\nObject.keys(PACKET_TYPES).forEach((key) => {\n    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n});\nconst ERROR_PACKET = { type: \"error\", data: \"parser error\" };\nexport { PACKET_TYPES, PACKET_TYPES_REVERSE, ERROR_PACKET };\n","import { PACKET_TYPES } from \"./commons.js\";\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n// ArrayBuffer.isView method is not defined in IE10\nconst isView = (obj) => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj && obj.buffer instanceof ArrayBuffer;\n};\nconst encodePacket = ({ type, data }, supportsBinary, callback) => {\n    if (withNativeBlob && data instanceof Blob) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(data, callback);\n        }\n    }\n    else if (withNativeArrayBuffer &&\n        (data instanceof ArrayBuffer || isView(data))) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(new Blob([data]), callback);\n        }\n    }\n    // plain string\n    return callback(PACKET_TYPES[type] + (data || \"\"));\n};\nconst encodeBlobAsBase64 = (data, callback) => {\n    const fileReader = new FileReader();\n    fileReader.onload = function () {\n        const content = fileReader.result.split(\",\")[1];\n        callback(\"b\" + (content || \"\"));\n    };\n    return fileReader.readAsDataURL(data);\n};\nfunction toArray(data) {\n    if (data instanceof Uint8Array) {\n        return data;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return new Uint8Array(data);\n    }\n    else {\n        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    }\n}\nlet TEXT_ENCODER;\nexport function encodePacketToBinary(packet, callback) {\n    if (withNativeBlob && packet.data instanceof Blob) {\n        return packet.data.arrayBuffer().then(toArray).then(callback);\n    }\n    else if (withNativeArrayBuffer &&\n        (packet.data instanceof ArrayBuffer || isView(packet.data))) {\n        return callback(toArray(packet.data));\n    }\n    encodePacket(packet, false, (encoded) => {\n        if (!TEXT_ENCODER) {\n            TEXT_ENCODER = new TextEncoder();\n        }\n        callback(TEXT_ENCODER.encode(encoded));\n    });\n}\nexport { encodePacket };\n","// imported from https://github.com/socketio/base64-arraybuffer\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nconst lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (let i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nexport const encode = (arraybuffer) => {\n    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nexport const decode = (base64) => {\n    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n","import { ERROR_PACKET, PACKET_TYPES_REVERSE, } from \"./commons.js\";\nimport { decode } from \"./contrib/base64-arraybuffer.js\";\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nexport const decodePacket = (encodedPacket, binaryType) => {\n    if (typeof encodedPacket !== \"string\") {\n        return {\n            type: \"message\",\n            data: mapBinary(encodedPacket, binaryType),\n        };\n    }\n    const type = encodedPacket.charAt(0);\n    if (type === \"b\") {\n        return {\n            type: \"message\",\n            data: decodeBase64Packet(encodedPacket.substring(1), binaryType),\n        };\n    }\n    const packetType = PACKET_TYPES_REVERSE[type];\n    if (!packetType) {\n        return ERROR_PACKET;\n    }\n    return encodedPacket.length > 1\n        ? {\n            type: PACKET_TYPES_REVERSE[type],\n            data: encodedPacket.substring(1),\n        }\n        : {\n            type: PACKET_TYPES_REVERSE[type],\n        };\n};\nconst decodeBase64Packet = (data, binaryType) => {\n    if (withNativeArrayBuffer) {\n        const decoded = decode(data);\n        return mapBinary(decoded, binaryType);\n    }\n    else {\n        return { base64: true, data }; // fallback for old browsers\n    }\n};\nconst mapBinary = (data, binaryType) => {\n    switch (binaryType) {\n        case \"blob\":\n            if (data instanceof Blob) {\n                // from WebSocket + binaryType \"blob\"\n                return data;\n            }\n            else {\n                // from HTTP long-polling or WebTransport\n                return new Blob([data]);\n            }\n        case \"arraybuffer\":\n        default:\n            if (data instanceof ArrayBuffer) {\n                // from HTTP long-polling (base64) or WebSocket + binaryType \"arraybuffer\"\n                return data;\n            }\n            else {\n                // from WebTransport (Uint8Array)\n                return data.buffer;\n            }\n    }\n};\n","import { encodePacket, encodePacketToBinary } from \"./encodePacket.js\";\nimport { decodePacket } from \"./decodePacket.js\";\nimport { ERROR_PACKET, } from \"./commons.js\";\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst encodePayload = (packets, callback) => {\n    // some packets may be added to the array while encoding, so the initial length must be saved\n    const length = packets.length;\n    const encodedPackets = new Array(length);\n    let count = 0;\n    packets.forEach((packet, i) => {\n        // force base64 encoding for binary packets\n        encodePacket(packet, false, (encodedPacket) => {\n            encodedPackets[i] = encodedPacket;\n            if (++count === length) {\n                callback(encodedPackets.join(SEPARATOR));\n            }\n        });\n    });\n};\nconst decodePayload = (encodedPayload, binaryType) => {\n    const encodedPackets = encodedPayload.split(SEPARATOR);\n    const packets = [];\n    for (let i = 0; i < encodedPackets.length; i++) {\n        const decodedPacket = decodePacket(encodedPackets[i], binaryType);\n        packets.push(decodedPacket);\n        if (decodedPacket.type === \"error\") {\n            break;\n        }\n    }\n    return packets;\n};\nexport function createPacketEncoderStream() {\n    return new TransformStream({\n        transform(packet, controller) {\n            encodePacketToBinary(packet, (encodedPacket) => {\n                const payloadLength = encodedPacket.length;\n                let header;\n                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length\n                if (payloadLength < 126) {\n                    header = new Uint8Array(1);\n                    new DataView(header.buffer).setUint8(0, payloadLength);\n                }\n                else if (payloadLength < 65536) {\n                    header = new Uint8Array(3);\n                    const view = new DataView(header.buffer);\n                    view.setUint8(0, 126);\n                    view.setUint16(1, payloadLength);\n                }\n                else {\n                    header = new Uint8Array(9);\n                    const view = new DataView(header.buffer);\n                    view.setUint8(0, 127);\n                    view.setBigUint64(1, BigInt(payloadLength));\n                }\n                // first bit indicates whether the payload is plain text (0) or binary (1)\n                if (packet.data && typeof packet.data !== \"string\") {\n                    header[0] |= 0x80;\n                }\n                controller.enqueue(header);\n                controller.enqueue(encodedPacket);\n            });\n        },\n    });\n}\nlet TEXT_DECODER;\nfunction totalLength(chunks) {\n    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);\n}\nfunction concatChunks(chunks, size) {\n    if (chunks[0].length === size) {\n        return chunks.shift();\n    }\n    const buffer = new Uint8Array(size);\n    let j = 0;\n    for (let i = 0; i < size; i++) {\n        buffer[i] = chunks[0][j++];\n        if (j === chunks[0].length) {\n            chunks.shift();\n            j = 0;\n        }\n    }\n    if (chunks.length && j < chunks[0].length) {\n        chunks[0] = chunks[0].slice(j);\n    }\n    return buffer;\n}\nexport function createPacketDecoderStream(maxPayload, binaryType) {\n    if (!TEXT_DECODER) {\n        TEXT_DECODER = new TextDecoder();\n    }\n    const chunks = [];\n    let state = 0 /* State.READ_HEADER */;\n    let expectedLength = -1;\n    let isBinary = false;\n    return new TransformStream({\n        transform(chunk, controller) {\n            chunks.push(chunk);\n            while (true) {\n                if (state === 0 /* State.READ_HEADER */) {\n                    if (totalLength(chunks) < 1) {\n                        break;\n                    }\n                    const header = concatChunks(chunks, 1);\n                    isBinary = (header[0] & 0x80) === 0x80;\n                    expectedLength = header[0] & 0x7f;\n                    if (expectedLength < 126) {\n                        state = 3 /* State.READ_PAYLOAD */;\n                    }\n                    else if (expectedLength === 126) {\n                        state = 1 /* State.READ_EXTENDED_LENGTH_16 */;\n                    }\n                    else {\n                        state = 2 /* State.READ_EXTENDED_LENGTH_64 */;\n                    }\n                }\n                else if (state === 1 /* State.READ_EXTENDED_LENGTH_16 */) {\n                    if (totalLength(chunks) < 2) {\n                        break;\n                    }\n                    const headerArray = concatChunks(chunks, 2);\n                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);\n                    state = 3 /* State.READ_PAYLOAD */;\n                }\n                else if (state === 2 /* State.READ_EXTENDED_LENGTH_64 */) {\n                    if (totalLength(chunks) < 8) {\n                        break;\n                    }\n                    const headerArray = concatChunks(chunks, 8);\n                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);\n                    const n = view.getUint32(0);\n                    if (n > Math.pow(2, 53 - 32) - 1) {\n                        // the maximum safe integer in JavaScript is 2^53 - 1\n                        controller.enqueue(ERROR_PACKET);\n                        break;\n                    }\n                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);\n                    state = 3 /* State.READ_PAYLOAD */;\n                }\n                else {\n                    if (totalLength(chunks) < expectedLength) {\n                        break;\n                    }\n                    const data = concatChunks(chunks, expectedLength);\n                    controller.enqueue(decodePacket(isBinary ? data : TEXT_DECODER.decode(data), binaryType));\n                    state = 0 /* State.READ_HEADER */;\n                }\n                if (expectedLength === 0 || expectedLength > maxPayload) {\n                    controller.enqueue(ERROR_PACKET);\n                    break;\n                }\n            }\n        },\n    });\n}\nexport const protocol = 4;\nexport { encodePacket, encodePayload, decodePacket, decodePayload, };\n","/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nexport function Emitter(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks['$' + event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks['$' + event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n\n  // Remove event specific arrays for event types that no\n  // one is subscribed for to avoid memory leak.\n  if (callbacks.length === 0) {\n    delete this._callbacks['$' + event];\n  }\n\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n\n  var args = new Array(arguments.length - 1)\n    , callbacks = this._callbacks['$' + event];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args[i - 1] = arguments[i];\n  }\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n// alias used for reserved events (protected method)\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks['$' + event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n","export const nextTick = (() => {\n    const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n    if (isPromiseAvailable) {\n        return (cb) => Promise.resolve().then(cb);\n    }\n    else {\n        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\n    }\n})();\nexport const globalThisShim = (() => {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    else if (typeof window !== \"undefined\") {\n        return window;\n    }\n    else {\n        return Function(\"return this\")();\n    }\n})();\nexport const defaultBinaryType = \"arraybuffer\";\nexport function createCookieJar() { }\n","import { globalThisShim as globalThis } from \"./globals.node.js\";\nexport function pick(obj, ...attr) {\n    return attr.reduce((acc, k) => {\n        if (obj.hasOwnProperty(k)) {\n            acc[k] = obj[k];\n        }\n        return acc;\n    }, {});\n}\n// Keep a reference to the real timeout functions so they can be used when overridden\nconst NATIVE_SET_TIMEOUT = globalThis.setTimeout;\nconst NATIVE_CLEAR_TIMEOUT = globalThis.clearTimeout;\nexport function installTimerFunctions(obj, opts) {\n    if (opts.useNativeTimers) {\n        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis);\n        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis);\n    }\n    else {\n        obj.setTimeoutFn = globalThis.setTimeout.bind(globalThis);\n        obj.clearTimeoutFn = globalThis.clearTimeout.bind(globalThis);\n    }\n}\n// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)\nconst BASE64_OVERHEAD = 1.33;\n// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9\nexport function byteLength(obj) {\n    if (typeof obj === \"string\") {\n        return utf8Length(obj);\n    }\n    // arraybuffer or blob\n    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);\n}\nfunction utf8Length(str) {\n    let c = 0, length = 0;\n    for (let i = 0, l = str.length; i < l; i++) {\n        c = str.charCodeAt(i);\n        if (c < 0x80) {\n            length += 1;\n        }\n        else if (c < 0x800) {\n            length += 2;\n        }\n        else if (c < 0xd800 || c >= 0xe000) {\n            length += 3;\n        }\n        else {\n            i++;\n            length += 4;\n        }\n    }\n    return length;\n}\n/**\n * Generates a random 8-characters string.\n */\nexport function randomString() {\n    return (Date.now().toString(36).substring(3) +\n        Math.random().toString(36).substring(2, 5));\n}\n","// imported from https://github.com/galkn/querystring\n/**\n * Compiles a querystring\n * Returns string representation of the object\n *\n * @param {Object}\n * @api private\n */\nexport function encode(obj) {\n    let str = '';\n    for (let i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            if (str.length)\n                str += '&';\n            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n        }\n    }\n    return str;\n}\n/**\n * Parses a simple querystring into an object\n *\n * @param {String} qs\n * @api private\n */\nexport function decode(qs) {\n    let qry = {};\n    let pairs = qs.split('&');\n    for (let i = 0, l = pairs.length; i < l; i++) {\n        let pair = pairs[i].split('=');\n        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n    }\n    return qry;\n}\n","import { decodePacket } from \"engine.io-parser\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport { installTimerFunctions } from \"./util.js\";\nimport { encode } from \"./contrib/parseqs.js\";\nexport class TransportError extends Error {\n    constructor(reason, description, context) {\n        super(reason);\n        this.description = description;\n        this.context = context;\n        this.type = \"TransportError\";\n    }\n}\nexport class Transport extends Emitter {\n    /**\n     * Transport abstract constructor.\n     *\n     * @param {Object} opts - options\n     * @protected\n     */\n    constructor(opts) {\n        super();\n        this.writable = false;\n        installTimerFunctions(this, opts);\n        this.opts = opts;\n        this.query = opts.query;\n        this.socket = opts.socket;\n        this.supportsBinary = !opts.forceBase64;\n    }\n    /**\n     * Emits an error.\n     *\n     * @param {String} reason\n     * @param description\n     * @param context - the error context\n     * @return {Transport} for chaining\n     * @protected\n     */\n    onError(reason, description, context) {\n        super.emitReserved(\"error\", new TransportError(reason, description, context));\n        return this;\n    }\n    /**\n     * Opens the transport.\n     */\n    open() {\n        this.readyState = \"opening\";\n        this.doOpen();\n        return this;\n    }\n    /**\n     * Closes the transport.\n     */\n    close() {\n        if (this.readyState === \"opening\" || this.readyState === \"open\") {\n            this.doClose();\n            this.onClose();\n        }\n        return this;\n    }\n    /**\n     * Sends multiple packets.\n     *\n     * @param {Array} packets\n     */\n    send(packets) {\n        if (this.readyState === \"open\") {\n            this.write(packets);\n        }\n        else {\n            // this might happen if the transport was silently closed in the beforeunload event handler\n        }\n    }\n    /**\n     * Called upon open\n     *\n     * @protected\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        this.writable = true;\n        super.emitReserved(\"open\");\n    }\n    /**\n     * Called with data.\n     *\n     * @param {String} data\n     * @protected\n     */\n    onData(data) {\n        const packet = decodePacket(data, this.socket.binaryType);\n        this.onPacket(packet);\n    }\n    /**\n     * Called with a decoded packet.\n     *\n     * @protected\n     */\n    onPacket(packet) {\n        super.emitReserved(\"packet\", packet);\n    }\n    /**\n     * Called upon close.\n     *\n     * @protected\n     */\n    onClose(details) {\n        this.readyState = \"closed\";\n        super.emitReserved(\"close\", details);\n    }\n    /**\n     * Pauses the transport, in order not to lose packets during an upgrade.\n     *\n     * @param onPause\n     */\n    pause(onPause) { }\n    createUri(schema, query = {}) {\n        return (schema +\n            \"://\" +\n            this._hostname() +\n            this._port() +\n            this.opts.path +\n            this._query(query));\n    }\n    _hostname() {\n        const hostname = this.opts.hostname;\n        return hostname.indexOf(\":\") === -1 ? hostname : \"[\" + hostname + \"]\";\n    }\n    _port() {\n        if (this.opts.port &&\n            ((this.opts.secure && Number(this.opts.port !== 443)) ||\n                (!this.opts.secure && Number(this.opts.port) !== 80))) {\n            return \":\" + this.opts.port;\n        }\n        else {\n            return \"\";\n        }\n    }\n    _query(query) {\n        const encodedQuery = encode(query);\n        return encodedQuery.length ? \"?\" + encodedQuery : \"\";\n    }\n}\n","import { Transport } from \"../transport.js\";\nimport { randomString } from \"../util.js\";\nimport { encodePayload, decodePayload } from \"engine.io-parser\";\nexport class Polling extends Transport {\n    constructor() {\n        super(...arguments);\n        this._polling = false;\n    }\n    get name() {\n        return \"polling\";\n    }\n    /**\n     * Opens the socket (triggers polling). We write a PING message to determine\n     * when the transport is open.\n     *\n     * @protected\n     */\n    doOpen() {\n        this._poll();\n    }\n    /**\n     * Pauses polling.\n     *\n     * @param {Function} onPause - callback upon buffers are flushed and transport is paused\n     * @package\n     */\n    pause(onPause) {\n        this.readyState = \"pausing\";\n        const pause = () => {\n            this.readyState = \"paused\";\n            onPause();\n        };\n        if (this._polling || !this.writable) {\n            let total = 0;\n            if (this._polling) {\n                total++;\n                this.once(\"pollComplete\", function () {\n                    --total || pause();\n                });\n            }\n            if (!this.writable) {\n                total++;\n                this.once(\"drain\", function () {\n                    --total || pause();\n                });\n            }\n        }\n        else {\n            pause();\n        }\n    }\n    /**\n     * Starts polling cycle.\n     *\n     * @private\n     */\n    _poll() {\n        this._polling = true;\n        this.doPoll();\n        this.emitReserved(\"poll\");\n    }\n    /**\n     * Overloads onData to detect payloads.\n     *\n     * @protected\n     */\n    onData(data) {\n        const callback = (packet) => {\n            // if its the first message we consider the transport open\n            if (\"opening\" === this.readyState && packet.type === \"open\") {\n                this.onOpen();\n            }\n            // if its a close packet, we close the ongoing requests\n            if (\"close\" === packet.type) {\n                this.onClose({ description: \"transport closed by the server\" });\n                return false;\n            }\n            // otherwise bypass onData and handle the message\n            this.onPacket(packet);\n        };\n        // decode payload\n        decodePayload(data, this.socket.binaryType).forEach(callback);\n        // if an event did not trigger closing\n        if (\"closed\" !== this.readyState) {\n            // if we got data we're not polling\n            this._polling = false;\n            this.emitReserved(\"pollComplete\");\n            if (\"open\" === this.readyState) {\n                this._poll();\n            }\n            else {\n            }\n        }\n    }\n    /**\n     * For polling, send a close packet.\n     *\n     * @protected\n     */\n    doClose() {\n        const close = () => {\n            this.write([{ type: \"close\" }]);\n        };\n        if (\"open\" === this.readyState) {\n            close();\n        }\n        else {\n            // in case we're trying to close while\n            // handshaking is in progress (GH-164)\n            this.once(\"open\", close);\n        }\n    }\n    /**\n     * Writes a packets payload.\n     *\n     * @param {Array} packets - data packets\n     * @protected\n     */\n    write(packets) {\n        this.writable = false;\n        encodePayload(packets, (data) => {\n            this.doWrite(data, () => {\n                this.writable = true;\n                this.emitReserved(\"drain\");\n            });\n        });\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */\n    uri() {\n        const schema = this.opts.secure ? \"https\" : \"http\";\n        const query = this.query || {};\n        // cache busting is forced\n        if (false !== this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = randomString();\n        }\n        if (!this.supportsBinary && !query.sid) {\n            query.b64 = 1;\n        }\n        return this.createUri(schema, query);\n    }\n}\n","// imported from https://github.com/component/has-cors\nlet value = false;\ntry {\n    value = typeof XMLHttpRequest !== 'undefined' &&\n        'withCredentials' in new XMLHttpRequest();\n}\ncatch (err) {\n    // if XMLHttp support is disabled in IE then it will throw\n    // when trying to create\n}\nexport const hasCORS = value;\n","import { Polling } from \"./polling.js\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport { installTimerFunctions, pick } from \"../util.js\";\nimport { globalThisShim as globalThis } from \"../globals.node.js\";\nimport { hasCORS } from \"../contrib/has-cors.js\";\nfunction empty() { }\nexport class BaseXHR extends Polling {\n    /**\n     * XHR Polling constructor.\n     *\n     * @param {Object} opts\n     * @package\n     */\n    constructor(opts) {\n        super(opts);\n        if (typeof location !== \"undefined\") {\n            const isSSL = \"https:\" === location.protocol;\n            let port = location.port;\n            // some user agents have empty `location.port`\n            if (!port) {\n                port = isSSL ? \"443\" : \"80\";\n            }\n            this.xd =\n                (typeof location !== \"undefined\" &&\n                    opts.hostname !== location.hostname) ||\n                    port !== opts.port;\n        }\n    }\n    /**\n     * Sends data.\n     *\n     * @param {String} data to send.\n     * @param {Function} called upon flush.\n     * @private\n     */\n    doWrite(data, fn) {\n        const req = this.request({\n            method: \"POST\",\n            data: data,\n        });\n        req.on(\"success\", fn);\n        req.on(\"error\", (xhrStatus, context) => {\n            this.onError(\"xhr post error\", xhrStatus, context);\n        });\n    }\n    /**\n     * Starts a poll cycle.\n     *\n     * @private\n     */\n    doPoll() {\n        const req = this.request();\n        req.on(\"data\", this.onData.bind(this));\n        req.on(\"error\", (xhrStatus, context) => {\n            this.onError(\"xhr poll error\", xhrStatus, context);\n        });\n        this.pollXhr = req;\n    }\n}\nexport class Request extends Emitter {\n    /**\n     * Request constructor\n     *\n     * @param {Object} options\n     * @package\n     */\n    constructor(createRequest, uri, opts) {\n        super();\n        this.createRequest = createRequest;\n        installTimerFunctions(this, opts);\n        this._opts = opts;\n        this._method = opts.method || \"GET\";\n        this._uri = uri;\n        this._data = undefined !== opts.data ? opts.data : null;\n        this._create();\n    }\n    /**\n     * Creates the XHR object and sends the request.\n     *\n     * @private\n     */\n    _create() {\n        var _a;\n        const opts = pick(this._opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n        opts.xdomain = !!this._opts.xd;\n        const xhr = (this._xhr = this.createRequest(opts));\n        try {\n            xhr.open(this._method, this._uri, true);\n            try {\n                if (this._opts.extraHeaders) {\n                    // @ts-ignore\n                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                    for (let i in this._opts.extraHeaders) {\n                        if (this._opts.extraHeaders.hasOwnProperty(i)) {\n                            xhr.setRequestHeader(i, this._opts.extraHeaders[i]);\n                        }\n                    }\n                }\n            }\n            catch (e) { }\n            if (\"POST\" === this._method) {\n                try {\n                    xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                }\n                catch (e) { }\n            }\n            try {\n                xhr.setRequestHeader(\"Accept\", \"*/*\");\n            }\n            catch (e) { }\n            (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);\n            // ie6 check\n            if (\"withCredentials\" in xhr) {\n                xhr.withCredentials = this._opts.withCredentials;\n            }\n            if (this._opts.requestTimeout) {\n                xhr.timeout = this._opts.requestTimeout;\n            }\n            xhr.onreadystatechange = () => {\n                var _a;\n                if (xhr.readyState === 3) {\n                    (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(\n                    // @ts-ignore\n                    xhr.getResponseHeader(\"set-cookie\"));\n                }\n                if (4 !== xhr.readyState)\n                    return;\n                if (200 === xhr.status || 1223 === xhr.status) {\n                    this._onLoad();\n                }\n                else {\n                    // make sure the `error` event handler that's user-set\n                    // does not throw in the same tick and gets caught here\n                    this.setTimeoutFn(() => {\n                        this._onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                    }, 0);\n                }\n            };\n            xhr.send(this._data);\n        }\n        catch (e) {\n            // Need to defer since .create() is called directly from the constructor\n            // and thus the 'error' event can only be only bound *after* this exception\n            // occurs.  Therefore, also, we cannot throw here at all.\n            this.setTimeoutFn(() => {\n                this._onError(e);\n            }, 0);\n            return;\n        }\n        if (typeof document !== \"undefined\") {\n            this._index = Request.requestsCount++;\n            Request.requests[this._index] = this;\n        }\n    }\n    /**\n     * Called upon error.\n     *\n     * @private\n     */\n    _onError(err) {\n        this.emitReserved(\"error\", err, this._xhr);\n        this._cleanup(true);\n    }\n    /**\n     * Cleans up house.\n     *\n     * @private\n     */\n    _cleanup(fromError) {\n        if (\"undefined\" === typeof this._xhr || null === this._xhr) {\n            return;\n        }\n        this._xhr.onreadystatechange = empty;\n        if (fromError) {\n            try {\n                this._xhr.abort();\n            }\n            catch (e) { }\n        }\n        if (typeof document !== \"undefined\") {\n            delete Request.requests[this._index];\n        }\n        this._xhr = null;\n    }\n    /**\n     * Called upon load.\n     *\n     * @private\n     */\n    _onLoad() {\n        const data = this._xhr.responseText;\n        if (data !== null) {\n            this.emitReserved(\"data\", data);\n            this.emitReserved(\"success\");\n            this._cleanup();\n        }\n    }\n    /**\n     * Aborts the request.\n     *\n     * @package\n     */\n    abort() {\n        this._cleanup();\n    }\n}\nRequest.requestsCount = 0;\nRequest.requests = {};\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\nif (typeof document !== \"undefined\") {\n    // @ts-ignore\n    if (typeof attachEvent === \"function\") {\n        // @ts-ignore\n        attachEvent(\"onunload\", unloadHandler);\n    }\n    else if (typeof addEventListener === \"function\") {\n        const terminationEvent = \"onpagehide\" in globalThis ? \"pagehide\" : \"unload\";\n        addEventListener(terminationEvent, unloadHandler, false);\n    }\n}\nfunction unloadHandler() {\n    for (let i in Request.requests) {\n        if (Request.requests.hasOwnProperty(i)) {\n            Request.requests[i].abort();\n        }\n    }\n}\nconst hasXHR2 = (function () {\n    const xhr = newRequest({\n        xdomain: false,\n    });\n    return xhr && xhr.responseType !== null;\n})();\n/**\n * HTTP long-polling based on the built-in `XMLHttpRequest` object.\n *\n * Usage: browser\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n */\nexport class XHR extends BaseXHR {\n    constructor(opts) {\n        super(opts);\n        const forceBase64 = opts && opts.forceBase64;\n        this.supportsBinary = hasXHR2 && !forceBase64;\n    }\n    request(opts = {}) {\n        Object.assign(opts, { xd: this.xd }, this.opts);\n        return new Request(newRequest, this.uri(), opts);\n    }\n}\nfunction newRequest(opts) {\n    const xdomain = opts.xdomain;\n    // XMLHttpRequest can be disabled on IE\n    try {\n        if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n            return new XMLHttpRequest();\n        }\n    }\n    catch (e) { }\n    if (!xdomain) {\n        try {\n            return new globalThis[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n        }\n        catch (e) { }\n    }\n}\n","import { Transport } from \"../transport.js\";\nimport { pick, randomString } from \"../util.js\";\nimport { encodePacket } from \"engine.io-parser\";\nimport { globalThisShim as globalThis, nextTick } from \"../globals.node.js\";\n// detect ReactNative environment\nconst isReactNative = typeof navigator !== \"undefined\" &&\n    typeof navigator.product === \"string\" &&\n    navigator.product.toLowerCase() === \"reactnative\";\nexport class BaseWS extends Transport {\n    get name() {\n        return \"websocket\";\n    }\n    doOpen() {\n        const uri = this.uri();\n        const protocols = this.opts.protocols;\n        // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n        const opts = isReactNative\n            ? {}\n            : pick(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n        if (this.opts.extraHeaders) {\n            opts.headers = this.opts.extraHeaders;\n        }\n        try {\n            this.ws = this.createSocket(uri, protocols, opts);\n        }\n        catch (err) {\n            return this.emitReserved(\"error\", err);\n        }\n        this.ws.binaryType = this.socket.binaryType;\n        this.addEventListeners();\n    }\n    /**\n     * Adds event listeners to the socket\n     *\n     * @private\n     */\n    addEventListeners() {\n        this.ws.onopen = () => {\n            if (this.opts.autoUnref) {\n                this.ws._socket.unref();\n            }\n            this.onOpen();\n        };\n        this.ws.onclose = (closeEvent) => this.onClose({\n            description: \"websocket connection closed\",\n            context: closeEvent,\n        });\n        this.ws.onmessage = (ev) => this.onData(ev.data);\n        this.ws.onerror = (e) => this.onError(\"websocket error\", e);\n    }\n    write(packets) {\n        this.writable = false;\n        // encodePacket efficient as it uses WS framing\n        // no need for encodePayload\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            encodePacket(packet, this.supportsBinary, (data) => {\n                // Sometimes the websocket has already been closed but the browser didn't\n                // have a chance of informing us about it yet, in that case send will\n                // throw an error\n                try {\n                    this.doWrite(packet, data);\n                }\n                catch (e) {\n                }\n                if (lastPacket) {\n                    // fake drain\n                    // defer to next tick to allow Socket to clear writeBuffer\n                    nextTick(() => {\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    doClose() {\n        if (typeof this.ws !== \"undefined\") {\n            this.ws.onerror = () => { };\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */\n    uri() {\n        const schema = this.opts.secure ? \"wss\" : \"ws\";\n        const query = this.query || {};\n        // append timestamp to URI\n        if (this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = randomString();\n        }\n        // communicate binary support capabilities\n        if (!this.supportsBinary) {\n            query.b64 = 1;\n        }\n        return this.createUri(schema, query);\n    }\n}\nconst WebSocketCtor = globalThis.WebSocket || globalThis.MozWebSocket;\n/**\n * WebSocket transport based on the built-in `WebSocket` object.\n *\n * Usage: browser, Node.js (since v21), Deno, Bun\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n * @see https://caniuse.com/mdn-api_websocket\n * @see https://nodejs.org/api/globals.html#websocket\n */\nexport class WS extends BaseWS {\n    createSocket(uri, protocols, opts) {\n        return !isReactNative\n            ? protocols\n                ? new WebSocketCtor(uri, protocols)\n                : new WebSocketCtor(uri)\n            : new WebSocketCtor(uri, protocols, opts);\n    }\n    doWrite(_packet, data) {\n        this.ws.send(data);\n    }\n}\n","import { Transport } from \"../transport.js\";\nimport { nextTick } from \"../globals.node.js\";\nimport { createPacketDecoderStream, createPacketEncoderStream, } from \"engine.io-parser\";\n/**\n * WebTransport transport based on the built-in `WebTransport` object.\n *\n * Usage: browser, Node.js (with the `@fails-components/webtransport` package)\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebTransport\n * @see https://caniuse.com/webtransport\n */\nexport class WT extends Transport {\n    get name() {\n        return \"webtransport\";\n    }\n    doOpen() {\n        try {\n            // @ts-ignore\n            this._transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\n        }\n        catch (err) {\n            return this.emitReserved(\"error\", err);\n        }\n        this._transport.closed\n            .then(() => {\n            this.onClose();\n        })\n            .catch((err) => {\n            this.onError(\"webtransport error\", err);\n        });\n        // note: we could have used async/await, but that would require some additional polyfills\n        this._transport.ready.then(() => {\n            this._transport.createBidirectionalStream().then((stream) => {\n                const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);\n                const reader = stream.readable.pipeThrough(decoderStream).getReader();\n                const encoderStream = createPacketEncoderStream();\n                encoderStream.readable.pipeTo(stream.writable);\n                this._writer = encoderStream.writable.getWriter();\n                const read = () => {\n                    reader\n                        .read()\n                        .then(({ done, value }) => {\n                        if (done) {\n                            return;\n                        }\n                        this.onPacket(value);\n                        read();\n                    })\n                        .catch((err) => {\n                    });\n                };\n                read();\n                const packet = { type: \"open\" };\n                if (this.query.sid) {\n                    packet.data = `{\"sid\":\"${this.query.sid}\"}`;\n                }\n                this._writer.write(packet).then(() => this.onOpen());\n            });\n        });\n    }\n    write(packets) {\n        this.writable = false;\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            this._writer.write(packet).then(() => {\n                if (lastPacket) {\n                    nextTick(() => {\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    doClose() {\n        var _a;\n        (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();\n    }\n}\n","import { XHR } from \"./polling-xhr.node.js\";\nimport { WS } from \"./websocket.node.js\";\nimport { WT } from \"./webtransport.js\";\nexport const transports = {\n    websocket: WS,\n    webtransport: WT,\n    polling: XHR,\n};\n","// imported from https://github.com/galkn/parseuri\n/**\n * Parses a URI\n *\n * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.\n *\n * See:\n * - https://developer.mozilla.org/en-US/docs/Web/API/URL\n * - https://caniuse.com/url\n * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B\n *\n * History of the parse() method:\n * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c\n * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3\n * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\nconst re = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nconst parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\nexport function parse(str) {\n    if (str.length > 8000) {\n        throw \"URI too long\";\n    }\n    const src = str, b = str.indexOf('['), e = str.indexOf(']');\n    if (b != -1 && e != -1) {\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n    }\n    let m = re.exec(str || ''), uri = {}, i = 14;\n    while (i--) {\n        uri[parts[i]] = m[i] || '';\n    }\n    if (b != -1 && e != -1) {\n        uri.source = src;\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n        uri.ipv6uri = true;\n    }\n    uri.pathNames = pathNames(uri, uri['path']);\n    uri.queryKey = queryKey(uri, uri['query']);\n    return uri;\n}\nfunction pathNames(obj, path) {\n    const regx = /\\/{2,9}/g, names = path.replace(regx, \"/\").split(\"/\");\n    if (path.slice(0, 1) == '/' || path.length === 0) {\n        names.splice(0, 1);\n    }\n    if (path.slice(-1) == '/') {\n        names.splice(names.length - 1, 1);\n    }\n    return names;\n}\nfunction queryKey(uri, query) {\n    const data = {};\n    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {\n        if ($1) {\n            data[$1] = $2;\n        }\n    });\n    return data;\n}\n","import { transports as DEFAULT_TRANSPORTS } from \"./transports/index.js\";\nimport { installTimerFunctions, byteLength } from \"./util.js\";\nimport { decode } from \"./contrib/parseqs.js\";\nimport { parse } from \"./contrib/parseuri.js\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport { protocol } from \"engine.io-parser\";\nimport { createCookieJar, defaultBinaryType, nextTick, } from \"./globals.node.js\";\nconst withEventListeners = typeof addEventListener === \"function\" &&\n    typeof removeEventListener === \"function\";\nconst OFFLINE_EVENT_LISTENERS = [];\nif (withEventListeners) {\n    // within a ServiceWorker, any event handler for the 'offline' event must be added on the initial evaluation of the\n    // script, so we create one single event listener here which will forward the event to the socket instances\n    addEventListener(\"offline\", () => {\n        OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());\n    }, false);\n}\n/**\n * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established\n * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.\n *\n * This class comes without upgrade mechanism, which means that it will keep the first low-level transport that\n * successfully establishes the connection.\n *\n * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.\n *\n * @example\n * import { SocketWithoutUpgrade, WebSocket } from \"engine.io-client\";\n *\n * const socket = new SocketWithoutUpgrade({\n *   transports: [WebSocket]\n * });\n *\n * socket.on(\"open\", () => {\n *   socket.send(\"hello\");\n * });\n *\n * @see SocketWithUpgrade\n * @see Socket\n */\nexport class SocketWithoutUpgrade extends Emitter {\n    /**\n     * Socket constructor.\n     *\n     * @param {String|Object} uri - uri or options\n     * @param {Object} opts - options\n     */\n    constructor(uri, opts) {\n        super();\n        this.binaryType = defaultBinaryType;\n        this.writeBuffer = [];\n        this._prevBufferLen = 0;\n        this._pingInterval = -1;\n        this._pingTimeout = -1;\n        this._maxPayload = -1;\n        /**\n         * The expiration timestamp of the {@link _pingTimeoutTimer} object is tracked, in case the timer is throttled and the\n         * callback is not fired on time. This can happen for example when a laptop is suspended or when a phone is locked.\n         */\n        this._pingTimeoutTime = Infinity;\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = null;\n        }\n        if (uri) {\n            const parsedUri = parse(uri);\n            opts.hostname = parsedUri.host;\n            opts.secure =\n                parsedUri.protocol === \"https\" || parsedUri.protocol === \"wss\";\n            opts.port = parsedUri.port;\n            if (parsedUri.query)\n                opts.query = parsedUri.query;\n        }\n        else if (opts.host) {\n            opts.hostname = parse(opts.host).host;\n        }\n        installTimerFunctions(this, opts);\n        this.secure =\n            null != opts.secure\n                ? opts.secure\n                : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n        if (opts.hostname && !opts.port) {\n            // if no port is specified manually, use the protocol default\n            opts.port = this.secure ? \"443\" : \"80\";\n        }\n        this.hostname =\n            opts.hostname ||\n                (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n        this.port =\n            opts.port ||\n                (typeof location !== \"undefined\" && location.port\n                    ? location.port\n                    : this.secure\n                        ? \"443\"\n                        : \"80\");\n        this.transports = [];\n        this._transportsByName = {};\n        opts.transports.forEach((t) => {\n            const transportName = t.prototype.name;\n            this.transports.push(transportName);\n            this._transportsByName[transportName] = t;\n        });\n        this.opts = Object.assign({\n            path: \"/engine.io\",\n            agent: false,\n            withCredentials: false,\n            upgrade: true,\n            timestampParam: \"t\",\n            rememberUpgrade: false,\n            addTrailingSlash: true,\n            rejectUnauthorized: true,\n            perMessageDeflate: {\n                threshold: 1024,\n            },\n            transportOptions: {},\n            closeOnBeforeunload: false,\n        }, opts);\n        this.opts.path =\n            this.opts.path.replace(/\\/$/, \"\") +\n                (this.opts.addTrailingSlash ? \"/\" : \"\");\n        if (typeof this.opts.query === \"string\") {\n            this.opts.query = decode(this.opts.query);\n        }\n        if (withEventListeners) {\n            if (this.opts.closeOnBeforeunload) {\n                // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n                // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n                // closed/reloaded)\n                this._beforeunloadEventListener = () => {\n                    if (this.transport) {\n                        // silently close the transport\n                        this.transport.removeAllListeners();\n                        this.transport.close();\n                    }\n                };\n                addEventListener(\"beforeunload\", this._beforeunloadEventListener, false);\n            }\n            if (this.hostname !== \"localhost\") {\n                this._offlineEventListener = () => {\n                    this._onClose(\"transport close\", {\n                        description: \"network connection lost\",\n                    });\n                };\n                OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);\n            }\n        }\n        if (this.opts.withCredentials) {\n            this._cookieJar = createCookieJar();\n        }\n        this._open();\n    }\n    /**\n     * Creates transport of the given type.\n     *\n     * @param {String} name - transport name\n     * @return {Transport}\n     * @private\n     */\n    createTransport(name) {\n        const query = Object.assign({}, this.opts.query);\n        // append engine.io protocol identifier\n        query.EIO = protocol;\n        // transport name\n        query.transport = name;\n        // session id if we already have one\n        if (this.id)\n            query.sid = this.id;\n        const opts = Object.assign({}, this.opts, {\n            query,\n            socket: this,\n            hostname: this.hostname,\n            secure: this.secure,\n            port: this.port,\n        }, this.opts.transportOptions[name]);\n        return new this._transportsByName[name](opts);\n    }\n    /**\n     * Initializes transport to use and starts probe.\n     *\n     * @private\n     */\n    _open() {\n        if (this.transports.length === 0) {\n            // Emit error on next tick so it can be listened to\n            this.setTimeoutFn(() => {\n                this.emitReserved(\"error\", \"No transports available\");\n            }, 0);\n            return;\n        }\n        const transportName = this.opts.rememberUpgrade &&\n            SocketWithoutUpgrade.priorWebsocketSuccess &&\n            this.transports.indexOf(\"websocket\") !== -1\n            ? \"websocket\"\n            : this.transports[0];\n        this.readyState = \"opening\";\n        const transport = this.createTransport(transportName);\n        transport.open();\n        this.setTransport(transport);\n    }\n    /**\n     * Sets the current transport. Disables the existing one (if any).\n     *\n     * @private\n     */\n    setTransport(transport) {\n        if (this.transport) {\n            this.transport.removeAllListeners();\n        }\n        // set up transport\n        this.transport = transport;\n        // set up transport listeners\n        transport\n            .on(\"drain\", this._onDrain.bind(this))\n            .on(\"packet\", this._onPacket.bind(this))\n            .on(\"error\", this._onError.bind(this))\n            .on(\"close\", (reason) => this._onClose(\"transport close\", reason));\n    }\n    /**\n     * Called when connection is deemed open.\n     *\n     * @private\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        SocketWithoutUpgrade.priorWebsocketSuccess =\n            \"websocket\" === this.transport.name;\n        this.emitReserved(\"open\");\n        this.flush();\n    }\n    /**\n     * Handles a packet.\n     *\n     * @private\n     */\n    _onPacket(packet) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            this.emitReserved(\"packet\", packet);\n            // Socket is live - any packet counts\n            this.emitReserved(\"heartbeat\");\n            switch (packet.type) {\n                case \"open\":\n                    this.onHandshake(JSON.parse(packet.data));\n                    break;\n                case \"ping\":\n                    this._sendPacket(\"pong\");\n                    this.emitReserved(\"ping\");\n                    this.emitReserved(\"pong\");\n                    this._resetPingTimeout();\n                    break;\n                case \"error\":\n                    const err = new Error(\"server error\");\n                    // @ts-ignore\n                    err.code = packet.data;\n                    this._onError(err);\n                    break;\n                case \"message\":\n                    this.emitReserved(\"data\", packet.data);\n                    this.emitReserved(\"message\", packet.data);\n                    break;\n            }\n        }\n        else {\n        }\n    }\n    /**\n     * Called upon handshake completion.\n     *\n     * @param {Object} data - handshake obj\n     * @private\n     */\n    onHandshake(data) {\n        this.emitReserved(\"handshake\", data);\n        this.id = data.sid;\n        this.transport.query.sid = data.sid;\n        this._pingInterval = data.pingInterval;\n        this._pingTimeout = data.pingTimeout;\n        this._maxPayload = data.maxPayload;\n        this.onOpen();\n        // In case open handler closes socket\n        if (\"closed\" === this.readyState)\n            return;\n        this._resetPingTimeout();\n    }\n    /**\n     * Sets and resets ping timeout timer based on server pings.\n     *\n     * @private\n     */\n    _resetPingTimeout() {\n        this.clearTimeoutFn(this._pingTimeoutTimer);\n        const delay = this._pingInterval + this._pingTimeout;\n        this._pingTimeoutTime = Date.now() + delay;\n        this._pingTimeoutTimer = this.setTimeoutFn(() => {\n            this._onClose(\"ping timeout\");\n        }, delay);\n        if (this.opts.autoUnref) {\n            this._pingTimeoutTimer.unref();\n        }\n    }\n    /**\n     * Called on `drain` event\n     *\n     * @private\n     */\n    _onDrain() {\n        this.writeBuffer.splice(0, this._prevBufferLen);\n        // setting prevBufferLen = 0 is very important\n        // for example, when upgrading, upgrade packet is sent over,\n        // and a nonzero prevBufferLen could cause problems on `drain`\n        this._prevBufferLen = 0;\n        if (0 === this.writeBuffer.length) {\n            this.emitReserved(\"drain\");\n        }\n        else {\n            this.flush();\n        }\n    }\n    /**\n     * Flush write buffers.\n     *\n     * @private\n     */\n    flush() {\n        if (\"closed\" !== this.readyState &&\n            this.transport.writable &&\n            !this.upgrading &&\n            this.writeBuffer.length) {\n            const packets = this._getWritablePackets();\n            this.transport.send(packets);\n            // keep track of current length of writeBuffer\n            // splice writeBuffer and callbackBuffer on `drain`\n            this._prevBufferLen = packets.length;\n            this.emitReserved(\"flush\");\n        }\n    }\n    /**\n     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP\n     * long-polling)\n     *\n     * @private\n     */\n    _getWritablePackets() {\n        const shouldCheckPayloadSize = this._maxPayload &&\n            this.transport.name === \"polling\" &&\n            this.writeBuffer.length > 1;\n        if (!shouldCheckPayloadSize) {\n            return this.writeBuffer;\n        }\n        let payloadSize = 1; // first packet type\n        for (let i = 0; i < this.writeBuffer.length; i++) {\n            const data = this.writeBuffer[i].data;\n            if (data) {\n                payloadSize += byteLength(data);\n            }\n            if (i > 0 && payloadSize > this._maxPayload) {\n                return this.writeBuffer.slice(0, i);\n            }\n            payloadSize += 2; // separator + packet type\n        }\n        return this.writeBuffer;\n    }\n    /**\n     * Checks whether the heartbeat timer has expired but the socket has not yet been notified.\n     *\n     * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the\n     * `write()` method then the message would not be buffered by the Socket.IO client.\n     *\n     * @return {boolean}\n     * @private\n     */\n    /* private */ _hasPingExpired() {\n        if (!this._pingTimeoutTime)\n            return true;\n        const hasExpired = Date.now() > this._pingTimeoutTime;\n        if (hasExpired) {\n            this._pingTimeoutTime = 0;\n            nextTick(() => {\n                this._onClose(\"ping timeout\");\n            }, this.setTimeoutFn);\n        }\n        return hasExpired;\n    }\n    /**\n     * Sends a message.\n     *\n     * @param {String} msg - message.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @return {Socket} for chaining.\n     */\n    write(msg, options, fn) {\n        this._sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a message. Alias of {@link Socket#write}.\n     *\n     * @param {String} msg - message.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @return {Socket} for chaining.\n     */\n    send(msg, options, fn) {\n        this._sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} type: packet type.\n     * @param {String} data.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @private\n     */\n    _sendPacket(type, data, options, fn) {\n        if (\"function\" === typeof data) {\n            fn = data;\n            data = undefined;\n        }\n        if (\"function\" === typeof options) {\n            fn = options;\n            options = null;\n        }\n        if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n            return;\n        }\n        options = options || {};\n        options.compress = false !== options.compress;\n        const packet = {\n            type: type,\n            data: data,\n            options: options,\n        };\n        this.emitReserved(\"packetCreate\", packet);\n        this.writeBuffer.push(packet);\n        if (fn)\n            this.once(\"flush\", fn);\n        this.flush();\n    }\n    /**\n     * Closes the connection.\n     */\n    close() {\n        const close = () => {\n            this._onClose(\"forced close\");\n            this.transport.close();\n        };\n        const cleanupAndClose = () => {\n            this.off(\"upgrade\", cleanupAndClose);\n            this.off(\"upgradeError\", cleanupAndClose);\n            close();\n        };\n        const waitForUpgrade = () => {\n            // wait for upgrade to finish since we can't send packets while pausing a transport\n            this.once(\"upgrade\", cleanupAndClose);\n            this.once(\"upgradeError\", cleanupAndClose);\n        };\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n            this.readyState = \"closing\";\n            if (this.writeBuffer.length) {\n                this.once(\"drain\", () => {\n                    if (this.upgrading) {\n                        waitForUpgrade();\n                    }\n                    else {\n                        close();\n                    }\n                });\n            }\n            else if (this.upgrading) {\n                waitForUpgrade();\n            }\n            else {\n                close();\n            }\n        }\n        return this;\n    }\n    /**\n     * Called upon transport error\n     *\n     * @private\n     */\n    _onError(err) {\n        SocketWithoutUpgrade.priorWebsocketSuccess = false;\n        if (this.opts.tryAllTransports &&\n            this.transports.length > 1 &&\n            this.readyState === \"opening\") {\n            this.transports.shift();\n            return this._open();\n        }\n        this.emitReserved(\"error\", err);\n        this._onClose(\"transport error\", err);\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @private\n     */\n    _onClose(reason, description) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            // clear timers\n            this.clearTimeoutFn(this._pingTimeoutTimer);\n            // stop event from firing again for transport\n            this.transport.removeAllListeners(\"close\");\n            // ensure transport won't stay open\n            this.transport.close();\n            // ignore further transport communication\n            this.transport.removeAllListeners();\n            if (withEventListeners) {\n                if (this._beforeunloadEventListener) {\n                    removeEventListener(\"beforeunload\", this._beforeunloadEventListener, false);\n                }\n                if (this._offlineEventListener) {\n                    const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);\n                    if (i !== -1) {\n                        OFFLINE_EVENT_LISTENERS.splice(i, 1);\n                    }\n                }\n            }\n            // set ready state\n            this.readyState = \"closed\";\n            // clear session id\n            this.id = null;\n            // emit close event\n            this.emitReserved(\"close\", reason, description);\n            // clean buffers after, so users can still\n            // grab the buffers on `close` event\n            this.writeBuffer = [];\n            this._prevBufferLen = 0;\n        }\n    }\n}\nSocketWithoutUpgrade.protocol = protocol;\n/**\n * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established\n * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.\n *\n * This class comes with an upgrade mechanism, which means that once the connection is established with the first\n * low-level transport, it will try to upgrade to a better transport.\n *\n * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.\n *\n * @example\n * import { SocketWithUpgrade, WebSocket } from \"engine.io-client\";\n *\n * const socket = new SocketWithUpgrade({\n *   transports: [WebSocket]\n * });\n *\n * socket.on(\"open\", () => {\n *   socket.send(\"hello\");\n * });\n *\n * @see SocketWithoutUpgrade\n * @see Socket\n */\nexport class SocketWithUpgrade extends SocketWithoutUpgrade {\n    constructor() {\n        super(...arguments);\n        this._upgrades = [];\n    }\n    onOpen() {\n        super.onOpen();\n        if (\"open\" === this.readyState && this.opts.upgrade) {\n            for (let i = 0; i < this._upgrades.length; i++) {\n                this._probe(this._upgrades[i]);\n            }\n        }\n    }\n    /**\n     * Probes a transport.\n     *\n     * @param {String} name - transport name\n     * @private\n     */\n    _probe(name) {\n        let transport = this.createTransport(name);\n        let failed = false;\n        SocketWithoutUpgrade.priorWebsocketSuccess = false;\n        const onTransportOpen = () => {\n            if (failed)\n                return;\n            transport.send([{ type: \"ping\", data: \"probe\" }]);\n            transport.once(\"packet\", (msg) => {\n                if (failed)\n                    return;\n                if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                    this.upgrading = true;\n                    this.emitReserved(\"upgrading\", transport);\n                    if (!transport)\n                        return;\n                    SocketWithoutUpgrade.priorWebsocketSuccess =\n                        \"websocket\" === transport.name;\n                    this.transport.pause(() => {\n                        if (failed)\n                            return;\n                        if (\"closed\" === this.readyState)\n                            return;\n                        cleanup();\n                        this.setTransport(transport);\n                        transport.send([{ type: \"upgrade\" }]);\n                        this.emitReserved(\"upgrade\", transport);\n                        transport = null;\n                        this.upgrading = false;\n                        this.flush();\n                    });\n                }\n                else {\n                    const err = new Error(\"probe error\");\n                    // @ts-ignore\n                    err.transport = transport.name;\n                    this.emitReserved(\"upgradeError\", err);\n                }\n            });\n        };\n        function freezeTransport() {\n            if (failed)\n                return;\n            // Any callback called by transport should be ignored since now\n            failed = true;\n            cleanup();\n            transport.close();\n            transport = null;\n        }\n        // Handle any error that happens while probing\n        const onerror = (err) => {\n            const error = new Error(\"probe error: \" + err);\n            // @ts-ignore\n            error.transport = transport.name;\n            freezeTransport();\n            this.emitReserved(\"upgradeError\", error);\n        };\n        function onTransportClose() {\n            onerror(\"transport closed\");\n        }\n        // When the socket is closed while we're probing\n        function onclose() {\n            onerror(\"socket closed\");\n        }\n        // When the socket is upgraded while we're probing\n        function onupgrade(to) {\n            if (transport && to.name !== transport.name) {\n                freezeTransport();\n            }\n        }\n        // Remove all listeners on the transport and on self\n        const cleanup = () => {\n            transport.removeListener(\"open\", onTransportOpen);\n            transport.removeListener(\"error\", onerror);\n            transport.removeListener(\"close\", onTransportClose);\n            this.off(\"close\", onclose);\n            this.off(\"upgrading\", onupgrade);\n        };\n        transport.once(\"open\", onTransportOpen);\n        transport.once(\"error\", onerror);\n        transport.once(\"close\", onTransportClose);\n        this.once(\"close\", onclose);\n        this.once(\"upgrading\", onupgrade);\n        if (this._upgrades.indexOf(\"webtransport\") !== -1 &&\n            name !== \"webtransport\") {\n            // favor WebTransport\n            this.setTimeoutFn(() => {\n                if (!failed) {\n                    transport.open();\n                }\n            }, 200);\n        }\n        else {\n            transport.open();\n        }\n    }\n    onHandshake(data) {\n        this._upgrades = this._filterUpgrades(data.upgrades);\n        super.onHandshake(data);\n    }\n    /**\n     * Filters upgrades, returning only those matching client transports.\n     *\n     * @param {Array} upgrades - server upgrades\n     * @private\n     */\n    _filterUpgrades(upgrades) {\n        const filteredUpgrades = [];\n        for (let i = 0; i < upgrades.length; i++) {\n            if (~this.transports.indexOf(upgrades[i]))\n                filteredUpgrades.push(upgrades[i]);\n        }\n        return filteredUpgrades;\n    }\n}\n/**\n * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established\n * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.\n *\n * This class comes with an upgrade mechanism, which means that once the connection is established with the first\n * low-level transport, it will try to upgrade to a better transport.\n *\n * @example\n * import { Socket } from \"engine.io-client\";\n *\n * const socket = new Socket();\n *\n * socket.on(\"open\", () => {\n *   socket.send(\"hello\");\n * });\n *\n * @see SocketWithoutUpgrade\n * @see SocketWithUpgrade\n */\nexport class Socket extends SocketWithUpgrade {\n    constructor(uri, opts = {}) {\n        const o = typeof uri === \"object\" ? uri : opts;\n        if (!o.transports ||\n            (o.transports && typeof o.transports[0] === \"string\")) {\n            o.transports = (o.transports || [\"polling\", \"websocket\", \"webtransport\"])\n                .map((transportName) => DEFAULT_TRANSPORTS[transportName])\n                .filter((t) => !!t);\n        }\n        super(uri, o);\n    }\n}\n","import { parse } from \"engine.io-client\";\n/**\n * URL parser.\n *\n * @param uri - url\n * @param path - the request path of the connection\n * @param loc - An object meant to mimic window.location.\n *        Defaults to window.location.\n * @public\n */\nexport function url(uri, path = \"\", loc) {\n    let obj = uri;\n    // default to window.location\n    loc = loc || (typeof location !== \"undefined\" && location);\n    if (null == uri)\n        uri = loc.protocol + \"//\" + loc.host;\n    // relative path support\n    if (typeof uri === \"string\") {\n        if (\"/\" === uri.charAt(0)) {\n            if (\"/\" === uri.charAt(1)) {\n                uri = loc.protocol + uri;\n            }\n            else {\n                uri = loc.host + uri;\n            }\n        }\n        if (!/^(https?|wss?):\\/\\//.test(uri)) {\n            if (\"undefined\" !== typeof loc) {\n                uri = loc.protocol + \"//\" + uri;\n            }\n            else {\n                uri = \"https://\" + uri;\n            }\n        }\n        // parse\n        obj = parse(uri);\n    }\n    // make sure we treat `localhost:80` and `localhost` equally\n    if (!obj.port) {\n        if (/^(http|ws)$/.test(obj.protocol)) {\n            obj.port = \"80\";\n        }\n        else if (/^(http|ws)s$/.test(obj.protocol)) {\n            obj.port = \"443\";\n        }\n    }\n    obj.path = obj.path || \"/\";\n    const ipv6 = obj.host.indexOf(\":\") !== -1;\n    const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n    // define unique id\n    obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n    // define href\n    obj.href =\n        obj.protocol +\n            \"://\" +\n            host +\n            (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n    return obj;\n}\n","const withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst isView = (obj) => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj.buffer instanceof ArrayBuffer;\n};\nconst toString = Object.prototype.toString;\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeFile = typeof File === \"function\" ||\n    (typeof File !== \"undefined\" &&\n        toString.call(File) === \"[object FileConstructor]\");\n/**\n * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n *\n * @private\n */\nexport function isBinary(obj) {\n    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||\n        (withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File));\n}\nexport function hasBinary(obj, toJSON) {\n    if (!obj || typeof obj !== \"object\") {\n        return false;\n    }\n    if (Array.isArray(obj)) {\n        for (let i = 0, l = obj.length; i < l; i++) {\n            if (hasBinary(obj[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (isBinary(obj)) {\n        return true;\n    }\n    if (obj.toJSON &&\n        typeof obj.toJSON === \"function\" &&\n        arguments.length === 1) {\n        return hasBinary(obj.toJSON(), true);\n    }\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n            return true;\n        }\n    }\n    return false;\n}\n","import { isBinary } from \"./is-binary.js\";\n/**\n * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @public\n */\nexport function deconstructPacket(packet) {\n    const buffers = [];\n    const packetData = packet.data;\n    const pack = packet;\n    pack.data = _deconstructPacket(packetData, buffers);\n    pack.attachments = buffers.length; // number of binary 'attachments'\n    return { packet: pack, buffers: buffers };\n}\nfunction _deconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (isBinary(data)) {\n        const placeholder = { _placeholder: true, num: buffers.length };\n        buffers.push(data);\n        return placeholder;\n    }\n    else if (Array.isArray(data)) {\n        const newData = new Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n            newData[i] = _deconstructPacket(data[i], buffers);\n        }\n        return newData;\n    }\n    else if (typeof data === \"object\" && !(data instanceof Date)) {\n        const newData = {};\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\n                newData[key] = _deconstructPacket(data[key], buffers);\n            }\n        }\n        return newData;\n    }\n    return data;\n}\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @public\n */\nexport function reconstructPacket(packet, buffers) {\n    packet.data = _reconstructPacket(packet.data, buffers);\n    delete packet.attachments; // no longer useful\n    return packet;\n}\nfunction _reconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (data && data._placeholder === true) {\n        const isIndexValid = typeof data.num === \"number\" &&\n            data.num >= 0 &&\n            data.num < buffers.length;\n        if (isIndexValid) {\n            return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n        }\n        else {\n            throw new Error(\"illegal attachments\");\n        }\n    }\n    else if (Array.isArray(data)) {\n        for (let i = 0; i < data.length; i++) {\n            data[i] = _reconstructPacket(data[i], buffers);\n        }\n    }\n    else if (typeof data === \"object\") {\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\n                data[key] = _reconstructPacket(data[key], buffers);\n            }\n        }\n    }\n    return data;\n}\n","import { Emitter } from \"@socket.io/component-emitter\";\nimport { deconstructPacket, reconstructPacket } from \"./binary.js\";\nimport { isBinary, hasBinary } from \"./is-binary.js\";\n/**\n * These strings must not be used as event names, as they have a special meaning.\n */\nconst RESERVED_EVENTS = [\n    \"connect\",\n    \"connect_error\",\n    \"disconnect\",\n    \"disconnecting\",\n    \"newListener\",\n    \"removeListener\", // used by the Node.js EventEmitter\n];\n/**\n * Protocol version.\n *\n * @public\n */\nexport const protocol = 5;\nexport var PacketType;\n(function (PacketType) {\n    PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n    PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n    PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n    PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n    PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n    PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n    PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n})(PacketType || (PacketType = {}));\n/**\n * A socket.io Encoder instance\n */\nexport class Encoder {\n    /**\n     * Encoder constructor\n     *\n     * @param {function} replacer - custom replacer to pass down to JSON.parse\n     */\n    constructor(replacer) {\n        this.replacer = replacer;\n    }\n    /**\n     * Encode a packet as a single string if non-binary, or as a\n     * buffer sequence, depending on packet type.\n     *\n     * @param {Object} obj - packet object\n     */\n    encode(obj) {\n        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n            if (hasBinary(obj)) {\n                return this.encodeAsBinary({\n                    type: obj.type === PacketType.EVENT\n                        ? PacketType.BINARY_EVENT\n                        : PacketType.BINARY_ACK,\n                    nsp: obj.nsp,\n                    data: obj.data,\n                    id: obj.id,\n                });\n            }\n        }\n        return [this.encodeAsString(obj)];\n    }\n    /**\n     * Encode packet as string.\n     */\n    encodeAsString(obj) {\n        // first is type\n        let str = \"\" + obj.type;\n        // attachments if we have them\n        if (obj.type === PacketType.BINARY_EVENT ||\n            obj.type === PacketType.BINARY_ACK) {\n            str += obj.attachments + \"-\";\n        }\n        // if we have a namespace other than `/`\n        // we append it followed by a comma `,`\n        if (obj.nsp && \"/\" !== obj.nsp) {\n            str += obj.nsp + \",\";\n        }\n        // immediately followed by the id\n        if (null != obj.id) {\n            str += obj.id;\n        }\n        // json data\n        if (null != obj.data) {\n            str += JSON.stringify(obj.data, this.replacer);\n        }\n        return str;\n    }\n    /**\n     * Encode packet as 'buffer sequence' by removing blobs, and\n     * deconstructing packet into object with placeholders and\n     * a list of buffers.\n     */\n    encodeAsBinary(obj) {\n        const deconstruction = deconstructPacket(obj);\n        const pack = this.encodeAsString(deconstruction.packet);\n        const buffers = deconstruction.buffers;\n        buffers.unshift(pack); // add packet info to beginning of data list\n        return buffers; // write all the buffers\n    }\n}\n// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript\nfunction isObject(value) {\n    return Object.prototype.toString.call(value) === \"[object Object]\";\n}\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n */\nexport class Decoder extends Emitter {\n    /**\n     * Decoder constructor\n     *\n     * @param {function} reviver - custom reviver to pass down to JSON.stringify\n     */\n    constructor(reviver) {\n        super();\n        this.reviver = reviver;\n    }\n    /**\n     * Decodes an encoded packet string into packet JSON.\n     *\n     * @param {String} obj - encoded packet\n     */\n    add(obj) {\n        let packet;\n        if (typeof obj === \"string\") {\n            if (this.reconstructor) {\n                throw new Error(\"got plaintext data when reconstructing a packet\");\n            }\n            packet = this.decodeString(obj);\n            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;\n            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {\n                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;\n                // binary packet's json\n                this.reconstructor = new BinaryReconstructor(packet);\n                // no attachments, labeled binary but no binary data to follow\n                if (packet.attachments === 0) {\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n            else {\n                // non-binary full packet\n                super.emitReserved(\"decoded\", packet);\n            }\n        }\n        else if (isBinary(obj) || obj.base64) {\n            // raw binary data\n            if (!this.reconstructor) {\n                throw new Error(\"got binary data when not reconstructing a packet\");\n            }\n            else {\n                packet = this.reconstructor.takeBinaryData(obj);\n                if (packet) {\n                    // received final buffer\n                    this.reconstructor = null;\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Unknown type: \" + obj);\n        }\n    }\n    /**\n     * Decode a packet String (JSON data)\n     *\n     * @param {String} str\n     * @return {Object} packet\n     */\n    decodeString(str) {\n        let i = 0;\n        // look up type\n        const p = {\n            type: Number(str.charAt(0)),\n        };\n        if (PacketType[p.type] === undefined) {\n            throw new Error(\"unknown packet type \" + p.type);\n        }\n        // look up attachments if type binary\n        if (p.type === PacketType.BINARY_EVENT ||\n            p.type === PacketType.BINARY_ACK) {\n            const start = i + 1;\n            while (str.charAt(++i) !== \"-\" && i != str.length) { }\n            const buf = str.substring(start, i);\n            if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                throw new Error(\"Illegal attachments\");\n            }\n            p.attachments = Number(buf);\n        }\n        // look up namespace (if any)\n        if (\"/\" === str.charAt(i + 1)) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (\",\" === c)\n                    break;\n                if (i === str.length)\n                    break;\n            }\n            p.nsp = str.substring(start, i);\n        }\n        else {\n            p.nsp = \"/\";\n        }\n        // look up id\n        const next = str.charAt(i + 1);\n        if (\"\" !== next && Number(next) == next) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (null == c || Number(c) != c) {\n                    --i;\n                    break;\n                }\n                if (i === str.length)\n                    break;\n            }\n            p.id = Number(str.substring(start, i + 1));\n        }\n        // look up json data\n        if (str.charAt(++i)) {\n            const payload = this.tryParse(str.substr(i));\n            if (Decoder.isPayloadValid(p.type, payload)) {\n                p.data = payload;\n            }\n            else {\n                throw new Error(\"invalid payload\");\n            }\n        }\n        return p;\n    }\n    tryParse(str) {\n        try {\n            return JSON.parse(str, this.reviver);\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    static isPayloadValid(type, payload) {\n        switch (type) {\n            case PacketType.CONNECT:\n                return isObject(payload);\n            case PacketType.DISCONNECT:\n                return payload === undefined;\n            case PacketType.CONNECT_ERROR:\n                return typeof payload === \"string\" || isObject(payload);\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                return (Array.isArray(payload) &&\n                    (typeof payload[0] === \"number\" ||\n                        (typeof payload[0] === \"string\" &&\n                            RESERVED_EVENTS.indexOf(payload[0]) === -1)));\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                return Array.isArray(payload);\n        }\n    }\n    /**\n     * Deallocates a parser's resources\n     */\n    destroy() {\n        if (this.reconstructor) {\n            this.reconstructor.finishedReconstruction();\n            this.reconstructor = null;\n        }\n    }\n}\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n */\nclass BinaryReconstructor {\n    constructor(packet) {\n        this.packet = packet;\n        this.buffers = [];\n        this.reconPack = packet;\n    }\n    /**\n     * Method to be called when binary data received from connection\n     * after a BINARY_EVENT packet.\n     *\n     * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n     * @return {null | Object} returns null if more binary data is expected or\n     *   a reconstructed packet object if all buffers have been received.\n     */\n    takeBinaryData(binData) {\n        this.buffers.push(binData);\n        if (this.buffers.length === this.reconPack.attachments) {\n            // done with buffer list\n            const packet = reconstructPacket(this.reconPack, this.buffers);\n            this.finishedReconstruction();\n            return packet;\n        }\n        return null;\n    }\n    /**\n     * Cleans up binary packet reconstruction variables.\n     */\n    finishedReconstruction() {\n        this.reconPack = null;\n        this.buffers = [];\n    }\n}\n","export function on(obj, ev, fn) {\n    obj.on(ev, fn);\n    return function subDestroy() {\n        obj.off(ev, fn);\n    };\n}\n","import { PacketType } from \"socket.io-parser\";\nimport { on } from \"./on.js\";\nimport { Emitter, } from \"@socket.io/component-emitter\";\n/**\n * Internal events.\n * These events can't be emitted by the user.\n */\nconst RESERVED_EVENTS = Object.freeze({\n    connect: 1,\n    connect_error: 1,\n    disconnect: 1,\n    disconnecting: 1,\n    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n    newListener: 1,\n    removeListener: 1,\n});\n/**\n * A Socket is the fundamental class for interacting with the server.\n *\n * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.\n *\n * @example\n * const socket = io();\n *\n * socket.on(\"connect\", () => {\n *   console.log(\"connected\");\n * });\n *\n * // send an event to the server\n * socket.emit(\"foo\", \"bar\");\n *\n * socket.on(\"foobar\", () => {\n *   // an event was received from the server\n * });\n *\n * // upon disconnection\n * socket.on(\"disconnect\", (reason) => {\n *   console.log(`disconnected due to ${reason}`);\n * });\n */\nexport class Socket extends Emitter {\n    /**\n     * `Socket` constructor.\n     */\n    constructor(io, nsp, opts) {\n        super();\n        /**\n         * Whether the socket is currently connected to the server.\n         *\n         * @example\n         * const socket = io();\n         *\n         * socket.on(\"connect\", () => {\n         *   console.log(socket.connected); // true\n         * });\n         *\n         * socket.on(\"disconnect\", () => {\n         *   console.log(socket.connected); // false\n         * });\n         */\n        this.connected = false;\n        /**\n         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n         * be transmitted by the server.\n         */\n        this.recovered = false;\n        /**\n         * Buffer for packets received before the CONNECT packet\n         */\n        this.receiveBuffer = [];\n        /**\n         * Buffer for packets that will be sent once the socket is connected\n         */\n        this.sendBuffer = [];\n        /**\n         * The queue of packets to be sent with retry in case of failure.\n         *\n         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.\n         * @private\n         */\n        this._queue = [];\n        /**\n         * A sequence to generate the ID of the {@link QueuedPacket}.\n         * @private\n         */\n        this._queueSeq = 0;\n        this.ids = 0;\n        /**\n         * A map containing acknowledgement handlers.\n         *\n         * The `withError` attribute is used to differentiate handlers that accept an error as first argument:\n         *\n         * - `socket.emit(\"test\", (err, value) => { ... })` with `ackTimeout` option\n         * - `socket.timeout(5000).emit(\"test\", (err, value) => { ... })`\n         * - `const value = await socket.emitWithAck(\"test\")`\n         *\n         * From those that don't:\n         *\n         * - `socket.emit(\"test\", (value) => { ... });`\n         *\n         * In the first case, the handlers will be called with an error when:\n         *\n         * - the timeout is reached\n         * - the socket gets disconnected\n         *\n         * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive\n         * an acknowledgement from the server.\n         *\n         * @private\n         */\n        this.acks = {};\n        this.flags = {};\n        this.io = io;\n        this.nsp = nsp;\n        if (opts && opts.auth) {\n            this.auth = opts.auth;\n        }\n        this._opts = Object.assign({}, opts);\n        if (this.io._autoConnect)\n            this.open();\n    }\n    /**\n     * Whether the socket is currently disconnected\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"connect\", () => {\n     *   console.log(socket.disconnected); // false\n     * });\n     *\n     * socket.on(\"disconnect\", () => {\n     *   console.log(socket.disconnected); // true\n     * });\n     */\n    get disconnected() {\n        return !this.connected;\n    }\n    /**\n     * Subscribe to open, close and packet events\n     *\n     * @private\n     */\n    subEvents() {\n        if (this.subs)\n            return;\n        const io = this.io;\n        this.subs = [\n            on(io, \"open\", this.onopen.bind(this)),\n            on(io, \"packet\", this.onpacket.bind(this)),\n            on(io, \"error\", this.onerror.bind(this)),\n            on(io, \"close\", this.onclose.bind(this)),\n        ];\n    }\n    /**\n     * Whether the Socket will try to reconnect when its Manager connects or reconnects.\n     *\n     * @example\n     * const socket = io();\n     *\n     * console.log(socket.active); // true\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   if (reason === \"io server disconnect\") {\n     *     // the disconnection was initiated by the server, you need to manually reconnect\n     *     console.log(socket.active); // false\n     *   }\n     *   // else the socket will automatically try to reconnect\n     *   console.log(socket.active); // true\n     * });\n     */\n    get active() {\n        return !!this.subs;\n    }\n    /**\n     * \"Opens\" the socket.\n     *\n     * @example\n     * const socket = io({\n     *   autoConnect: false\n     * });\n     *\n     * socket.connect();\n     */\n    connect() {\n        if (this.connected)\n            return this;\n        this.subEvents();\n        if (!this.io[\"_reconnecting\"])\n            this.io.open(); // ensure open\n        if (\"open\" === this.io._readyState)\n            this.onopen();\n        return this;\n    }\n    /**\n     * Alias for {@link connect()}.\n     */\n    open() {\n        return this.connect();\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * socket.send(\"hello\");\n     *\n     * // this is equivalent to\n     * socket.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */\n    send(...args) {\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n    }\n    /**\n     * Override `emit`.\n     * If the event is in `events`, it's emitted normally.\n     *\n     * @example\n     * socket.emit(\"hello\", \"world\");\n     *\n     * // all serializable datastructures are supported (no need to call JSON.stringify)\n     * socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n     *\n     * // with an acknowledgement from the server\n     * socket.emit(\"hello\", \"world\", (val) => {\n     *   // ...\n     * });\n     *\n     * @return self\n     */\n    emit(ev, ...args) {\n        var _a, _b, _c;\n        if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n            throw new Error('\"' + ev.toString() + '\" is a reserved event name');\n        }\n        args.unshift(ev);\n        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {\n            this._addToQueue(args);\n            return this;\n        }\n        const packet = {\n            type: PacketType.EVENT,\n            data: args,\n        };\n        packet.options = {};\n        packet.options.compress = this.flags.compress !== false;\n        // event ack callback\n        if (\"function\" === typeof args[args.length - 1]) {\n            const id = this.ids++;\n            const ack = args.pop();\n            this._registerAckCallback(id, ack);\n            packet.id = id;\n        }\n        const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;\n        const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());\n        const discardPacket = this.flags.volatile && !isTransportWritable;\n        if (discardPacket) {\n        }\n        else if (isConnected) {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        }\n        else {\n            this.sendBuffer.push(packet);\n        }\n        this.flags = {};\n        return this;\n    }\n    /**\n     * @private\n     */\n    _registerAckCallback(id, ack) {\n        var _a;\n        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;\n        if (timeout === undefined) {\n            this.acks[id] = ack;\n            return;\n        }\n        // @ts-ignore\n        const timer = this.io.setTimeoutFn(() => {\n            delete this.acks[id];\n            for (let i = 0; i < this.sendBuffer.length; i++) {\n                if (this.sendBuffer[i].id === id) {\n                    this.sendBuffer.splice(i, 1);\n                }\n            }\n            ack.call(this, new Error(\"operation has timed out\"));\n        }, timeout);\n        const fn = (...args) => {\n            // @ts-ignore\n            this.io.clearTimeoutFn(timer);\n            ack.apply(this, args);\n        };\n        fn.withError = true;\n        this.acks[id] = fn;\n    }\n    /**\n     * Emits an event and waits for an acknowledgement\n     *\n     * @example\n     * // without timeout\n     * const response = await socket.emitWithAck(\"hello\", \"world\");\n     *\n     * // with a specific timeout\n     * try {\n     *   const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n     * } catch (err) {\n     *   // the server did not acknowledge the event in the given delay\n     * }\n     *\n     * @return a Promise that will be fulfilled when the server acknowledges the event\n     */\n    emitWithAck(ev, ...args) {\n        return new Promise((resolve, reject) => {\n            const fn = (arg1, arg2) => {\n                return arg1 ? reject(arg1) : resolve(arg2);\n            };\n            fn.withError = true;\n            args.push(fn);\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * Add the packet to the queue.\n     * @param args\n     * @private\n     */\n    _addToQueue(args) {\n        let ack;\n        if (typeof args[args.length - 1] === \"function\") {\n            ack = args.pop();\n        }\n        const packet = {\n            id: this._queueSeq++,\n            tryCount: 0,\n            pending: false,\n            args,\n            flags: Object.assign({ fromQueue: true }, this.flags),\n        };\n        args.push((err, ...responseArgs) => {\n            if (packet !== this._queue[0]) {\n                // the packet has already been acknowledged\n                return;\n            }\n            const hasError = err !== null;\n            if (hasError) {\n                if (packet.tryCount > this._opts.retries) {\n                    this._queue.shift();\n                    if (ack) {\n                        ack(err);\n                    }\n                }\n            }\n            else {\n                this._queue.shift();\n                if (ack) {\n                    ack(null, ...responseArgs);\n                }\n            }\n            packet.pending = false;\n            return this._drainQueue();\n        });\n        this._queue.push(packet);\n        this._drainQueue();\n    }\n    /**\n     * Send the first packet of the queue, and wait for an acknowledgement from the server.\n     * @param force - whether to resend a packet that has not been acknowledged yet\n     *\n     * @private\n     */\n    _drainQueue(force = false) {\n        if (!this.connected || this._queue.length === 0) {\n            return;\n        }\n        const packet = this._queue[0];\n        if (packet.pending && !force) {\n            return;\n        }\n        packet.pending = true;\n        packet.tryCount++;\n        this.flags = packet.flags;\n        this.emit.apply(this, packet.args);\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param packet\n     * @private\n     */\n    packet(packet) {\n        packet.nsp = this.nsp;\n        this.io._packet(packet);\n    }\n    /**\n     * Called upon engine `open`.\n     *\n     * @private\n     */\n    onopen() {\n        if (typeof this.auth == \"function\") {\n            this.auth((data) => {\n                this._sendConnectPacket(data);\n            });\n        }\n        else {\n            this._sendConnectPacket(this.auth);\n        }\n    }\n    /**\n     * Sends a CONNECT packet to initiate the Socket.IO session.\n     *\n     * @param data\n     * @private\n     */\n    _sendConnectPacket(data) {\n        this.packet({\n            type: PacketType.CONNECT,\n            data: this._pid\n                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)\n                : data,\n        });\n    }\n    /**\n     * Called upon engine or manager `error`.\n     *\n     * @param err\n     * @private\n     */\n    onerror(err) {\n        if (!this.connected) {\n            this.emitReserved(\"connect_error\", err);\n        }\n    }\n    /**\n     * Called upon engine `close`.\n     *\n     * @param reason\n     * @param description\n     * @private\n     */\n    onclose(reason, description) {\n        this.connected = false;\n        delete this.id;\n        this.emitReserved(\"disconnect\", reason, description);\n        this._clearAcks();\n    }\n    /**\n     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from\n     * the server.\n     *\n     * @private\n     */\n    _clearAcks() {\n        Object.keys(this.acks).forEach((id) => {\n            const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);\n            if (!isBuffered) {\n                // note: handlers that do not accept an error as first argument are ignored here\n                const ack = this.acks[id];\n                delete this.acks[id];\n                if (ack.withError) {\n                    ack.call(this, new Error(\"socket has been disconnected\"));\n                }\n            }\n        });\n    }\n    /**\n     * Called with socket packet.\n     *\n     * @param packet\n     * @private\n     */\n    onpacket(packet) {\n        const sameNamespace = packet.nsp === this.nsp;\n        if (!sameNamespace)\n            return;\n        switch (packet.type) {\n            case PacketType.CONNECT:\n                if (packet.data && packet.data.sid) {\n                    this.onconnect(packet.data.sid, packet.data.pid);\n                }\n                else {\n                    this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                }\n                break;\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n            case PacketType.CONNECT_ERROR:\n                this.destroy();\n                const err = new Error(packet.data.message);\n                // @ts-ignore\n                err.data = packet.data.data;\n                this.emitReserved(\"connect_error\", err);\n                break;\n        }\n    }\n    /**\n     * Called upon a server event.\n     *\n     * @param packet\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        if (null != packet.id) {\n            args.push(this.ack(packet.id));\n        }\n        if (this.connected) {\n            this.emitEvent(args);\n        }\n        else {\n            this.receiveBuffer.push(Object.freeze(args));\n        }\n    }\n    emitEvent(args) {\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        super.emit.apply(this, args);\n        if (this._pid && args.length && typeof args[args.length - 1] === \"string\") {\n            this._lastOffset = args[args.length - 1];\n        }\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function (...args) {\n            // prevent double callbacks\n            if (sent)\n                return;\n            sent = true;\n            self.packet({\n                type: PacketType.ACK,\n                id: id,\n                data: args,\n            });\n        };\n    }\n    /**\n     * Called upon a server acknowledgement.\n     *\n     * @param packet\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks[packet.id];\n        if (typeof ack !== \"function\") {\n            return;\n        }\n        delete this.acks[packet.id];\n        // @ts-ignore FIXME ack is incorrectly inferred as 'never'\n        if (ack.withError) {\n            packet.data.unshift(null);\n        }\n        // @ts-ignore\n        ack.apply(this, packet.data);\n    }\n    /**\n     * Called upon server connect.\n     *\n     * @private\n     */\n    onconnect(id, pid) {\n        this.id = id;\n        this.recovered = pid && this._pid === pid;\n        this._pid = pid; // defined only if connection state recovery is enabled\n        this.connected = true;\n        this.emitBuffered();\n        this.emitReserved(\"connect\");\n        this._drainQueue(true);\n    }\n    /**\n     * Emit buffered events (received and emitted).\n     *\n     * @private\n     */\n    emitBuffered() {\n        this.receiveBuffer.forEach((args) => this.emitEvent(args));\n        this.receiveBuffer = [];\n        this.sendBuffer.forEach((packet) => {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        });\n        this.sendBuffer = [];\n    }\n    /**\n     * Called upon server disconnect.\n     *\n     * @private\n     */\n    ondisconnect() {\n        this.destroy();\n        this.onclose(\"io server disconnect\");\n    }\n    /**\n     * Called upon forced client/server side disconnections,\n     * this method ensures the manager stops tracking us and\n     * that reconnections don't get triggered for this.\n     *\n     * @private\n     */\n    destroy() {\n        if (this.subs) {\n            // clean subscriptions to avoid reconnections\n            this.subs.forEach((subDestroy) => subDestroy());\n            this.subs = undefined;\n        }\n        this.io[\"_destroy\"](this);\n    }\n    /**\n     * Disconnects the socket manually. In that case, the socket will not try to reconnect.\n     *\n     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   // console.log(reason); prints \"io client disconnect\"\n     * });\n     *\n     * socket.disconnect();\n     *\n     * @return self\n     */\n    disconnect() {\n        if (this.connected) {\n            this.packet({ type: PacketType.DISCONNECT });\n        }\n        // remove socket from pool\n        this.destroy();\n        if (this.connected) {\n            // fire events\n            this.onclose(\"io client disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Alias for {@link disconnect()}.\n     *\n     * @return self\n     */\n    close() {\n        return this.disconnect();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * socket.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n     * ready to send messages.\n     *\n     * @example\n     * socket.volatile.emit(\"hello\"); // the server may or may not receive it\n     *\n     * @returns self\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n     * given number of milliseconds have elapsed without an acknowledgement from the server:\n     *\n     * @example\n     * socket.timeout(5000).emit(\"my-event\", (err) => {\n     *   if (err) {\n     *     // the server did not acknowledge the event in the given delay\n     *   }\n     * });\n     *\n     * @returns self\n     */\n    timeout(timeout) {\n        this.flags.timeout = timeout;\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * @example\n     * socket.onAny((event, ...args) => {\n     *   console.log(`got ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @example\n     * socket.prependAny((event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * }\n     *\n     * socket.onAny(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAny(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAny();\n     *\n     * @param listener\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.onAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.prependAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * }\n     *\n     * socket.onAnyOutgoing(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAnyOutgoing(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAnyOutgoing();\n     *\n     * @param [listener] - the catch-all listener (optional)\n     */\n    offAnyOutgoing(listener) {\n        if (!this._anyOutgoingListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyOutgoingListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyOutgoingListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n    }\n    /**\n     * Notify the listeners for each packet sent\n     *\n     * @param packet\n     *\n     * @private\n     */\n    notifyOutgoingListeners(packet) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n            const listeners = this._anyOutgoingListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, packet.data);\n            }\n        }\n    }\n}\n","/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\nexport function Backoff(opts) {\n    opts = opts || {};\n    this.ms = opts.min || 100;\n    this.max = opts.max || 10000;\n    this.factor = opts.factor || 2;\n    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n    this.attempts = 0;\n}\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\nBackoff.prototype.duration = function () {\n    var ms = this.ms * Math.pow(this.factor, this.attempts++);\n    if (this.jitter) {\n        var rand = Math.random();\n        var deviation = Math.floor(rand * this.jitter * ms);\n        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n    }\n    return Math.min(ms, this.max) | 0;\n};\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\nBackoff.prototype.reset = function () {\n    this.attempts = 0;\n};\n/**\n * Set the minimum duration\n *\n * @api public\n */\nBackoff.prototype.setMin = function (min) {\n    this.ms = min;\n};\n/**\n * Set the maximum duration\n *\n * @api public\n */\nBackoff.prototype.setMax = function (max) {\n    this.max = max;\n};\n/**\n * Set the jitter\n *\n * @api public\n */\nBackoff.prototype.setJitter = function (jitter) {\n    this.jitter = jitter;\n};\n","import { Socket as Engine, installTimerFunctions, nextTick, } from \"engine.io-client\";\nimport { Socket } from \"./socket.js\";\nimport * as parser from \"socket.io-parser\";\nimport { on } from \"./on.js\";\nimport { Backoff } from \"./contrib/backo2.js\";\nimport { Emitter, } from \"@socket.io/component-emitter\";\nexport class Manager extends Emitter {\n    constructor(uri, opts) {\n        var _a;\n        super();\n        this.nsps = {};\n        this.subs = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        opts.path = opts.path || \"/socket.io\";\n        this.opts = opts;\n        installTimerFunctions(this, opts);\n        this.reconnection(opts.reconnection !== false);\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n        this.backoff = new Backoff({\n            min: this.reconnectionDelay(),\n            max: this.reconnectionDelayMax(),\n            jitter: this.randomizationFactor(),\n        });\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n        this._readyState = \"closed\";\n        this.uri = uri;\n        const _parser = opts.parser || parser;\n        this.encoder = new _parser.Encoder();\n        this.decoder = new _parser.Decoder();\n        this._autoConnect = opts.autoConnect !== false;\n        if (this._autoConnect)\n            this.open();\n    }\n    reconnection(v) {\n        if (!arguments.length)\n            return this._reconnection;\n        this._reconnection = !!v;\n        if (!v) {\n            this.skipReconnect = true;\n        }\n        return this;\n    }\n    reconnectionAttempts(v) {\n        if (v === undefined)\n            return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n    }\n    reconnectionDelay(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n        return this;\n    }\n    randomizationFactor(v) {\n        var _a;\n        if (v === undefined)\n            return this._randomizationFactor;\n        this._randomizationFactor = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n        return this;\n    }\n    reconnectionDelayMax(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n        return this;\n    }\n    timeout(v) {\n        if (!arguments.length)\n            return this._timeout;\n        this._timeout = v;\n        return this;\n    }\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this._reconnecting &&\n            this._reconnection &&\n            this.backoff.attempts === 0) {\n            // keeps reconnection from firing twice for the same reconnection loop\n            this.reconnect();\n        }\n    }\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn) {\n        if (~this._readyState.indexOf(\"open\"))\n            return this;\n        this.engine = new Engine(this.uri, this.opts);\n        const socket = this.engine;\n        const self = this;\n        this._readyState = \"opening\";\n        this.skipReconnect = false;\n        // emit `open`\n        const openSubDestroy = on(socket, \"open\", function () {\n            self.onopen();\n            fn && fn();\n        });\n        const onError = (err) => {\n            this.cleanup();\n            this._readyState = \"closed\";\n            this.emitReserved(\"error\", err);\n            if (fn) {\n                fn(err);\n            }\n            else {\n                // Only do this if there is no fn to handle the error\n                this.maybeReconnectOnOpen();\n            }\n        };\n        // emit `error`\n        const errorSub = on(socket, \"error\", onError);\n        if (false !== this._timeout) {\n            const timeout = this._timeout;\n            // set timer\n            const timer = this.setTimeoutFn(() => {\n                openSubDestroy();\n                onError(new Error(\"timeout\"));\n                socket.close();\n            }, timeout);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(() => {\n                this.clearTimeoutFn(timer);\n            });\n        }\n        this.subs.push(openSubDestroy);\n        this.subs.push(errorSub);\n        return this;\n    }\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn) {\n        return this.open(fn);\n    }\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    onopen() {\n        // clear old subs\n        this.cleanup();\n        // mark as open\n        this._readyState = \"open\";\n        this.emitReserved(\"open\");\n        // add new subs\n        const socket = this.engine;\n        this.subs.push(on(socket, \"ping\", this.onping.bind(this)), on(socket, \"data\", this.ondata.bind(this)), on(socket, \"error\", this.onerror.bind(this)), on(socket, \"close\", this.onclose.bind(this)), \n        // @ts-ignore\n        on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n    }\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    onping() {\n        this.emitReserved(\"ping\");\n    }\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    ondata(data) {\n        try {\n            this.decoder.add(data);\n        }\n        catch (e) {\n            this.onclose(\"parse error\", e);\n        }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a \"parse error\"\n        nextTick(() => {\n            this.emitReserved(\"packet\", packet);\n        }, this.setTimeoutFn);\n    }\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    onerror(err) {\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp, opts) {\n        let socket = this.nsps[nsp];\n        if (!socket) {\n            socket = new Socket(this, nsp, opts);\n            this.nsps[nsp] = socket;\n        }\n        else if (this._autoConnect && !socket.active) {\n            socket.connect();\n        }\n        return socket;\n    }\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket) {\n        const nsps = Object.keys(this.nsps);\n        for (const nsp of nsps) {\n            const socket = this.nsps[nsp];\n            if (socket.active) {\n                return;\n            }\n        }\n        this._close();\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet) {\n        const encodedPackets = this.encoder.encode(packet);\n        for (let i = 0; i < encodedPackets.length; i++) {\n            this.engine.write(encodedPackets[i], packet.options);\n        }\n    }\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    cleanup() {\n        this.subs.forEach((subDestroy) => subDestroy());\n        this.subs.length = 0;\n        this.decoder.destroy();\n    }\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close() {\n        this.skipReconnect = true;\n        this._reconnecting = false;\n        this.onclose(\"forced close\");\n    }\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    disconnect() {\n        return this._close();\n    }\n    /**\n     * Called when:\n     *\n     * - the low-level engine is closed\n     * - the parser encountered a badly formatted packet\n     * - all sockets are disconnected\n     *\n     * @private\n     */\n    onclose(reason, description) {\n        var _a;\n        this.cleanup();\n        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        this.emitReserved(\"close\", reason, description);\n        if (this._reconnection && !this.skipReconnect) {\n            this.reconnect();\n        }\n    }\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    reconnect() {\n        if (this._reconnecting || this.skipReconnect)\n            return this;\n        const self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n            this.backoff.reset();\n            this.emitReserved(\"reconnect_failed\");\n            this._reconnecting = false;\n        }\n        else {\n            const delay = this.backoff.duration();\n            this._reconnecting = true;\n            const timer = this.setTimeoutFn(() => {\n                if (self.skipReconnect)\n                    return;\n                this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n                // check again for the case socket closed in above events\n                if (self.skipReconnect)\n                    return;\n                self.open((err) => {\n                    if (err) {\n                        self._reconnecting = false;\n                        self.reconnect();\n                        this.emitReserved(\"reconnect_error\", err);\n                    }\n                    else {\n                        self.onreconnect();\n                    }\n                });\n            }, delay);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(() => {\n                this.clearTimeoutFn(timer);\n            });\n        }\n    }\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    onreconnect() {\n        const attempt = this.backoff.attempts;\n        this._reconnecting = false;\n        this.backoff.reset();\n        this.emitReserved(\"reconnect\", attempt);\n    }\n}\n","import { url } from \"./url.js\";\nimport { Manager } from \"./manager.js\";\nimport { Socket } from \"./socket.js\";\n/**\n * Managers cache.\n */\nconst cache = {};\nfunction lookup(uri, opts) {\n    if (typeof uri === \"object\") {\n        opts = uri;\n        uri = undefined;\n    }\n    opts = opts || {};\n    const parsed = url(uri, opts.path || \"/socket.io\");\n    const source = parsed.source;\n    const id = parsed.id;\n    const path = parsed.path;\n    const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n    const newConnection = opts.forceNew ||\n        opts[\"force new connection\"] ||\n        false === opts.multiplex ||\n        sameNamespace;\n    let io;\n    if (newConnection) {\n        io = new Manager(source, opts);\n    }\n    else {\n        if (!cache[id]) {\n            cache[id] = new Manager(source, opts);\n        }\n        io = cache[id];\n    }\n    if (parsed.query && !opts.query) {\n        opts.query = parsed.queryKey;\n    }\n    return io.socket(parsed.path, opts);\n}\n// so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n// namespace (e.g. `io.connect(...)`), for backward compatibility\nObject.assign(lookup, {\n    Manager,\n    Socket,\n    io: lookup,\n    connect: lookup,\n});\n/**\n * Protocol version.\n *\n * @public\n */\nexport { protocol } from \"socket.io-parser\";\n/**\n * Expose constructors for standalone build.\n *\n * @public\n */\nexport { Manager, Socket, lookup as io, lookup as connect, lookup as default, };\nexport { Fetch, NodeXHR, XHR, NodeWebSocket, WebSocket, WebTransport, } from \"engine.io-client\";\n","import { createContext, useContext } from 'react';\n\nexport interface WatchpartyConfig {\n  serverOrigin: string;\n  defaultRoomKey: string;\n  mediaBase: string;\n}\n\nexport const DEFAULT_CONFIG: WatchpartyConfig = {\n  serverOrigin: 'http://localhost:8080',\n  defaultRoomKey: 'dev-room-1000',\n  mediaBase: '/media',\n};\n\n// Runtime config used by non-component code (socket, catalog, etc.)\nlet runtimeConfig: WatchpartyConfig = { ...DEFAULT_CONFIG };\n\nexport function setRuntimeConfig(config: Partial<WatchpartyConfig>) {\n  runtimeConfig = { ...runtimeConfig, ...config };\n}\n\nexport function getRuntimeConfig(): WatchpartyConfig {\n  return runtimeConfig;\n}\n\n// React Context for component tree\nexport const ConfigContext = createContext<WatchpartyConfig>(DEFAULT_CONFIG);\n\nexport function useConfig(): WatchpartyConfig {\n  return useContext(ConfigContext);\n}\n","import { io, Socket } from 'socket.io-client';\nimport { useAppStore, RosterUser, ChatMessage } from './store';\nimport { getRuntimeConfig } from './config';\n\n// Verbose flag detection (URL ?verbose or ?v=1, or localStorage wp_verbose=1)\nconst VERBOSE = (() => {\n  try {\n    const sp = new URLSearchParams(window.location.search);\n    if (sp.has('verbose') || sp.get('v') === '1') return true;\n    if (localStorage.getItem('wp_verbose') === '1') return true;\n  } catch (_) { /* noop */ }\n  return false;\n})();\n\nfunction vLog(label: string, payload?: any) {\n  if (!VERBOSE) return;\n  if (payload !== undefined) console.debug('[wp]', label, payload); else console.debug('[wp]', label);\n}\n\nexport function isVerbose() { return VERBOSE; }\n\nexport async function probeServerHealth() {\n  const config = getRuntimeConfig();\n  const origin = config.serverOrigin.replace(/\\/$/, '');\n  const url = origin + '/healthz';\n  try {\n    const t0 = performance.now();\n    const res = await fetch(url, { cache: 'no-store' });\n    const text = await res.text().catch(()=>'<no-body>');\n    vLog('http_probe', { url, status: res.status, ok: res.ok, ms: Math.round(performance.now()-t0), body: text.slice(0,60) });\n  } catch (e:any) {\n    vLog('http_probe_fail', { url, error: e?.message || String(e) });\n  }\n}\n\nlet socket: Socket | null = null;\nlet timePingInflight: { ts: number } | null = null;\nlet timePingInterval: any = null;\n\ninterface JoinOpts {\n  room_key: string;\n  leader_key?: string | null;\n  override?: boolean;\n  name?: string;\n  sprite?: string | null;\n}\n\nexport function connectAndJoin(opts: JoinOpts) {\n  const s = getSocket();\n  const state = useAppStore.getState();\n  // If we already have a clientId and roster contains it, avoid duplicate join.\n  if (state.me.clientId && state.roster[state.me.clientId]) {\n    if (opts.name || opts.sprite) {\n      vLog('identity_update_emit', { name: opts.name, sprite: opts.sprite });\n      s.emit('identity_update', { name: opts.name, sprite: opts.sprite });\n    }\n    return s;\n  }\n  const payload = sanitizeJoin(opts);\n  const postJoinIdentity = () => {\n    setTimeout(() => {\n      const st = useAppStore.getState();\n      if (st.name) {\n        vLog('identity_update_emit_post_join', { name: st.name, sprite: st.sprite });\n        s.emit('identity_update', { name: st.name, sprite: st.sprite || undefined });\n      }\n    }, 40); // small delay to ensure server processed join\n  };\n  if (s.connected) {\n    vLog('join_emit', payload);\n    s.emit('join', payload);\n    postJoinIdentity();\n  } else {\n    s.once('connect', () => { vLog('join_emit', payload); s.emit('join', payload); postJoinIdentity(); });\n  }\n  return s;\n}\n\nfunction sanitizeJoin(o: JoinOpts) {\n  return {\n    room_key: o.room_key,\n    leader_key: o.leader_key || undefined,\n    override: o.override || undefined,\n    name: o.name,\n    sprite: o.sprite\n  };\n}\n\nlet RESOLVED_ORIGIN: string | null = null;\nexport function getResolvedOrigin() { return RESOLVED_ORIGIN; }\n\nexport function getSocket(): Socket {\n  if (!socket) {\n    const config = getRuntimeConfig();\n    let origin = config.serverOrigin || '/';\n    if (origin === '/' && typeof window !== 'undefined') {\n      const loc = window.location;\n      if ((loc.hostname === 'localhost' || loc.hostname === '127.0.0.1') && loc.port === '5173') {\n        origin = `${loc.protocol}//${loc.hostname}:8080`;\n        vLog('socket_origin_fallback', { origin });\n      }\n    }\n    RESOLVED_ORIGIN = origin;\n    socket = io(origin, { path: '/watchparty/ws', transports: ['websocket'] });\n    vLog('socket_init', { origin });\n    socket.on('connect', () => {\n      const sid = socket?.id;\n      vLog('socket_connect', { id: sid });\n      if (sid) {\n        try { useAppStore.getState().ensureMe(sid); } catch (_) {}\n      }\n    });\n    socket.on('disconnect', (reason) => vLog('socket_disconnect', { reason }));\n  socket.on('connect_error', (err) => vLog('socket_connect_error', { message: err?.message }));\n  socket.on('reconnect_attempt', (n) => vLog('socket_reconnect_attempt', { attempt: n }));\n  socket.on('reconnect_failed', () => vLog('socket_reconnect_failed'));\n    wireCoreHandlers(socket);\n  }\n  return socket;\n}\n\nfunction wireCoreHandlers(s: Socket) {\n  const store = useAppStore.getState();\n  // snapshot\n  s.on('snapshot', (payload: any) => {\n    if (payload?.client_id) useAppStore.getState().ensureMe(payload.client_id);\n    const users: RosterUser[] = (payload?.users || []).map((u: any) => ({\n      clientId: u.client_id,\n      name: u.name || 'Anon',\n      sprite: u.sprite_id ?? u.sprite ?? null,\n      isLeader: u.client_id === payload.leader_id\n    }));\n    useAppStore.getState().applySnapshot({\n      mediaId: payload.media_id ?? null,\n      playheadMs: payload.playhead_ms || 0,\n      playing: !!payload.playing,\n      serverSeq: payload.server_seq || 0,\n      leaderId: payload.leader_id || null,\n      users\n    });\n    // Auto identity assignment if we still have none\n    const st = useAppStore.getState();\n    if (!st.name) {\n      st.ensureAutoIdentity?.();\n      const st2 = useAppStore.getState();\n      if (st2.name) {\n        vLog('identity_auto_assign', { name: st2.name, sprite: st2.sprite });\n        s.emit('identity_update', { name: st2.name, sprite: st2.sprite || undefined });\n      }\n    }\n    vLog('snapshot', payload);\n  });\n\n  // start time ping loop (client-initiated) every 5s if not already\n  if (!timePingInterval) {\n    timePingInterval = setInterval(() => {\n      initiateTimePing();\n    }, 5000);\n  }\n\n  // presence events\n  s.on('presence', (ev: any) => {\n    if (!ev) return;\n    // Server currently emits { users: [...] }\n    if (Array.isArray(ev.users)) {\n      const roster: Record<string, RosterUser> = {};\n      for (const u of ev.users) {\n        roster[u.client_id] = {\n          clientId: u.client_id,\n          name: u.name || 'Anon',\n          sprite: u.sprite_id ?? u.sprite ?? null,\n          isLeader: u.is_leader\n        };\n      }\n      // If our local identity is known but server omitted it (race), patch it in\n      const st = useAppStore.getState();\n      const myId = socket?.id;\n      if (myId && roster[myId]) {\n        if (st.name) roster[myId].name = st.name; // authoritative locally chosen name\n        if (st.sprite) roster[myId].sprite = st.sprite;\n      }\n      // Replace roster wholesale for simplicity\n      (st as any).roster = roster; // direct mutate not ideal; use set\n  useAppStore.setState({ roster });\n    } else if (ev.kind && ev.user) { // fallback legacy granular events\n      if (ev.kind === 'leave') {\n        useAppStore.getState().removeUser(ev.user.client_id);\n      } else { // join/update\n        useAppStore.getState().upsertUser({\n          clientId: ev.user.client_id,\n          name: ev.user.name || '',\n          sprite: ev.user.sprite_id ?? ev.user.sprite ?? null,\n          isLeader: ev.user.is_leader\n        });\n        // Patch local identity if ours\n        const st2 = useAppStore.getState();\n        const myId2 = socket?.id;\n        if (myId2 && myId2 === ev.user.client_id && st2.name) {\n          useAppStore.getState().upsertUser({\n            clientId: myId2,\n            name: st2.name,\n            sprite: st2.sprite,\n            isLeader: ev.user.is_leader\n          });\n        }\n      }\n    }\n    vLog('presence', ev);\n    // If we still have no identity after presence, attempt assignment\n    const stFinal = useAppStore.getState();\n    if (!stFinal.name) {\n      stFinal.ensureAutoIdentity?.();\n      const st3 = useAppStore.getState();\n      if (st3.name) {\n        vLog('identity_auto_assign_presence', { name: st3.name, sprite: st3.sprite });\n        s.emit('identity_update', { name: st3.name, sprite: st3.sprite || undefined });\n      }\n    }\n  });\n\n  // control broadcasts (simplified before MSE): { server_seq, playhead_ms, playing, leader_id? }\n  s.on('control_broadcast', (msg: any) => {\n    const state = useAppStore.getState();\n    // If media_id present and changed, promote it into snapshot + reset readiness gate\n    if (Object.prototype.hasOwnProperty.call(msg, 'media_id')) {\n      const newMediaId = msg.media_id ?? null;\n      if (state.snapshot.mediaId !== newMediaId) {\n        state.applySnapshot({ mediaId: newMediaId });\n        // Reset readiness (server will emit fresh ready_state after clients append)\n        if (newMediaId) state.setReadiness({ mediaId: newMediaId, ready: false, readyCount: 0, total: 0 });\n      }\n    }\n    state.updateControlState({\n      playheadMs: msg.playhead_ms,\n      playing: msg.playing,\n      serverSeq: msg.server_seq,\n      leaderId: msg.leader_id ?? state.snapshot.leaderId\n    });\n    vLog('control_broadcast', msg);\n  });\n\n  // readiness gate updates\n  s.on('ready_state', (rs: any) => {\n    if (!rs) return;\n    useAppStore.getState().setReadiness({\n      mediaId: rs.media_id,\n      ready: !!rs.ready,\n      readyCount: rs.ready_count ?? rs.readyCount ?? 0,\n      total: rs.total ?? 0\n    });\n    vLog('ready_state', rs);\n  });\n\n  // control ack (map client_seq -> server_seq)\n  s.on('control_ack', (ack: any) => {\n    if (typeof ack?.client_seq === 'number' && typeof ack?.server_seq === 'number') {\n      useAppStore.getState().recordAck(ack.client_seq, ack.server_seq);\n      vLog('control_ack', ack);\n    }\n  });\n\n  // time ping from server: { id, server_time_ms }\n  s.on('time_ping', (p: any) => {\n    // respond immediately; include original id if present\n    s.emit('time_pong', { id: p?.id });\n    if (timePingInflight && timePingInflight.ts) {\n      const rtt = Date.now() - timePingInflight.ts;\n      useAppStore.getState().addRttSample(rtt, p?.server_time_ms, timePingInflight.ts);\n      timePingInflight = null;\n      vLog('time_rtt', { rtt, offset: useAppStore.getState().drift.offsetMs });\n    }\n  });\n\n  // chat_broadcast: { id, client_id, text, name, sprite, ts }\n  s.on('chat_broadcast', (m: any) => {\n    const chatMsg: ChatMessage = {\n      id: String(m.id ?? m.server_seq ?? Date.now()),\n      clientId: m.client_id,\n      name: m.name || 'Anon',\n      sprite: m.sprite ?? null,\n      text: m.text || '',\n      ts: m.ts || Date.now()\n    };\n    useAppStore.getState().appendChat(chatMsg);\n    vLog('chat', chatMsg);\n  });\n\n  // error: { code, message? }\n  s.on('error', (e: any) => {\n    console.warn('[error]', e);\n    const code = e?.code || 'error/unknown';\n    const map: Record<string, string> = {\n      'control/forbidden': 'You are not the leader.',\n      'control/stale_seq': 'Stale control sequence.',\n      'control/seq_gap': 'Control sequence gap detected.',\n      'rate/limited': 'Rate limited. Slow down.',\n      'payload/too_large': 'Payload too large.',\n      'room/full': 'Room is full.',\n      'auth/invalid_key': 'Invalid leader key.',\n      'origin_block': 'Origin not allowed.'\n    };\n    useAppStore.getState().pushToast('error', map[code] || code);\n  });\n}\n\n// outbound helpers\nexport function sendControl(kind: 'play' | 'pause' | 'seek', extra?: any) {\n  const state = useAppStore.getState();\n  const client_seq = state.allocateClientSeq();\n  const payload = { kind, client_seq, ...extra };\n  getSocket().emit('control', payload);\n  return client_seq;\n}\n\nexport function sendChat(text: string) {\n  getSocket().emit('chat_send', { text });\n}\n\nexport function initiateTimePing() {\n  if (timePingInflight) return; // wait for prior\n  timePingInflight = { ts: Date.now() };\n  getSocket().emit('time_ping', {});\n}\n\nexport function sendIdentityUpdate(name?: string, sprite?: string | null) {\n  const payload: any = {};\n  if (name) payload.name = name;\n  if (sprite) payload.sprite = sprite;\n  if (!payload.name && !payload.sprite) return;\n  vLog('identity_update_emit', payload);\n  getSocket().emit('identity_update', payload);\n}\n","import React, { useEffect, useRef, useState } from 'react';\nimport { useAppStore } from '../lib/store';\nimport { isVerbose, getSocket } from '../lib/socket';\n\ninterface Fragment { start_ms: number; end_ms: number; start_byte: number; end_byte: number; }\ninterface IndexJson { duration_ms: number; fragments: Fragment[]; }\n\ninterface Props { mediaUrl: string; indexUrl: string; mediaId: string; }\n\n// Minimal fMP4 append (single file) with basic first-chunk readiness emit.\nexport default function MediaPlayer({ mediaUrl, indexUrl, mediaId }: Props) {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const [mseReady, setMseReady] = useState(false);\n  const [fragments, setFragments] = useState<Fragment[]>([]);\n  const [durationMs, setDurationMs] = useState<number | null>(null);\n  const readiness = useAppStore(s => s.readiness);\n  const snapshot = useAppStore(s => s.snapshot);\n  const emittedRef = useRef(false);\n  const sourceBufferRef = useRef<SourceBuffer | null>(null);\n  const mediaSourceRef = useRef<MediaSource | null>(null);\n  const pendingFetchRef = useRef<AbortController | null>(null);\n\n  // Fetch index.json\n  useEffect(() => {\n    let aborted = false;\n    (async () => {\n      try {\n        const res = await fetch(indexUrl, { cache: 'no-store' });\n        if (!res.ok) return;\n        const data: IndexJson = await res.json();\n        if (aborted) return;\n        setFragments(data.fragments || []);\n        setDurationMs(data.duration_ms || null);\n        if (isVerbose()) console.debug('[wp] index_loaded', { count: data.fragments?.length, duration: data.duration_ms });\n      } catch (e) {\n        if (isVerbose()) console.debug('[wp] index_error', (e as any)?.message);\n      }\n    })();\n    return () => { aborted = true; };\n  }, [indexUrl]);\n\n  // Initialize MSE and append first fragment (init + first)\n  useEffect(() => {\n    let objectUrl: string | null = null;\n    const ms = new MediaSource();\n    mediaSourceRef.current = ms;\n    if (videoRef.current) {\n      objectUrl = URL.createObjectURL(ms);\n      videoRef.current.src = objectUrl;\n    }\n    const onOpen = () => {\n      try {\n        const sb = ms.addSourceBuffer('video/mp4; codecs=\"avc1.4d401e, mp4a.40.2\"');\n        sourceBufferRef.current = sb;\n        sb.addEventListener('error', () => { if (isVerbose()) console.debug('[wp] sb_error'); });\n        if (fragments.length) {\n          fetchAndAppendInitial();\n        }\n      } catch (e) {\n        if (isVerbose()) console.debug('[wp] mse_source_error', (e as any)?.message);\n      }\n    };\n    ms.addEventListener('sourceopen', onOpen);\n    return () => {\n      ms.removeEventListener('sourceopen', onOpen);\n      if (objectUrl) URL.revokeObjectURL(objectUrl);\n      if (pendingFetchRef.current) pendingFetchRef.current.abort();\n    };\n  }, [mediaUrl, mediaId]);\n\n  // When fragments arrive after MSE open, attempt initial append\n  useEffect(() => {\n    if (mediaSourceRef.current?.readyState === 'open' && sourceBufferRef.current && fragments.length && !emittedRef.current) {\n      fetchAndAppendInitial();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [fragments]);\n\n  function fetchAndAppendInitial() {\n    if (!fragments.length || !sourceBufferRef.current) return;\n    const first = fragments[0];\n    const rangeHeader = `bytes=${first.start_byte}-${first.end_byte}`;\n    const ac = new AbortController();\n    pendingFetchRef.current = ac;\n    fetch(mediaUrl, { headers: { Range: rangeHeader }, signal: ac.signal }).then(r => r.arrayBuffer()).then(buf => {\n      if (!sourceBufferRef.current) return;\n      sourceBufferRef.current.addEventListener('updateend', handleInitialAppended, { once: true });\n      sourceBufferRef.current.appendBuffer(buf);\n    }).catch(e => { if (isVerbose()) console.debug('[wp] init_fetch_error', (e as any)?.message); });\n  }\n\n  function handleInitialAppended() {\n    if (!emittedRef.current) {\n      emittedRef.current = true;\n      getSocket().emit('client_ready', { media_id: mediaId, first_appended: true });\n      if (isVerbose()) console.debug('[wp] client_ready emitted', { mediaId });\n    }\n    setMseReady(true);\n  }\n\n  // Sync play/pause & basic drift correction\n  useEffect(() => {\n    const v = videoRef.current; if (!v) return;\n    if (snapshot.playing) {\n      if (v.paused) v.play().catch(()=>{});\n    } else {\n      if (!v.paused) v.pause();\n    }\n    // Drift: compare video currentTime vs snapshot playhead\n    const targetMs = snapshot.playheadMs;\n    if (typeof targetMs === 'number' && mseReady) {\n      const currentMs = v.currentTime * 1000;\n      const drift = targetMs - currentMs;\n      const abs = Math.abs(drift);\n      if (abs > 500) {\n        v.currentTime = targetMs / 1000; // hard snap\n        if (isVerbose()) console.debug('[wp] drift_snap', { drift });\n      } else if (abs > 80) {\n        // small nudge by setting currentTime (simpler than rate tweak for MVP)\n        v.currentTime = targetMs / 1000;\n        if (isVerbose()) console.debug('[wp] drift_nudge', { drift });\n      }\n    }\n  }, [snapshot.playing, snapshot.playheadMs, mseReady]);\n\n  return (\n    <div className=\"relative w-full h-full bg-black\">\n      <video ref={videoRef} className=\"w-full h-full\" playsInline muted />\n      {!readiness.ready && (\n        <div className=\"absolute inset-0 flex items-center justify-center pointer-events-none\">\n          <div className=\"px-4 py-2 rounded bg-slate-900/80 text-xs font-medium\">\n            Syncing… ({readiness.readyCount}/{readiness.total})\n          </div>\n        </div>\n      )}\n      {durationMs && (\n        <div className=\"absolute bottom-2 right-2 text-[10px] opacity-60 bg-black/40 px-2 py-1 rounded\">\n          {(durationMs/1000).toFixed(0)}s\n        </div>\n      )}\n    </div>\n  );\n}\n","import { isVerbose } from './socket';\nimport { getRuntimeConfig } from './config';\n\nexport interface CatalogDir { name: string; path: string; }\nexport interface CatalogFile { id: string; title: string; masterUrl: string; poster: string | null; durationMs: number | null; }\nexport interface CatalogResponse { dirs: CatalogDir[]; files: CatalogFile[]; }\n\nlet cache: { ts: number; prefix: string; data: CatalogResponse } | null = null;\nconst CACHE_MS = 60000;\n\nexport async function fetchCatalog(prefix: string = ''): Promise<CatalogResponse> {\n  const now = Date.now();\n  if (cache && cache.prefix === prefix && (now - cache.ts) < CACHE_MS) {\n    return cache.data;\n  }\n  const config = getRuntimeConfig();\n  const origin = config.serverOrigin.replace(/\\/$/, '');\n  const url = `${origin}/api/catalog${prefix ? `?prefix=${encodeURIComponent(prefix)}` : ''}`;\n  const res = await fetch(url, { cache: 'no-store' });\n  if (!res.ok) throw new Error(`catalog_http_${res.status}`);\n  const data = await res.json();\n  if (isVerbose()) console.debug('[wp] catalog_fetch', { prefix, dirs: data.dirs?.length, files: data.files?.length });\n  cache = { ts: now, prefix, data };\n  return data;\n}\n\nexport function invalidateCatalog(prefix?: string) {\n  if (!cache) return;\n  if (!prefix || cache.prefix === prefix) cache = null;\n}\n","import { getSocket } from './socket';\nimport { useAppStore } from './store';\n\n// Unified control sender ensuring sequential client_seq for EVERY control (including load/home)\nexport function sendControl(kind: string, extra?: Record<string, any>) {\n  const st = useAppStore.getState();\n  const client_seq = st.allocateClientSeq();\n  const payload = { kind, client_seq, ...(extra || {}) };\n  getSocket().emit('control', payload);\n  return client_seq;\n}\n\nexport function sendLoad(mediaId: string) {\n  return sendControl('load', { media_id: mediaId });\n}\n\nexport function sendHome() {\n  return sendControl('home');\n}\n","import { fetchCatalog } from './catalog';\nimport { isVerbose } from './socket';\nimport { getRuntimeConfig } from './config';\n\n// Developer utility (verbose mode) to sanity check media catalog + sample media accessibility.\n// Invoked when MediaDrawer opens in verbose mode.\nexport async function probeMediaEndpoints() {\n  if (!isVerbose()) return;\n  try {\n    const categories = ['output/fmp4/anime','output/fmp4/movie','output/fmp4/tv'];\n    for (const cat of categories) {\n      const catData = await fetchCatalog(cat);\n      console.debug('[wp][probe] catalog', cat, { dirs: catData.dirs.length, files: catData.files.length });\n      // Try first playable leaf if present\n      const candidate = catData.files[0];\n      if (candidate) {\n        const base = mediaBase();\n        const indexUrl = `${base}/${candidate.id}/index.json`.replace(/\\\\/g,'/');\n        const mediaUrl = `${base}/${candidate.id}/output_frag.mp4`.replace(/\\\\/g,'/');\n        await fetchAndLog(indexUrl, 'index');\n        // Range fetch first ~1KB\n        await fetchAndLog(mediaUrl, 'fragment', { headers: { Range: 'bytes=0-1023' } });\n      }\n    }\n  } catch (err: any) {\n    console.debug('[wp][probe] error', err?.message || String(err));\n  }\n}\n\nfunction mediaBase() {\n  const config = getRuntimeConfig();\n  return config.mediaBase;\n}\n\nasync function fetchAndLog(url: string, label: string, init?: RequestInit) {\n  const t0 = performance.now();\n  const res = await fetch(url, init);\n  const ms = Math.round(performance.now() - t0);\n  console.debug('[wp][probe]', label, { url, status: res.status, ms, bytes: res.headers.get('content-length') });\n  return res;\n}\n","import React, { useCallback, useEffect, useMemo, useState } from 'react';\nimport { fetchCatalog, invalidateCatalog } from '../lib/catalog';\nimport { sendLoad, sendHome } from '../lib/controls';\nimport { isVerbose } from '../lib/socket';\nimport { probeMediaEndpoints } from '../lib/catalogProbe';\n\ninterface MediaDrawerProps { open: boolean; onClose: () => void; }\ninterface EpisodeNode { type: 'episode'; name: string; mediaId: string; }\ninterface SeriesNode { type: 'series'; name: string; episodes: EpisodeNode[]; expanded?: boolean; }\ninterface CategoryNode { type: 'category'; name: string; series: SeriesNode[]; expanded?: boolean; }\ntype MediaTree = CategoryNode[];\n\nexport const MediaDrawer: React.FC<MediaDrawerProps> = ({ open, onClose }) => {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [tree, setTree] = useState<MediaTree>([]);\n  const [filter, setFilter] = useState('');\n\n  const buildTree = useCallback(async () => {\n    setLoading(true); setError(null);\n    try {\n      const categories: { key: string; label: string }[] = [\n        { key: 'anime', label: 'Anime' },\n        { key: 'movie', label: 'Movie' },\n        { key: 'tv', label: 'TV' }\n      ];\n      const root = 'output/fmp4';\n      const result: MediaTree = [];\n      for (const cat of categories) {\n        const catPrefix = `${root}/${cat.key}`;\n        let catCatalog; try { catCatalog = await fetchCatalog(catPrefix); } catch { continue; }\n        const seriesNodes: SeriesNode[] = [];\n        for (const d of catCatalog.dirs) {\n          let seriesCatalog; try { seriesCatalog = await fetchCatalog(d.path); } catch { continue; }\n          const episodes: EpisodeNode[] = seriesCatalog.files.map(f => ({ type: 'episode', name: f.title, mediaId: f.id }));\n          if (episodes.length) seriesNodes.push({ type: 'series', name: d.name, episodes, expanded: false });\n        }\n        if (seriesNodes.length) result.push({ type: 'category', name: cat.label, series: seriesNodes, expanded: true });\n      }\n      setTree(result);\n      if (isVerbose()) probeMediaEndpoints();\n    } catch (e:any) {\n      setError(e.message || 'catalog_error');\n    } finally { setLoading(false); }\n  }, []);\n\n  useEffect(() => { if (open) buildTree(); }, [open, buildTree]);\n\n  function handleEpisodeSelect(mediaId: string) {\n    sendLoad(mediaId);\n    if (isVerbose()) console.debug('[wp] control_load', mediaId);\n    onClose();\n  }\n  function handleHome() {\n    sendHome();\n    if (isVerbose()) console.debug('[wp] control_home');\n    onClose();\n  }\n  function toggleSeries(ci: number, si: number) {\n    setTree(t => t.map((c,i)=> i!==ci? c : ({ ...c, series: c.series.map((s,j)=> j!==si? s : ({ ...s, expanded: !s.expanded })) })));\n  }\n  function toggleCategory(ci: number) {\n    setTree(t => t.map((c,i)=> i!==ci? c : ({ ...c, expanded: !c.expanded })));\n  }\n  function refreshAll() {\n    invalidateCatalog('');\n    buildTree();\n  }\n\n  const filteredTree = useMemo(() => {\n    if (!filter.trim()) return tree;\n    const q = filter.toLowerCase();\n    return tree.map(cat => {\n      const seriesFiltered = cat.series.map(s => {\n        const eps = s.episodes.filter(e => e.name.toLowerCase().includes(q));\n        if (eps.length) return { ...s, episodes: eps, expanded: true } as SeriesNode;\n        if (s.name.toLowerCase().includes(q)) return { ...s, expanded: true } as SeriesNode;\n        return null;\n      }).filter(Boolean) as SeriesNode[];\n      if (seriesFiltered.length) return { ...cat, series: seriesFiltered, expanded: true } as CategoryNode;\n      if (cat.name.toLowerCase().includes(q)) return { ...cat, expanded: true } as CategoryNode;\n      return null;\n    }).filter(Boolean) as MediaTree;\n  }, [tree, filter]);\n\n  if (!open) return null;\n\n  return (\n    <div className=\"fixed inset-0 bg-black/40 flex justify-end z-40\">\n      <div className=\"w-[440px] h-full bg-gray-950 border-l border-gray-800 flex flex-col\">\n        <div className=\"p-3 border-b border-gray-800 flex items-center gap-2 text-sm\">\n          <button onClick={onClose} className=\"px-2 py-1 bg-gray-800 hover:bg-gray-700 rounded\">Close</button>\n          <button onClick={handleHome} className=\"px-2 py-1 bg-indigo-600 hover:bg-indigo-500 rounded\">Home</button>\n          <button onClick={refreshAll} className=\"px-2 py-1 bg-gray-800 hover:bg-gray-700 rounded\">Reload</button>\n          <input value={filter} onChange={e=>setFilter(e.target.value)} placeholder=\"search\" className=\"ml-auto bg-gray-900 border border-gray-700 focus:border-gray-500 outline-none px-2 py-1 rounded text-xs\" />\n        </div>\n        {loading && <div className=\"px-4 py-2 text-xs text-gray-500\">Loading catalog…</div>}\n        {error && <div className=\"px-4 py-2 text-xs text-red-400\">{error}</div>}\n        <div className=\"flex-1 overflow-auto text-sm py-2\">\n          {filteredTree.map((cat, ci) => (\n            <div key={cat.name} className=\"px-3 pb-3\">\n              <div className=\"flex items-center gap-2 cursor-pointer select-none group\" onClick={()=>toggleCategory(ci)}>\n                <span className=\"text-xs uppercase tracking-wider text-gray-500 group-hover:text-gray-300\">{cat.name}</span>\n                <span className=\"text-[10px] opacity-50\">{cat.expanded? '−':'+'}</span>\n              </div>\n              {cat.expanded && (\n                <div className=\"mt-2 space-y-2\">\n                  {cat.series.map((s, si) => (\n                    <div key={s.name}>\n                      <div className=\"flex items-center gap-2 cursor-pointer text-gray-300 hover:text-white\" onClick={()=>toggleSeries(ci, si)}>\n                        <span className=\"text-xs font-medium\">{s.name}</span>\n                        <span className=\"text-[10px] opacity-40\">{s.expanded? '−':'+'}</span>\n                      </div>\n                      {s.expanded && (\n                        <div className=\"mt-1 ml-3 border-l border-gray-800 pl-3 space-y-1\">\n                          {s.episodes.map(ep => (\n                            <button key={ep.mediaId} onClick={()=>handleEpisodeSelect(ep.mediaId)} className=\"w-full text-left px-2 py-1 rounded hover:bg-gray-900 flex items-center gap-2 group\">\n                              <span className=\"text-[11px] text-gray-400 group-hover:text-gray-200 truncate\">{ep.name}</span>\n                              <span className=\"ml-auto text-[10px] text-indigo-400 opacity-0 group-hover:opacity-100 transition-opacity\">Load</span>\n                            </button>\n                          ))}\n                          {s.episodes.length === 0 && <div className=\"text-[11px] text-gray-600 italic\">(no episodes)</div>}\n                        </div>\n                      )}\n                    </div>\n                  ))}\n                  {cat.series.length === 0 && <div className=\"text-[11px] text-gray-600 italic\">(empty)</div>}\n                </div>\n              )}\n            </div>\n          ))}\n          {!loading && !filteredTree.length && <div className=\"px-4 py-6 text-center text-xs text-gray-600\">No matches</div>}\n        </div>\n        <div className=\"p-2 text-[10px] text-gray-600 border-t border-gray-900 flex justify-between\">\n          <span>Simple Catalog</span>\n          {isVerbose() && <span className=\"opacity-70\">verbose</span>}\n        </div>\n      </div>\n    </div>\n  );\n};\n","import React, { useEffect, useState } from 'react';\nimport { useAppStore } from '../lib/store';\nimport PixelAvatar from './PixelAvatar';\nimport { sendIdentityUpdate } from '../lib/socket';\nimport { CHARACTER_ORDER, spriteUrlFor } from '../lib/characters';\n\ninterface Props { open: boolean; onClose: () => void; onJoin: () => void; }\n\nexport default function CharacterDrawer({ open, onClose }: Props) {\n  const { name, sprite, setIdentity } = useAppStore();\n  const [localName, setLocalName] = useState(name);\n  const [localSprite, setLocalSprite] = useState<string | null>(sprite);\n  const [mounted, setMounted] = useState(open);\n  useEffect(() => {\n    if (open) {\n      setMounted(true);\n    } else {\n      const t = setTimeout(() => setMounted(false), 320); // allow transition\n      return () => clearTimeout(t);\n    }\n  }, [open]);\n\n  const updateIdentity = () => {\n    const finalName = (localName || '').trim().slice(0,32) || 'Guest';\n    setIdentity(finalName, localSprite);\n    sendIdentityUpdate(finalName, localSprite || undefined);\n    onClose();\n  };\n\n  if (!mounted) return null;\n\n  return (\n    <div aria-hidden={!open} className={`fixed inset-y-0 right-0 w-80 bg-slate-900/95 backdrop-blur border-l border-slate-700 transition-transform duration-300 z-30 flex flex-col ${open ? 'translate-x-0' : 'translate-x-full'} ${open ? '' : 'pointer-events-none'}`}>\n      <div className=\"p-4 flex items-center justify-between border-b border-slate-700\">\n        <h2 className=\"font-semibold text-sm\">Identity</h2>\n  <button type=\"button\" onClick={onClose} role=\"button\" className=\"text-xs opacity-70 hover:opacity-100 select-none\">Close</button>\n      </div>\n      <div className=\"p-4 space-y-4 overflow-y-auto text-sm\">\n        <div>\n          <label className=\"block text-xs uppercase tracking-wide mb-1 opacity-70\">Display Name</label>\n          <input value={localName} onChange={e=>setLocalName(e.target.value)} className=\"w-full bg-slate-800 border border-slate-600 rounded px-2 py-1 text-sm\" placeholder=\"Your name\" />\n        </div>\n        <div>\n          <label className=\"block text-xs uppercase tracking-wide mb-1 opacity-70\">Character</label>\n          <div className=\"grid grid-cols-4 gap-3\">\n            {CHARACTER_ORDER.map(c => (\n              <button key={c} onClick={()=>{ setLocalSprite(c); if (!localName.trim() || CHARACTER_ORDER.includes(localName as any) || localName === 'Guest') setLocalName(c); }} className={`relative group rounded border ${localSprite===c ? 'border-emerald-400' : 'border-slate-600 hover:border-slate-400'} p-1 flex flex-col items-center gap-1`}> \n                <img src={spriteUrlFor(c)} alt={c} className=\"w-12 h-12 object-cover rounded\" />\n                <span className=\"text-[10px] opacity-70 group-hover:opacity-100 capitalize\">{c}</span>\n              </button>\n            ))}\n          </div>\n        </div>\n        <div className=\"pt-2 flex gap-2 items-center\">\n          <button onClick={updateIdentity} className=\"bg-emerald-500 hover:bg-emerald-400 text-black font-semibold text-sm px-3 py-1 rounded\">Update</button>\n        </div>\n      </div>\n    </div>\n  );\n}\n","import React, { useEffect, useMemo, useRef, useState } from 'react';\nimport StarfieldCanvas from '../components/StarfieldCanvas';\nimport Roster from '../components/Roster';\nimport MediaPlayer from '../components/MediaPlayer';\nimport { MediaDrawer } from '../components/MediaDrawer';\nimport { useAppStore } from '../lib/store';\nimport CharacterDrawer from '../components/CharacterDrawer';\nimport { connectAndJoin } from '../lib/socket';\nimport { useParams } from 'react-router-dom';\nimport { useConfig } from '../lib/config';\n\nfunction resolveMedia(mediaId: string | null, mediaBase: string) {\n  if (!mediaId) return null;\n  // mediaId is a relative path under MEDIA_ROOT returned by server (catalog id)\n  const root = `${mediaBase.replace(/\\/$/, '')}/${mediaId}`.replace(/\\\\/g,'/');\n  return { mediaUrl: `${root}/output_frag.mp4`, indexUrl: `${root}/index.json` };\n}\n\nexport default function Room() {\n  const config = useConfig();\n  const snapshot = useAppStore(s => s.snapshot);\n  const { ensureAutoIdentity, name, sprite } = useAppStore();\n  const params = useParams();\n  const joinedRef = useRef(false);\n  const mediaInfo = useMemo(() => resolveMedia(snapshot.mediaId, config.mediaBase), [snapshot.mediaId, config.mediaBase]);\n  const [drawerOpen, setDrawerOpen] = useState(false);\n  const [identityOpen, setIdentityOpen] = useState(false);\n  useEffect(() => {\n    if (joinedRef.current) return;\n    const sp = new URLSearchParams(window.location.search);\n    const roomKey = params.roomKey || sp.get('room') || config.defaultRoomKey;\n    ensureAutoIdentity();\n    // Accept multiple casings for leader key param\n    const leaderKeyParam = sp.get('leaderKey') || sp.get('leaderkey') || sp.get('leader_key') || undefined;\n    // Only send leader_key if explicitly supplied (no implicit dev fallback granting everyone leader rights)\n    connectAndJoin({ room_key: roomKey, leader_key: leaderKeyParam || null, name: name || undefined, sprite: sprite || undefined });\n    joinedRef.current = true;\n  }, [params.roomKey, ensureAutoIdentity, name, sprite, config.defaultRoomKey]);\n  const isLeader = useAppStore(s => !!s.snapshot.leaderId && s.snapshot.leaderId === s.me.clientId);\n\n  function openMedia() {\n    setIdentityOpen(false);\n    setDrawerOpen(true);\n  }\n  function openIdentity() {\n    setDrawerOpen(false);\n    setIdentityOpen(true);\n  }\n  function closeMedia() { setDrawerOpen(false); }\n  function closeIdentity() { setIdentityOpen(false); }\n  return (\n    <div className=\"relative min-h-[calc(100vh-120px)] flex\">\n      <div className=\"flex-1 relative bg-black\">\n        {mediaInfo ? (\n          <MediaPlayer mediaUrl={mediaInfo.mediaUrl} indexUrl={mediaInfo.indexUrl} mediaId={snapshot.mediaId!} />\n        ) : (\n          <>\n            <StarfieldCanvas />\n            <div className=\"absolute inset-0 flex flex-col items-center justify-center gap-4 p-6\">\n              {/* Removed placeholder instructional texts per spec */}\n              <div className=\"mt-6 p-3 rounded bg-slate-900/70 border border-slate-700/40 backdrop-blur-sm\">\n                <Roster />\n              </div>\n            </div>\n          </>\n        )}\n        {isLeader && !drawerOpen && (\n          <button onClick={openMedia} className=\"fixed bottom-4 left-1/2 -translate-x-1/2 z-40 bg-indigo-600 hover:bg-indigo-500 text-xs px-4 py-2 rounded shadow\">\n            Media\n          </button>\n        )}\n      </div>\n      <aside className=\"w-80 border-l border-slate-800 p-4 hidden md:block text-xs opacity-70\">\n        Chat panel placeholder (Phase 5)\n      </aside>\n      <MediaDrawer open={drawerOpen} onClose={closeMedia} />\n      <CharacterDrawer open={identityOpen} onClose={closeIdentity} onJoin={()=>{}} />\n      {!identityOpen && (\n        <button onClick={openIdentity} className=\"fixed bottom-4 right-4 bg-slate-800/80 hover:bg-slate-700 border border-slate-600 text-xs px-3 py-1 rounded shadow backdrop-blur z-40\">Identity</button>\n      )}\n    </div>\n  );\n}\n","import React from 'react';\nimport StarfieldCanvas from './StarfieldCanvas';\n\nexport default function APIDownFallback() {\n  return (\n    <div className=\"fixed inset-0 bg-black\">\n      <StarfieldCanvas />\n      <div className=\"absolute inset-0 flex items-center justify-center\">\n        <div className=\"text-center\">\n          <h1 className=\"text-4xl font-bold text-white mb-4\">\n            API is sleeping...\n          </h1>\n          <p className=\"text-slate-400 text-lg\">\n            ༼ つ ◕_◕ ༽つ HADOKU TAKE MY ENERGY ༼ つ ◕_◕ ༽つ\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n}\n","import React, { useEffect, useState } from 'react';\nimport { Link, Outlet, useLocation, useNavigate, useParams } from 'react-router-dom';\nimport Toasts from './components/Toasts';\nimport { CHARACTER_ORDER, spriteUrlFor } from './lib/characters';\nimport Home from './routes/Home';\nimport Room from './routes/Room';\nimport APIDownFallback from './components/APIDownFallback';\nimport { ConfigContext, DEFAULT_CONFIG, type WatchpartyConfig } from './lib/config';\n\nfunction RouteBody() {\n  const loc = useLocation();\n  const nav = useNavigate();\n  const params = useParams();\n  // Query param based roomKey redirect\n  useEffect(() => {\n    const sp = new URLSearchParams(window.location.search);\n    const rk = sp.get('roomKey') || sp.get('room');\n    if (rk && (loc.pathname === '/' || loc.pathname === '')) {\n      nav(`/room/${encodeURIComponent(rk)}`, { replace: true });\n    }\n  }, [loc.pathname, nav]);\n  if (loc.pathname === '/' || loc.pathname === '') return <Home />;\n  if (loc.pathname.startsWith('/room')) return <Room />;\n  return <div className=\"p-6\">Not Found</div>;\n}\n\nexport type AppProps = {\n  serverOrigin?: string;\n  defaultRoomKey?: string;\n  mediaBase?: string;\n};\n\nexport default function App(props: AppProps) {\n  const [apiDown, setApiDown] = useState(false);\n  const [checking, setChecking] = useState(true);\n\n  // Merge props with defaults\n  const config: WatchpartyConfig = {\n    serverOrigin: props.serverOrigin || DEFAULT_CONFIG.serverOrigin,\n    defaultRoomKey: props.defaultRoomKey || DEFAULT_CONFIG.defaultRoomKey,\n    mediaBase: props.mediaBase || DEFAULT_CONFIG.mediaBase,\n  };\n\n  // Check API health on mount\n  useEffect(() => {\n    async function checkHealth() {\n      const origin = config.serverOrigin.replace(/\\/$/, '');\n      const url = origin + '/healthz';\n      try {\n        const res = await fetch(url, { \n          cache: 'no-store',\n          signal: AbortSignal.timeout(5000) // 5s timeout\n        });\n        if (res.ok) {\n          setApiDown(false);\n        } else {\n          setApiDown(true);\n        }\n      } catch (e) {\n        setApiDown(true);\n      } finally {\n        setChecking(false);\n      }\n    }\n    checkHealth();\n  }, [config.serverOrigin]);\n\n  // Defer sprite preloading until after page load & idle to avoid early aborted requests noise.\n  useEffect(() => {\n    function preloadAll() {\n      for (const c of CHARACTER_ORDER) {\n        const img = new Image();\n        img.decoding = 'async';\n        img.loading = 'eager';\n        img.src = spriteUrlFor(c);\n      }\n    }\n    function schedule() {\n      if ('requestIdleCallback' in window) {\n        (window as any).requestIdleCallback(preloadAll, { timeout: 2000 });\n      } else {\n        setTimeout(preloadAll, 600);\n      }\n    }\n    if (document.readyState === 'complete') schedule(); else window.addEventListener('load', schedule, { once: true });\n  }, []);\n\n  // Show loading state briefly while checking\n  if (checking) {\n    return (\n      <div className=\"min-h-screen flex items-center justify-center bg-black\">\n        <div className=\"text-slate-400\">Checking server status...</div>\n      </div>\n    );\n  }\n\n  // Show fallback if API is down\n  if (apiDown) {\n    return <APIDownFallback />;\n  }\n\n  return (\n    <ConfigContext.Provider value={config}>\n      <div className=\"min-h-screen flex flex-col\">\n        <header className=\"p-3 border-b border-slate-700 flex items-center gap-4 text-sm\">\n          <Link to=\"/\" className=\"font-semibold\">Watchparty</Link>\n        </header>\n        <main className=\"flex-1\">\n          <RouteBody />\n          <Outlet />\n        </main>\n        <Toasts />\n      </div>\n    </ConfigContext.Provider>\n  );\n}\n","import type { RouteObject } from 'react-router-dom';\nimport { createBrowserRouter } from 'react-router-dom';\nimport App, { type AppProps } from './App';\n\nexport interface CreateWatchpartyRouterOptions {\n  basename?: string;\n  appProps?: AppProps;\n}\n\nexport function createWatchpartyRouter(\n  { basename = '/watchparty', appProps }: CreateWatchpartyRouterOptions = {},\n) {\n  const resolvedAppProps = appProps ?? ({} as AppProps);\n  const routes: RouteObject[] = [\n    { path: '/', element: <App {...resolvedAppProps} /> },\n    { path: '/room/:roomKey', element: <App {...resolvedAppProps} /> },\n  ];\n\n  return createBrowserRouter(routes, { basename });\n}\n","import React from 'react';\nimport { createRoot, type Root } from 'react-dom/client';\nimport { RouterProvider } from 'react-router-dom';\nimport type { AppProps } from './App';\nimport { createWatchpartyRouter } from './router';\nimport { setRuntimeConfig } from './lib/config';\nimport './styles.css';\n\nexport type { AppProps } from './App';\nexport { createWatchpartyRouter } from './router';\nexport type { CreateWatchpartyRouterOptions } from './router';\n\nexport type WatchpartyMountProps = AppProps & {\n  basename?: string;\n  strictMode?: boolean;\n};\n\ntype MountedInstance = {\n  root: Root;\n};\n\nfunction render(el: HTMLElement, routerContent: React.ReactElement, strictMode: boolean) {\n  const root = createRoot(el);\n  const element = strictMode ? (\n    <React.StrictMode>{routerContent}</React.StrictMode>\n  ) : (\n    routerContent\n  );\n  root.render(element);\n  return root;\n}\n\nexport function mount(el: HTMLElement, props: WatchpartyMountProps = {}) {\n  const { basename, strictMode = true, ...appProps } = props;\n  \n  // Set runtime config for non-component code (socket, catalog, etc.)\n  setRuntimeConfig({\n    serverOrigin: appProps.serverOrigin,\n    defaultRoomKey: appProps.defaultRoomKey,\n    mediaBase: appProps.mediaBase,\n  });\n  \n  const existing = (el as any).__watchparty as MountedInstance | undefined;\n  existing?.root.unmount();\n  const router = createWatchpartyRouter({\n    basename,\n    appProps: appProps as AppProps,\n  });\n  const root = render(el, <RouterProvider router={router} />, strictMode);\n  const instance: MountedInstance = { root };\n  (el as any).__watchparty = instance;\n  return router;\n}\n\nexport function unmount(el: HTMLElement) {\n  const instance = (el as any).__watchparty as MountedInstance | undefined;\n  instance?.root.unmount();\n  if (instance) {\n    delete (el as any).__watchparty;\n  }\n}\n"],"names":["REACT_ELEMENT_TYPE","REACT_FRAGMENT_TYPE","jsxProd","type","config","maybeKey","key","propName","reactJsxRuntime_production","jsxRuntimeModule","require$$0","React","formatProdErrorMessage","code","url","i","noop","Internals","REACT_PORTAL_TYPE","createPortal$1","children","containerInfo","implementation","ReactSharedInternals","getCrossOriginStringAs","as","input","reactDom_production","container","fn","previousTransition","previousUpdatePriority","href","options","crossOrigin","integrity","fetchPriority","form","a","action","initialState","permalink","checkDCE","err","reactDomModule","_extends","target","source","Action","PopStateEventType","createBrowserHistory","createBrowserLocation","window","globalHistory","pathname","search","hash","createLocation","createBrowserHref","to","createPath","getUrlBasedHistory","invariant","value","message","warning","cond","createKey","getHistoryState","location","index","current","state","parsePath","_ref","path","parsedPath","hashIndex","searchIndex","getLocation","createHref","validateLocation","v5Compat","listener","getIndex","handlePop","nextIndex","delta","history","push","historyState","error","replace","createURL","base","n","ResultType","immutableRouteKeys","isIndexRoute","route","convertRoutesToDataRoutes","routes","mapRouteProperties","parentPath","manifest","treePath","id","indexRoute","pathOrLayoutRoute","matchRoutes","locationArg","basename","matchRoutesImpl","allowPartial","stripBasename","branches","flattenRoutes","rankRouteBranches","matches","decoded","decodePath","matchRouteBranch","convertRouteMatchToUiMatch","match","loaderData","params","parentsMeta","flattenRoute","relativePath","meta","joinPaths","routesMeta","computeScore","_route$path","exploded","explodeOptionalSegments","segments","first","rest","isOptional","required","restExploded","result","subpath","b","compareIndexes","paramRe","dynamicSegmentValue","indexRouteValue","emptySegmentValue","staticSegmentValue","splatPenalty","isSplat","s","initialScore","score","segment","branch","matchedParams","matchedPathname","end","remainingPathname","matchPath","normalizePathname","pattern","matcher","compiledParams","compilePath","pathnameBase","captureGroups","memo","paramName","splatValue","caseSensitive","regexpSource","_","v","startIndex","nextChar","resolvePath","fromPathname","toPathname","resolvePathname","normalizeSearch","normalizeHash","getInvalidPathError","char","field","dest","getPathContributingMatches","getResolveToMatches","v7_relativeSplatPath","pathMatches","idx","resolveTo","toArg","routePathnames","locationPathname","isPathRelative","isEmptyPath","from","routePathnameIndex","toSegments","hasExplicitTrailingSlash","hasCurrentTrailingSlash","paths","ErrorResponseImpl","status","statusText","data","internal","isRouteErrorResponse","validMutationMethodsArr","validMutationMethods","validRequestMethodsArr","validRequestMethods","redirectStatusCodes","redirectPreserveMethodStatusCodes","IDLE_NAVIGATION","IDLE_FETCHER","IDLE_BLOCKER","ABSOLUTE_URL_REGEX","defaultMapRouteProperties","TRANSITIONS_STORAGE_KEY","createRouter","init","routerWindow","isBrowser","isServer","detectErrorBoundary","dataRoutes","inFlightDataRoutes","dataStrategyImpl","defaultDataStrategy","patchRoutesOnNavigationImpl","future","unlistenHistory","subscribers","savedScrollPositions","getScrollRestorationKey","getScrollPosition","initialScrollRestored","initialMatches","initialMatchesIsFOW","initialErrors","getInternalRouterError","getShortCircuitMatches","checkFogOfWar","initialized","m","errors","shouldLoadRouteOnHydration","fogOfWar","router","pendingAction","pendingPreventScrollReset","pendingNavigationController","pendingViewTransitionEnabled","appliedViewTransitions","removePageHideEventListener","isUninterruptedRevalidation","isRevalidationRequired","cancelledDeferredRoutes","cancelledFetcherLoads","fetchControllers","incrementingLoadId","pendingNavigationLoadId","fetchReloadIds","fetchRedirectIds","fetchLoadMatches","activeFetchers","deletedFetchers","activeDeferreds","blockerFunctions","unblockBlockerHistoryUpdate","initialize","historyAction","blockerKey","shouldBlockNavigation","nextHistoryUpdatePromise","resolve","updateBlocker","blockers","updateState","startNavigation","restoreAppliedTransitions","_saveAppliedTransitions","persistAppliedTransitions","dispose","deleteFetcher","deleteBlocker","subscribe","newState","opts","completedFetchers","deletedFetchersKeys","fetcher","subscriber","completeNavigation","_temp","_location$state","_location$state2","flushSync","isActionReload","isMutationMethod","actionData","mergeLoaderData","k","preventScrollReset","viewTransitionOpts","priorPaths","toPaths","getSavedScrollPosition","navigate","normalizedPath","normalizeTo","submission","normalizeNavigateOptions","currentLocation","nextLocation","userReplace","revalidate","interruptActiveLoads","saveScrollPosition","routesToUse","loadingNavigation","isHashChangeOnly","notFoundMatches","handleNavigational404","request","createClientSideRequest","pendingActionResult","findNearestBoundary","actionResult","handleAction","routeId","isErrorResult","getLoadingNavigation","shortCircuited","updatedMatches","handleLoaders","getActionDataForCommit","isFogOfWar","navigation","getSubmittingNavigation","discoverResult","discoverRoutes","boundaryId","actionMatch","getTargetMatch","callDataStrategy","isRedirectResult","normalizeRedirectLocation","startRedirectNavigation","isDeferredResult","boundaryMatch","overrideNavigation","fetcherSubmission","initialHydration","activeSubmission","getSubmissionFromNavigation","shouldUpdateNavigationState","getUpdatedActionData","matchesToLoad","revalidatingFetchers","getMatchesToLoad","cancelActiveDeferreds","updatedFetchers","markFetchRedirectsDone","updates","getUpdatedRevalidatingFetchers","rf","abortFetcher","abortPendingFetchRevalidations","f","loaderResults","fetcherResults","callLoadersAndMaybeResolveData","redirect","findRedirect","processLoaderData","deferredData","aborted","didAbortFetchLoads","abortStaleFetchLoads","shouldUpdateFetchers","revalidatingFetcher","getLoadingFetcher","fetch","setFetcherError","handleFetcherAction","handleFetcherLoader","requestMatches","detectAndHandle405Error","existingFetcher","updateFetcherState","getSubmittingFetcher","abortController","fetchRequest","originatingLoadId","getDoneFetcher","revalidationRequest","loadId","loadFetcher","staleKey","r","doneFetcher","resolveDeferredData","isNavigation","_temp2","redirectLocation","isDocumentReload","redirectHistoryAction","formMethod","formAction","formEncType","fetcherKey","results","dataResults","callDataStrategyImpl","e","isRedirectDataStrategyResultResult","response","normalizeRelativeRoutingRedirectResponse","convertDataStrategyResultToDataResult","fetchersToLoad","currentMatches","loaderResultsPromise","fetcherResultsPromise","acc","resolveNavigationDeferredResults","resolveFetcherDeferredResults","getFetcher","deleteFetcherAndUpdateState","count","controller","markFetchersDone","keys","doneKeys","landedId","yeetedKeys","getBlocker","blocker","newBlocker","_ref2","entries","blockerFunction","predicate","cancelledRouteIds","dfd","enableScrollRestoration","positions","getPosition","getKey","y","getScrollKey","signal","partialMatches","isNonHMR","localManifest","patchRoutesImpl","newMatches","newPartialMatches","_internalSetRoutes","newRoutes","patchRoutes","isSubmissionNavigation","prependBasename","fromRouteId","relative","contextualMatches","activeRouteMatch","nakedIndex","hasNakedIndexQuery","indexValues","qs","normalizeFormMethod","isFetcher","isValidMethod","getInvalidBodyError","rawFormMethod","stripHashFromPath","text","_ref3","name","json","searchParams","formData","convertFormDataToSearchParams","convertSearchParamsToFormData","getLoaderMatchesUntilBoundary","includeBoundary","skipActionErrorRevalidation","currentUrl","nextUrl","boundaryMatches","actionStatus","shouldSkipRevalidation","navigationMatches","isNewLoader","currentRouteMatch","nextRouteMatch","shouldRevalidateLoader","isNewRouteInstance","fetcherMatches","fetcherMatch","shouldRevalidate","hasData","hasError","currentLoaderData","currentMatch","isNew","isMissingData","currentPath","loaderMatch","arg","routeChoice","_childrenToPatch","childrenToPatch","uniqueChildren","newRoute","existingRoute","isSameRoute","aChild","_existingRoute$childr","bChild","loadLazyRouteModule","lazyRoute","routeToUpdate","routeUpdates","lazyRouteProperty","isPropertyStaticallyDefined","_ref4","requestContext","loadRouteDefinitionsPromises","dsMatches","loadRoutePromise","shouldLoad","handlerOverride","callLoaderOrAction","staticContext","onReject","runHandler","handler","reject","abortPromise","actualHandler","ctx","handlerPromise","handlerError","dataStrategyResult","isResponse","contentType","isDataWithResponseInit","_result$init3","_result$init4","_result$init","_result$init2","isDeferredData","_result$init5","_result$init6","_result$init7","_result$init8","trimmedMatches","normalizedLocation","isSameBasename","processRouteLoaderData","skipLoaderErrorBubbling","statusCode","foundError","loaderHeaders","pendingError","newLoaderData","mergedLoaderData","_temp5","method","errorMessage","deferred","isRevalidatingLoader","unwrap","_window","transitions","sessionPositions","DataRouterContext","DataRouterStateContext","NavigationContext","LocationContext","RouteContext","RouteErrorContext","useHref","useInRouterContext","UNSAFE_invariant","navigator","useResolvedPath","joinedPathname","useLocation","useIsomorphicLayoutEffect","cb","useNavigate","isDataRoute","useNavigateStable","useNavigateUnstable","dataRouterContext","routePathnamesJson","UNSAFE_getResolveToMatches","activeRef","OutletContext","useOutlet","context","outlet","useParams","routeMatch","useRoutesImpl","dataRouterState","parentMatches","parentParams","parentPathnameBase","locationFromContext","parentSegments","_renderMatches","DefaultErrorComponent","useRouteError","stack","preStyles","defaultErrorElement","RenderErrorBoundary","props","errorInfo","RenderedRoute","routeContext","_dataRouterState","_future","renderedMatches","errorIndex","renderFallback","fallbackIndex","needsToRunLoader","shouldRenderHydrateFallback","errorElement","hydrateFallbackElement","warningOnce","getChildren","DataRouterHook","DataRouterStateHook","useDataRouterContext","hookName","useDataRouterState","useRouteContext","useCurrentRouteId","thisRoute","_state$errors","alreadyWarned$1","logV6DeprecationWarnings","renderFuture","routerFuture","Outlet","Router","_ref5","basenameProp","locationProp","navigationType","staticProp","navigationContext","locationContext","trailingPathname","_objectWithoutPropertiesLoose","excluded","sourceKeys","isModifiedEvent","event","shouldProcessLinkClick","_excluded","REACT_ROUTER_VERSION","createBrowserRouter","parseHydrationData","UNSAFE_mapRouteProperties","deserializeErrors","serialized","val","UNSAFE_ErrorResponseImpl","ErrorConstructor","ViewTransitionContext","FetchersContext","START_TRANSITION","startTransitionImpl","FLUSH_SYNC","flushSyncImpl","ReactDOM","startTransitionSafe","flushSyncSafe","Deferred","reason","RouterProvider","fallbackElement","setStateImpl","pendingState","setPendingState","vtContext","setVtContext","renderDfd","setRenderDfd","transition","setTransition","interruption","setInterruption","fetcherData","v7_startTransition","optInStartTransition","setState","isViewTransitionUnavailable","t","renderPromise","UNSAFE_logV6DeprecationWarnings","UNSAFE_DataRouterContext","UNSAFE_DataRouterStateContext","MemoizedDataRoutes","DataRoutes","UNSAFE_useRoutesImpl","Link","_ref7","ref","onClick","reloadDocument","viewTransition","UNSAFE_NavigationContext","absoluteHref","isExternal","targetUrl","internalOnClick","useLinkClickHandler","handleClick","replaceProp","createStoreImpl","createState","listeners","partial","nextState","previousState","getState","api","__vite_import_meta_env__","createStore","is","x","objectIs","useState","useEffect","useLayoutEffect","useDebugValue","useSyncExternalStore$2","getSnapshot","_useState","inst","forceUpdate","checkIfSnapshotChanged","latestGetSnapshot","nextValue","useSyncExternalStore$1","shim","useSyncExternalStoreShim_production","shimModule","require$$1","useSyncExternalStore","useRef","useMemo","withSelector_production","getServerSnapshot","selector","isEqual","instRef","memoizedSelector","nextSnapshot","hasMemo","memoizedSnapshot","currentSelection","memoizedSelection","nextSelection","maybeGetServerSnapshot","withSelectorModule","ReactExports","useSyncExternalStoreWithSelector","useSyncExternalStoreExports","didWarnAboutEqualityFn","identity","useStore","equalityFn","slice","createImpl","useBoundStore","create","CHARACTER_ORDER","CHARACTER_COLORS","spriteUrlFor","character","ADMIN_KEY_STORAGE","useAppStore","set","get","sprite","used","c","remember","stored","clientId","snap","rosterUpdates","u","copy","clientSeq","serverSeq","rtt","serverTime","clientSendTs","rtts","offsetMs","clientMid","kind","msg","Toasts","toasts","pop","timers","jsx","STAR_COUNT","StarfieldCanvas","canvasRef","starsRef","canvas","resize","creationCounter","biasForIndex","makeStar","initial","creationIndex","bias","ultraRare","rare","colorRare","z","tri","min","max","u1","u2","sizeBase","sizeVariance","size","alpha","speedBase","speedScale","speed","normAlpha","normSize","cw","ch","twinkleAmount","twinkleEnabled","dimFloor","startVal","targetVal","duration","speedNorm","MIN_SEC","spanSec","exp","floorLift","lifeMsTotal","lastTime","drawCurvedBottomRect","bottomR","w","h","x0","y0","x1","y1","updateAlpha","dt","baseDur","jitter","p","eased","micro","updateColor","colors","cycle","next","c0","c1","rCol","gCol","bCol","render","now","deltaMs","OFFSCREEN_BUFFER","norm","scaled","newStar","baseAlphaRaw","FADE_MS","lifeFade","baseAlpha","starFillStyle","enhanced","len","ti","tp","linear","fade","scale","drawSize","headLeft","headTop","over","glowSize","Home","defaultRooms","jsxs","Roster","roster","users","color","PACKET_TYPES","PACKET_TYPES_REVERSE","ERROR_PACKET","withNativeBlob","withNativeArrayBuffer","isView","obj","encodePacket","supportsBinary","callback","encodeBlobAsBase64","fileReader","content","toArray","TEXT_ENCODER","encodePacketToBinary","packet","encoded","chars","lookup","decode","base64","bufferLength","encoded1","encoded2","encoded3","encoded4","arraybuffer","bytes","decodePacket","encodedPacket","binaryType","mapBinary","decodeBase64Packet","SEPARATOR","encodePayload","packets","length","encodedPackets","decodePayload","encodedPayload","decodedPacket","createPacketEncoderStream","payloadLength","header","view","TEXT_DECODER","totalLength","chunks","chunk","concatChunks","buffer","j","createPacketDecoderStream","maxPayload","expectedLength","isBinary","headerArray","protocol","Emitter","mixin","on","callbacks","args","nextTick","setTimeoutFn","globalThisShim","defaultBinaryType","pick","attr","NATIVE_SET_TIMEOUT","globalThis","NATIVE_CLEAR_TIMEOUT","installTimerFunctions","BASE64_OVERHEAD","byteLength","utf8Length","str","l","randomString","encode","qry","pairs","pair","TransportError","description","Transport","details","onPause","schema","query","hostname","encodedQuery","Polling","pause","total","close","hasCORS","empty","BaseXHR","isSSL","port","req","xhrStatus","Request","createRequest","uri","_a","xhr","fromError","unloadHandler","terminationEvent","hasXHR2","newRequest","XHR","forceBase64","xdomain","isReactNative","BaseWS","protocols","closeEvent","ev","lastPacket","WebSocketCtor","WS","_packet","WT","stream","decoderStream","reader","encoderStream","read","done","transports","re","parts","parse","src","pathNames","queryKey","regx","names","$0","$1","$2","withEventListeners","OFFLINE_EVENT_LISTENERS","SocketWithoutUpgrade","parsedUri","transportName","transport","delay","payloadSize","hasExpired","cleanupAndClose","waitForUpgrade","SocketWithUpgrade","failed","onTransportOpen","cleanup","freezeTransport","onerror","onTransportClose","onclose","onupgrade","upgrades","filteredUpgrades","o","DEFAULT_TRANSPORTS","loc","host","toString","withNativeFile","hasBinary","toJSON","deconstructPacket","buffers","packetData","pack","_deconstructPacket","placeholder","newData","reconstructPacket","_reconstructPacket","RESERVED_EVENTS","PacketType","Encoder","replacer","deconstruction","isObject","Decoder","reviver","isBinaryEvent","BinaryReconstructor","start","buf","payload","binData","Socket","io","nsp","_b","_c","ack","isTransportWritable","isConnected","timeout","timer","arg1","arg2","responseArgs","force","self","sent","pid","subDestroy","compress","Backoff","ms","rand","deviation","Manager","_parser","parser","Engine","socket","openSubDestroy","onError","errorSub","nsps","attempt","cache","parsed","sameNamespace","newConnection","DEFAULT_CONFIG","runtimeConfig","setRuntimeConfig","getRuntimeConfig","ConfigContext","createContext","useConfig","useContext","VERBOSE","sp","vLog","label","isVerbose","timePingInflight","timePingInterval","connectAndJoin","getSocket","sanitizeJoin","postJoinIdentity","st","origin","sid","wireCoreHandlers","st2","initiateTimePing","myId","myId2","stFinal","st3","newMediaId","rs","chatMsg","map","sendIdentityUpdate","MediaPlayer","mediaUrl","indexUrl","mediaId","videoRef","mseReady","setMseReady","fragments","setFragments","durationMs","setDurationMs","readiness","snapshot","emittedRef","sourceBufferRef","mediaSourceRef","pendingFetchRef","res","objectUrl","onOpen","sb","fetchAndAppendInitial","rangeHeader","ac","handleInitialAppended","targetMs","currentMs","drift","abs","CACHE_MS","fetchCatalog","prefix","invalidateCatalog","sendControl","extra","client_seq","sendLoad","sendHome","probeMediaEndpoints","categories","cat","catData","candidate","mediaBase","fetchAndLog","t0","MediaDrawer","open","onClose","loading","setLoading","setError","tree","setTree","filter","setFilter","buildTree","useCallback","root","catPrefix","catCatalog","seriesNodes","d","seriesCatalog","episodes","handleEpisodeSelect","handleHome","toggleSeries","ci","si","toggleCategory","refreshAll","filteredTree","q","seriesFiltered","eps","ep","CharacterDrawer","setIdentity","localName","setLocalName","localSprite","setLocalSprite","mounted","setMounted","updateIdentity","finalName","resolveMedia","Room","ensureAutoIdentity","joinedRef","mediaInfo","drawerOpen","setDrawerOpen","identityOpen","setIdentityOpen","roomKey","leaderKeyParam","isLeader","openMedia","openIdentity","closeMedia","closeIdentity","Fragment","APIDownFallback","RouteBody","nav","rk","App","apiDown","setApiDown","checking","setChecking","checkHealth","preloadAll","img","schedule","createWatchpartyRouter","appProps","resolvedAppProps","el","routerContent","strictMode","createRoot","element","mount","existing","instance","unmount"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45]}